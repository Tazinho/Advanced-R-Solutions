<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Advanced R Solutions</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="Solutions to the exercises in Hadley Wickham’s book Advanced R.">
  <meta name="generator" content="bookdown 0.3 and GitBook 2.6.7">

  <meta property="og:title" content="Advanced R Solutions" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="images/advrs_cover.png" />
  <meta property="og:description" content="Solutions to the exercises in Hadley Wickham’s book Advanced R." />
  <meta name="github-repo" content="Tazinho/Advanced-R-Solutions" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Advanced R Solutions" />
  
  <meta name="twitter:description" content="Solutions to the exercises in Hadley Wickham’s book Advanced R." />
  <meta name="twitter:image" content="images/advrs_cover.png" />

<meta name="author" content="Malte Grosser &amp; Henning Bumann">


<meta name="date" content="2017-04-10">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="oo-field-guide.html">
<link rel="next" href="exceptions-and-debugging.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<!-- COLLAPSIBLE TEXT WITH OPEN ALL/CLOSE ALL LINK -->

<!-- This goes into the HEAD of the html file -->

<script language="JavaScript" type="text/javascript">
<!-- Copyright 2007, Sandeep Gangadharan -->
<!-- For more free scripts go to http://www.sivamdesign.com/scripts/ -->
<!--
if (document.getElementById) {
 document.write('<style type="text/css">.texter {display:none; border-left:white 20px solid; color:#404040; font-family:verdana,arial,helvetica,sans-serif; font-size:9pt} @media print {.texter {display:block;}}</style>') }

 var divNum = new Array("a1","a2","a3");  // at the left you should add a1, a2 etc. for each header you wish to include
                                          // so if you want 4 headers you should add a1, a2, a3, a4 in the format shown
                                          // enclosed in double quotes
function openClose(theID) {
 for(var i=0; i < divNum.length; i++) {
  if (divNum[i] == theID) {
   if (document.getElementById(divNum[i]).style.display == "block") { document.getElementById(divNum[i]).style.display = "none" }
   else { document.getElementById(divNum[i]).style.display = "block" }
  }
  else { document.getElementById(divNum[i]).style.display = "none"; }
 }
}

function openAll() {
 for(var i=0; i < divNum.length; i++) {
   document.getElementById(divNum[i]).style.display = "block";
 }
}

function closeAll() {
 for(var i=0; i < divNum.length; i++) {
   document.getElementById(divNum[i]).style.display = "none";
 }
}
// -->
</script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>


  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="1" data-path="data-structures.html"><a href="data-structures.html"><i class="fa fa-check"></i><b>1</b> Data structures</a><ul>
<li class="chapter" data-level="1.1" data-path="data-structures.html"><a href="data-structures.html#vectors"><i class="fa fa-check"></i><b>1.1</b> Vectors</a></li>
<li class="chapter" data-level="1.2" data-path="data-structures.html"><a href="data-structures.html#attributes"><i class="fa fa-check"></i><b>1.2</b> Attributes</a></li>
<li class="chapter" data-level="1.3" data-path="data-structures.html"><a href="data-structures.html#matrices-and-arrays"><i class="fa fa-check"></i><b>1.3</b> Matrices and arrays</a></li>
<li class="chapter" data-level="1.4" data-path="data-structures.html"><a href="data-structures.html#data-frames"><i class="fa fa-check"></i><b>1.4</b> Data frames</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="subsetting.html"><a href="subsetting.html"><i class="fa fa-check"></i><b>2</b> Subsetting</a><ul>
<li class="chapter" data-level="2.1" data-path="subsetting.html"><a href="subsetting.html#data-types"><i class="fa fa-check"></i><b>2.1</b> Data types</a></li>
<li class="chapter" data-level="2.2" data-path="subsetting.html"><a href="subsetting.html#subsetting-operators"><i class="fa fa-check"></i><b>2.2</b> Subsetting operators</a></li>
<li class="chapter" data-level="2.3" data-path="subsetting.html"><a href="subsetting.html#applications"><i class="fa fa-check"></i><b>2.3</b> Applications</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="functions.html"><a href="functions.html"><i class="fa fa-check"></i><b>3</b> Functions</a><ul>
<li class="chapter" data-level="3.1" data-path="functions.html"><a href="functions.html#function-components"><i class="fa fa-check"></i><b>3.1</b> Function components</a></li>
<li class="chapter" data-level="3.2" data-path="functions.html"><a href="functions.html#lexical-scoping"><i class="fa fa-check"></i><b>3.2</b> Lexical Scoping</a></li>
<li class="chapter" data-level="3.3" data-path="functions.html"><a href="functions.html#function-arguments"><i class="fa fa-check"></i><b>3.3</b> Function arguments</a></li>
<li class="chapter" data-level="3.4" data-path="functions.html"><a href="functions.html#special-calls"><i class="fa fa-check"></i><b>3.4</b> Special calls</a></li>
<li class="chapter" data-level="3.5" data-path="functions.html"><a href="functions.html#return-values"><i class="fa fa-check"></i><b>3.5</b> Return Values</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="oo-field-guide.html"><a href="oo-field-guide.html"><i class="fa fa-check"></i><b>4</b> OO field guide</a><ul>
<li class="chapter" data-level="4.1" data-path="oo-field-guide.html"><a href="oo-field-guide.html#s3"><i class="fa fa-check"></i><b>4.1</b> S3</a></li>
<li class="chapter" data-level="4.2" data-path="oo-field-guide.html"><a href="oo-field-guide.html#s4"><i class="fa fa-check"></i><b>4.2</b> S4</a></li>
<li class="chapter" data-level="4.3" data-path="oo-field-guide.html"><a href="oo-field-guide.html#rc"><i class="fa fa-check"></i><b>4.3</b> RC</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="environments.html"><a href="environments.html"><i class="fa fa-check"></i><b>5</b> Environments</a><ul>
<li class="chapter" data-level="5.1" data-path="environments.html"><a href="environments.html#environment-basics"><i class="fa fa-check"></i><b>5.1</b> Environment basics</a></li>
<li class="chapter" data-level="5.2" data-path="environments.html"><a href="environments.html#recursing-over-environments"><i class="fa fa-check"></i><b>5.2</b> Recursing over environments</a></li>
<li class="chapter" data-level="5.3" data-path="environments.html"><a href="environments.html#function-environments"><i class="fa fa-check"></i><b>5.3</b> Function environments</a></li>
<li class="chapter" data-level="5.4" data-path="environments.html"><a href="environments.html#binding-names-to-values"><i class="fa fa-check"></i><b>5.4</b> Binding names to values</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="exceptions-and-debugging.html"><a href="exceptions-and-debugging.html"><i class="fa fa-check"></i><b>6</b> Exceptions and debugging</a><ul>
<li class="chapter" data-level="6.1" data-path="exceptions-and-debugging.html"><a href="exceptions-and-debugging.html#condition-handling"><i class="fa fa-check"></i><b>6.1</b> Condition handling</a></li>
<li class="chapter" data-level="6.2" data-path="exceptions-and-debugging.html"><a href="exceptions-and-debugging.html#defensive-programming"><i class="fa fa-check"></i><b>6.2</b> Defensive programming</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="functional-programming.html"><a href="functional-programming.html"><i class="fa fa-check"></i><b>7</b> Functional programming</a><ul>
<li class="chapter" data-level="7.1" data-path="functional-programming.html"><a href="functional-programming.html#annonymous-functions"><i class="fa fa-check"></i><b>7.1</b> Annonymous functions</a></li>
<li class="chapter" data-level="7.2" data-path="functional-programming.html"><a href="functional-programming.html#closures"><i class="fa fa-check"></i><b>7.2</b> Closures</a></li>
<li class="chapter" data-level="7.3" data-path="functional-programming.html"><a href="functional-programming.html#lists-of-functions"><i class="fa fa-check"></i><b>7.3</b> Lists of functions</a></li>
<li class="chapter" data-level="7.4" data-path="functional-programming.html"><a href="functional-programming.html#case-study-numerical-integration"><i class="fa fa-check"></i><b>7.4</b> Case study: numerical integration</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="functionals.html"><a href="functionals.html"><i class="fa fa-check"></i><b>8</b> Functionals</a><ul>
<li class="chapter" data-level="8.1" data-path="functionals.html"><a href="functionals.html#my-first-functional-lapply"><i class="fa fa-check"></i><b>8.1</b> My first functional: lapply()</a></li>
<li class="chapter" data-level="8.2" data-path="functionals.html"><a href="functionals.html#for-loops-functionals-friends-of-lapply"><i class="fa fa-check"></i><b>8.2</b> For loops functionals: friends of lapply():</a></li>
<li class="chapter" data-level="8.3" data-path="functionals.html"><a href="functionals.html#manipulating-matrices-and-data-frames"><i class="fa fa-check"></i><b>8.3</b> Manipulating matrices and data frames</a></li>
<li class="chapter" data-level="8.4" data-path="functionals.html"><a href="functionals.html#manipulating-lists"><i class="fa fa-check"></i><b>8.4</b> Manipulating lists</a></li>
<li class="chapter" data-level="8.5" data-path="functionals.html"><a href="functionals.html#mathematical-functionals"><i class="fa fa-check"></i><b>8.5</b> Mathematical functionals</a></li>
<li class="chapter" data-level="8.6" data-path="functionals.html"><a href="functionals.html#a-family-of-functions"><i class="fa fa-check"></i><b>8.6</b> A family of functions</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="function-operators.html"><a href="function-operators.html"><i class="fa fa-check"></i><b>9</b> Function operators</a><ul>
<li class="chapter" data-level="9.1" data-path="function-operators.html"><a href="function-operators.html#behavioural-fos"><i class="fa fa-check"></i><b>9.1</b> Behavioural FOs</a></li>
<li class="chapter" data-level="9.2" data-path="function-operators.html"><a href="function-operators.html#output-fos"><i class="fa fa-check"></i><b>9.2</b> Output FOs</a></li>
<li class="chapter" data-level="9.3" data-path="function-operators.html"><a href="function-operators.html#input-fos"><i class="fa fa-check"></i><b>9.3</b> Input FOs</a></li>
<li class="chapter" data-level="9.4" data-path="function-operators.html"><a href="function-operators.html#combining-fos"><i class="fa fa-check"></i><b>9.4</b> Combining FOs</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html"><i class="fa fa-check"></i><b>10</b> Non standard evaluation</a><ul>
<li class="chapter" data-level="10.1" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#capturing-expressions"><i class="fa fa-check"></i><b>10.1</b> Capturing expressions</a></li>
<li class="chapter" data-level="10.2" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#non-standard-evaluation-in-subset"><i class="fa fa-check"></i><b>10.2</b> Non standard evaluation in subset</a></li>
<li class="chapter" data-level="10.3" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#scoping-issues"><i class="fa fa-check"></i><b>10.3</b> Scoping issues</a></li>
<li class="chapter" data-level="10.4" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#calling-from-another-function"><i class="fa fa-check"></i><b>10.4</b> Calling from another function</a></li>
<li class="chapter" data-level="10.5" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#substitute"><i class="fa fa-check"></i><b>10.5</b> Substitute</a></li>
<li class="chapter" data-level="10.6" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#the-downsides-of-non-standard-evaluation"><i class="fa fa-check"></i><b>10.6</b> The downsides of non-standard evaluation</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="expressions.html"><a href="expressions.html"><i class="fa fa-check"></i><b>11</b> Expressions</a><ul>
<li class="chapter" data-level="11.1" data-path="expressions.html"><a href="expressions.html#structure-of-expressions"><i class="fa fa-check"></i><b>11.1</b> Structure of expressions</a></li>
<li class="chapter" data-level="11.2" data-path="expressions.html"><a href="expressions.html#names"><i class="fa fa-check"></i><b>11.2</b> Names</a></li>
<li class="chapter" data-level="11.3" data-path="expressions.html"><a href="expressions.html#calls"><i class="fa fa-check"></i><b>11.3</b> Calls</a></li>
<li class="chapter" data-level="11.4" data-path="expressions.html"><a href="expressions.html#capturing-the-current-call"><i class="fa fa-check"></i><b>11.4</b> Capturing the current call</a></li>
<li class="chapter" data-level="11.5" data-path="expressions.html"><a href="expressions.html#pairlists"><i class="fa fa-check"></i><b>11.5</b> Pairlists</a></li>
<li class="chapter" data-level="11.6" data-path="expressions.html"><a href="expressions.html#parsing-and-deparsing"><i class="fa fa-check"></i><b>11.6</b> Parsing and deparsing</a></li>
<li class="chapter" data-level="11.7" data-path="expressions.html"><a href="expressions.html#walking-the-ast-with-recursive-functions"><i class="fa fa-check"></i><b>11.7</b> Walking the AST with recursive functions</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="domain-specific-languages.html"><a href="domain-specific-languages.html"><i class="fa fa-check"></i><b>12</b> Domain specific languages</a><ul>
<li class="chapter" data-level="12.1" data-path="domain-specific-languages.html"><a href="domain-specific-languages.html#html"><i class="fa fa-check"></i><b>12.1</b> HTML</a></li>
<li class="chapter" data-level="12.2" data-path="domain-specific-languages.html"><a href="domain-specific-languages.html#latex"><i class="fa fa-check"></i><b>12.2</b> LaTeX</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="performance.html"><a href="performance.html"><i class="fa fa-check"></i><b>13</b> Performance</a><ul>
<li class="chapter" data-level="13.1" data-path="performance.html"><a href="performance.html#microbenchmarking"><i class="fa fa-check"></i><b>13.1</b> Microbenchmarking</a></li>
<li class="chapter" data-level="13.2" data-path="performance.html"><a href="performance.html#language-performance"><i class="fa fa-check"></i><b>13.2</b> Language performance</a></li>
<li class="chapter" data-level="13.3" data-path="performance.html"><a href="performance.html#implementations-performance"><i class="fa fa-check"></i><b>13.3</b> Implementations performance</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="profiling.html"><a href="profiling.html"><i class="fa fa-check"></i><b>14</b> Profiling</a><ul>
<li class="chapter" data-level="14.1" data-path="profiling.html"><a href="profiling.html#has-somebody-already-solved-the-problem"><i class="fa fa-check"></i><b>14.1</b> Has somebody already solved the problem?</a></li>
<li class="chapter" data-level="14.2" data-path="profiling.html"><a href="profiling.html#do-as-little-as-possible"><i class="fa fa-check"></i><b>14.2</b> Do as little as possible</a></li>
<li class="chapter" data-level="14.3" data-path="profiling.html"><a href="profiling.html#vectorise"><i class="fa fa-check"></i><b>14.3</b> Vectorise</a></li>
</ul></li>
<li class="chapter" data-level="15" data-path="memory.html"><a href="memory.html"><i class="fa fa-check"></i><b>15</b> Memory</a><ul>
<li class="chapter" data-level="15.1" data-path="memory.html"><a href="memory.html#object-size"><i class="fa fa-check"></i><b>15.1</b> Object size</a></li>
<li class="chapter" data-level="15.2" data-path="memory.html"><a href="memory.html#memory-profiling-with-lineprof"><i class="fa fa-check"></i><b>15.2</b> Memory profiling with lineprof</a></li>
<li class="chapter" data-level="15.3" data-path="memory.html"><a href="memory.html#modification-in-place"><i class="fa fa-check"></i><b>15.3</b> Modification in place</a></li>
</ul></li>
<li class="chapter" data-level="16" data-path="rcpp.html"><a href="rcpp.html"><i class="fa fa-check"></i><b>16</b> Rcpp</a><ul>
<li class="chapter" data-level="16.1" data-path="rcpp.html"><a href="rcpp.html#getting-started-with-c"><i class="fa fa-check"></i><b>16.1</b> Getting started with C++</a></li>
<li class="chapter" data-level="16.2" data-path="rcpp.html"><a href="rcpp.html#missing-values"><i class="fa fa-check"></i><b>16.2</b> Missing values</a></li>
<li class="chapter" data-level="16.3" data-path="rcpp.html"><a href="rcpp.html#the-stl"><i class="fa fa-check"></i><b>16.3</b> The STL</a></li>
</ul></li>
<li class="chapter" data-level="17" data-path="testchapter.html"><a href="testchapter.html"><i class="fa fa-check"></i><b>17</b> Testchapter</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Advanced R Solutions</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="environments" class="section level1">
<h1><span class="header-section-number">5</span> Environments</h1>
<div id="environment-basics" class="section level2">
<h2><span class="header-section-number">5.1</span> Environment basics</h2>
<ol style="list-style-type: decimal">
<li><strong><span style="color:red">Q</span></strong>: List three ways in which an environment differs from a list.<br />
<strong><span style="color:green">A</span></strong>: The most important differences are:
<ul>
<li>environments have reference semantics</li>
<li>environments have parents</li>
<li>environments are not ordered</li>
<li>elements of environments need to be (uniquely) named</li>
</ul></li>
<li><p><strong><span style="color:red">Q</span></strong>: If you don’t supply an explicit environment, where do <code>ls()</code> and <code>rm()</code> look? Where does <code>&lt;-</code> make bindings? The<br />
<strong><span style="color:green">A</span></strong>: <code>ls()</code> and <code>rm</code> look in their calling environments which they find by <code>as.environment(-1)</code>.<br />
From the book:</p>
<blockquote>
<p>Assignment is the act of binding (or rebinding) a name to a value in an environment.</p>
</blockquote>
<p>From <code>?`&lt;-`</code>:</p>
<blockquote>
<p>The operators <code>&lt;-</code> and <code>=</code> assign into the environment in which they are evaluated. The operator <code>&lt;-</code> can be used anywhere, whereas the operator <code>=</code> is only allowed at the top level (e.g., in the complete expression typed at the command prompt) or as one of the subexpressions in a braced list of expressions.</p>
</blockquote></li>
<li><p><strong><span style="color:red">Q</span></strong>: Using <code>parent.env()</code> and a loop (or a recursive function), verify that the ancestors of <code>globalenv()</code> include <code>baseenv()</code> and <code>emptyenv()</code>. Use the same basic idea to implement your own version of <code>search()</code>.<br />
<strong><span style="color:green">A</span></strong>: We can print the ancestors for example by using a recursive function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ancestors &lt;-<span class="st"> </span>function(<span class="dt">env =</span> <span class="kw">globalenv</span>()){
  if (<span class="kw">identical</span>(env, <span class="kw">emptyenv</span>())) {
    <span class="kw">print</span>(<span class="kw">environmentName</span>(env))} 
  else {
    <span class="kw">print</span>(<span class="kw">environmentName</span>(env))
    <span class="kw">ancestors</span>(<span class="kw">parent.env</span>(env))
  }
}

<span class="kw">ancestors</span>()
<span class="co">#&gt; [1] &quot;R_GlobalEnv&quot;</span>
<span class="co">#&gt; [1] &quot;package:stats&quot;</span>
<span class="co">#&gt; [1] &quot;package:graphics&quot;</span>
<span class="co">#&gt; [1] &quot;package:grDevices&quot;</span>
<span class="co">#&gt; [1] &quot;package:utils&quot;</span>
<span class="co">#&gt; [1] &quot;package:datasets&quot;</span>
<span class="co">#&gt; [1] &quot;Autoloads&quot;</span>
<span class="co">#&gt; [1] &quot;base&quot;</span>
<span class="co">#&gt; [1] &quot;R_EmptyEnv&quot;</span></code></pre></div>
<p>To implement a new version of <code>search()</code> we use a while statement:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">search2 &lt;-<span class="st"> </span>function(<span class="dt">env =</span> <span class="kw">globalenv</span>()){
  envs &lt;-<span class="st"> </span><span class="kw">character</span>()
  while (!<span class="kw">identical</span>(env, <span class="kw">emptyenv</span>())) {
    ename &lt;-<span class="st"> </span><span class="kw">environmentName</span>(env)
    if (ename ==<span class="st"> &quot;base&quot;</span>) ename &lt;-<span class="st"> &quot;package:base&quot;</span>
    if (ename ==<span class="st"> &quot;R_GlobalEnv&quot;</span>) ename &lt;-<span class="st"> &quot;.GlobalEnv&quot;</span>
    envs &lt;-<span class="st"> </span><span class="kw">c</span>(envs, ename)
    env &lt;-<span class="st"> </span><span class="kw">parent.env</span>(env)
    }
  <span class="kw">return</span>(envs)
}

<span class="kw">search2</span>()
<span class="co">#&gt; [1] &quot;.GlobalEnv&quot;        &quot;package:stats&quot;     &quot;package:graphics&quot; </span>
<span class="co">#&gt; [4] &quot;package:grDevices&quot; &quot;package:utils&quot;     &quot;package:datasets&quot; </span>
<span class="co">#&gt; [7] &quot;Autoloads&quot;         &quot;package:base&quot;</span>
<span class="co"># visual check that results are identical to the original search() function</span>
<span class="kw">search</span>()
<span class="co">#&gt; [1] &quot;.GlobalEnv&quot;        &quot;package:stats&quot;     &quot;package:graphics&quot; </span>
<span class="co">#&gt; [4] &quot;package:grDevices&quot; &quot;package:utils&quot;     &quot;package:datasets&quot; </span>
<span class="co">#&gt; [7] &quot;Autoloads&quot;         &quot;package:base&quot;</span></code></pre></div></li>
</ol>
</div>
<div id="recursing-over-environments" class="section level2">
<h2><span class="header-section-number">5.2</span> Recursing over environments</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: Modify <code>where()</code> to find all environments that contain a binding for <code>name</code>.<br />
<strong><span style="color:green">A</span></strong>: We look at the source code of the original <code>pryr::where()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pryr::where
function (name, <span class="dt">env =</span> <span class="kw">parent.frame</span>()) 
  {
  <span class="kw">stopifnot</span>(<span class="kw">is.character</span>(name), <span class="kw">length</span>(name) ==<span class="st"> </span><span class="dv">1</span>)
  env &lt;-<span class="st"> </span><span class="kw">to_env</span>(env)
  if (<span class="kw">identical</span>(env, <span class="kw">emptyenv</span>())) { <span class="co"># &quot;base case&quot;</span>
    <span class="kw">stop</span>(<span class="st">&quot;Can&#39;t find &quot;</span>, name, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
    }
  if (<span class="kw">exists</span>(name, env, <span class="dt">inherits =</span> <span class="ot">FALSE</span>)) { <span class="co"># &quot;success case&quot;</span>
    env
    }
  else { <span class="co"># &quot;recursive case&quot;</span>
    <span class="kw">where</span>(name, <span class="kw">parent.env</span>(env)) <span class="co"># we will copy this line in the success case</span>
  }
}</code></pre></div>
<p>Since <code>where()</code> stops searching when a match appears, we copy the recursive call in the <code>else</code> block to the block of the matching (“success”) case, so that our new function <code>where2</code> will look for a binding within the complete search path. We also need to pay attention to other details. We have to take care to save the bindings in an object, while not overriding it in our recursive calls. So we create a list object for that and define a new function within <code>where2()</code> that we call <code>where2.internal</code>. <code>where2.internal()</code> will do the recursive work and whenever it finds a binding it will write it via <code>&lt;&lt;-</code> to the especially created list in its enclosing environment:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">where2 &lt;-<span class="st"> </span>function(name, <span class="dt">env =</span> <span class="kw">parent.frame</span>()){
  <span class="co"># we need to collect all environments where name has a binding</span>
  env_list &lt;-<span class="st"> </span><span class="kw">list</span>()

  <span class="co"># since our function will be recursive and env_list would be overwritten</span>
  <span class="co"># when it is inside the recursive function, we put it on the outside of</span>
  <span class="co"># the recursive function and concatenate every binding environment</span>
  <span class="co"># that we find via the `&lt;&lt;-` operator on its end.</span>
  <span class="co"># In the following we start by defining the recursive function:</span>
  where2.internal &lt;-<span class="st"> </span>function(name, <span class="dt">env =</span> <span class="kw">parent.frame</span>()) {
    <span class="kw">stopifnot</span>(<span class="kw">is.character</span>(name), <span class="kw">length</span>(name) ==<span class="st"> </span><span class="dv">1</span>)
    env &lt;-<span class="st"> </span>pryr:::<span class="kw">to_env</span>(env) <span class="co"># note that we need to call to_env via pryr:::</span>

    <span class="co"># when we reach the empty environment, we return all binding environments</span>
    <span class="co"># (if we found some) if we found no bindings, we give the same error message</span>
    <span class="co"># as pryr::where does</span>
    if (<span class="kw">identical</span>(env, <span class="kw">emptyenv</span>())) {
      if (<span class="kw">length</span>(env_list) !=<span class="st"> </span><span class="dv">0</span>){
        <span class="kw">return</span>(env_list)
        }
      <span class="kw">stop</span>(<span class="st">&quot;Can&#39;t find &quot;</span>, name, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
      }
    if (<span class="kw">exists</span>(name, env, <span class="dt">inherits =</span> <span class="ot">FALSE</span>)) {
      <span class="co"># this is a case where we find a binding. the main difference to</span>
      <span class="co"># pryr::where is that we don&#39;t return immediately. Instead we save</span>
      <span class="co"># the binding environment to env_list and call where2.internal again</span>
      env_list &lt;&lt;-<span class="st"> </span><span class="kw">c</span>(env_list, env)
      <span class="kw">where2.internal</span>(name, <span class="kw">parent.env</span>(env))
      } else {
        <span class="kw">where2.internal</span>(name, <span class="kw">parent.env</span>(env))
      }
  }

  <span class="co"># as a last step we just call where2.internal() to start the recursion</span>
  <span class="kw">where2.internal</span>(name, <span class="dt">env =</span> <span class="kw">parent.frame</span>())
}</code></pre></div>
<p>Note that <code>where2.internal()</code> still provides the same structure as <code>pryr::where</code> does and you can also divide it in “base case”, “success case” and “recursive case”.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Write your own version of <code>get()</code> using a function written in the style of <code>where()</code>.<br />
<strong><span style="color:green">A</span></strong>: Note that <code>get()</code> provides a bit more arguments than our following version, but it should be easy to build up on that. However, we can change <code>pryr::where</code> to <code>get2()</code> with just changing one line of code (and the function name for the recursive call):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">get2 &lt;-<span class="st"> </span>function(name, <span class="dt">env =</span> <span class="kw">parent.frame</span>()) 
  {
  <span class="kw">stopifnot</span>(<span class="kw">is.character</span>(name), <span class="kw">length</span>(name) ==<span class="st"> </span><span class="dv">1</span>)
  env &lt;-<span class="st"> </span>pryr:::<span class="kw">to_env</span>(env)
  if (<span class="kw">identical</span>(env, <span class="kw">emptyenv</span>())) {
    <span class="kw">stop</span>(<span class="st">&quot;Can&#39;t find &quot;</span>, name, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
    }
  if (<span class="kw">exists</span>(name, env, <span class="dt">inherits =</span> <span class="ot">FALSE</span>)) {
    <span class="co"># we cancel env and substitute it with the following line, where we subset</span>
    <span class="co"># the environment (like a list) by the name of our object and return it</span>
    <span class="kw">return</span>(env[[name]])
    }
  else {
    <span class="kw">get2</span>(name, <span class="kw">parent.env</span>(env))
  }
}</code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: Write a function called <code>fget()</code> that finds only function objects. It should have two arguments, <code>name</code> and <code>env</code>, and should obey the regular scoping rules for functions: if there’s an object with a matching name that’s not a function, look in the parent. For an added challenge, also add an <code>inherits</code> argument which controls whether the function recurses up the parents or only looks in one environment.<br />
<strong><span style="color:green">A</span></strong>: We can build up our function on the implementation of <code>get2()</code> in the last exercise. We only need to add a check via <code>is.function()</code>, change the name (also in the recursive call) and the error message:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fget2 &lt;-<span class="st"> </span>function(name, <span class="dt">env =</span> <span class="kw">parent.frame</span>()){
  <span class="kw">stopifnot</span>(<span class="kw">is.character</span>(name), <span class="kw">length</span>(name) ==<span class="st"> </span><span class="dv">1</span>)
  env &lt;-<span class="st"> </span>pryr:::<span class="kw">to_env</span>(env)
  if (<span class="kw">identical</span>(env, <span class="kw">emptyenv</span>())) {
    <span class="kw">stop</span>(<span class="st">&quot;Could not find function called &quot;</span>, name, <span class="dt">call. =</span> <span class="ot">FALSE</span>) <span class="co"># </span>
    }
  <span class="co"># here we add the is.function() check</span>
  if (<span class="kw">exists</span>(name, env, <span class="dt">inherits =</span> <span class="ot">FALSE</span>) &amp;&amp;<span class="st"> </span><span class="kw">is.function</span>(env[[name]])) {
    <span class="kw">return</span>(env[[name]])
    }
  else {
    <span class="kw">fget2</span>(name, <span class="kw">parent.env</span>(env))
  }
}</code></pre></div>
<p>Note that this function is almost the same as the implementation of <code>pryr::fget()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pryr::fget
<span class="co">#&gt; function (name, env = parent.frame()) </span>
<span class="co">#&gt; {</span>
<span class="co">#&gt;     env &lt;- to_env(env)</span>
<span class="co">#&gt;     if (identical(env, emptyenv())) {</span>
<span class="co">#&gt;         stop(&quot;Could not find function called &quot;, name, call. = FALSE)</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;     if (exists(name, env, inherits = FALSE) &amp;&amp; is.function(env[[name]])) {</span>
<span class="co">#&gt;         env[[name]]</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;     else {</span>
<span class="co">#&gt;         fget(name, parent.env(env))</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:pryr&gt;</span></code></pre></div>
<p>We add an <code>inherits</code> parameter as described in the exercise:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fget3 &lt;-<span class="st"> </span>function(name, <span class="dt">env =</span> <span class="kw">parent.frame</span>(), <span class="dt">inherits =</span> <span class="ot">TRUE</span>){
  <span class="kw">stopifnot</span>(<span class="kw">is.character</span>(name), <span class="kw">length</span>(name) ==<span class="st"> </span><span class="dv">1</span>)
  env &lt;-<span class="st"> </span>pryr:::<span class="kw">to_env</span>(env)
  if (<span class="kw">identical</span>(env, <span class="kw">emptyenv</span>())) {
    <span class="kw">stop</span>(<span class="st">&quot;Could not find function called &quot;</span>, name, <span class="dt">call. =</span> <span class="ot">FALSE</span>) 
    }
  if (<span class="kw">exists</span>(name, env, <span class="dt">inherits =</span> <span class="ot">FALSE</span>) &amp;&amp;<span class="st"> </span><span class="kw">is.function</span>(env[[name]])) {
    <span class="kw">return</span>(env[[name]])
    }
  <span class="co"># after the environment, which is specified in the env parameter, is checked</span>
  <span class="co"># we stop our function in case the new inherits parameter is set to FALSE</span>
  if(inherits ==<span class="st"> </span><span class="ot">FALSE</span>){
    <span class="kw">stop</span>(<span class="st">&quot;Could not find function called &quot;</span>, name,<span class="st">&quot; within &quot;</span>,
         <span class="kw">environmentName</span>(env),
         <span class="dt">call. =</span> <span class="ot">FALSE</span>)
    }
  else {
    <span class="kw">fget3</span>(name, <span class="kw">parent.env</span>(env))
  }
}</code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: Write your own version of <code>exists(inherits = FALSE)</code> (Hint: use <code>ls()</code>.) Write a recursive version that behaves like <code>exists(inherits = TRUE)</code>.<br />
<strong><span style="color:green">A</span></strong>: We write two versions. <code>exists2()</code> will be the case <code>inherits = FALSE</code> and <code>exists3()</code> <code>inherits = TRUE</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">exists2 &lt;-<span class="st"> </span>function(name, <span class="dt">env =</span> <span class="kw">parent.frame</span>()){
  <span class="kw">stopifnot</span>(<span class="kw">is.character</span>(name), <span class="kw">length</span>(name) ==<span class="st"> </span><span class="dv">1</span>)
  env &lt;-<span class="st"> </span>pryr:::<span class="kw">to_env</span>(env)
  name %in%<span class="st"> </span><span class="kw">ls</span>(env, <span class="dt">sorted =</span> <span class="ot">FALSE</span>) <span class="co"># set sorted to FALSE for a small speedup</span>
}

exists3 &lt;-<span class="st"> </span>function(name, <span class="dt">env =</span> <span class="kw">parent.frame</span>()){
  <span class="kw">stopifnot</span>(<span class="kw">is.character</span>(name), <span class="kw">length</span>(name) ==<span class="st"> </span><span class="dv">1</span>)
  env &lt;-<span class="st"> </span>pryr:::<span class="kw">to_env</span>(env)
  if (<span class="kw">identical</span>(env, <span class="kw">emptyenv</span>())) {
    <span class="kw">return</span>(<span class="ot">FALSE</span>)
  }
  if (name %in%<span class="st"> </span><span class="kw">ls</span>(env, <span class="dt">sorted =</span> <span class="ot">FALSE</span>)){
    <span class="ot">TRUE</span>
    }
  else {
    <span class="kw">exists3</span>(name, <span class="kw">parent.env</span>(env))
  }
}</code></pre></div></li>
</ol>
</div>
<div id="function-environments" class="section level2">
<h2><span class="header-section-number">5.3</span> Function environments</h2>
<ol style="list-style-type: decimal">
<li><strong><span style="color:red">Q</span></strong>: List the four environments associated with a function. What does each one do? Why is the distinction between enclosing and binding environments particularly important?<br />
<strong><span style="color:green">A</span></strong>:
<ul>
<li>Enclosing: where the function is created</li>
<li>Binding: where the function was assigned</li>
<li>Execution: a temporary environment which is created when the function is executed</li>
<li>Calling: the environment from where the function was called</li>
</ul>
<p>The difference between binding and enclosing environment is important, because of R’s lexical scoping rules. If R can’t find an object in the current environment while executing a function, it will look for it in the enclosing environment.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Draw a diagram that shows the enclosing environments of this function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f1 &lt;-<span class="st"> </span>function(x1) {
  f2 &lt;-<span class="st"> </span>function(x2) {
    f3 &lt;-<span class="st"> </span>function(x3) {
      x1 +<span class="st"> </span>x2 +<span class="st"> </span>x3
    }
    <span class="kw">f3</span>(<span class="dv">3</span>)
  }
  <span class="kw">f2</span>(<span class="dv">2</span>)
}
<span class="kw">f1</span>(<span class="dv">1</span>)</code></pre></div>
<p><strong><span style="color:green">A</span></strong>:</p>
<p><img src="diagrams/enclosing.png" width="943" /></p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Expand your previous diagram to show function bindings.<br />
<strong><span style="color:green">A</span></strong>:</p>
<p><img src="diagrams/binding.png" width="943" /></p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Expand it again to show the execution and calling environments.<br />
<strong><span style="color:green">A</span></strong>:</p>
<p><img src="diagrams/calling_execution.png" width="943" /></p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Write an enhanced version of <code>str()</code> that provides more information about functions. Show where the function was found and what environment it was defined in.<br />
<strong><span style="color:green">A</span></strong>: Additionally we provide the function type in the sense of <code>pryr::ftype</code>. We use functions from the <code>pryr</code> package, since it provides helpers for all requested features:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fstr &lt;-<span class="st"> </span>function(object){
  if(!<span class="kw">is.function</span>(object)){<span class="kw">stop</span>(<span class="st">&quot;fstr works only for functions&quot;</span>)}

  object_str &lt;-<span class="st"> </span>lazyeval::<span class="kw">expr_text</span>(object)

  flist &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">ftype =</span> pryr::<span class="kw">ftype</span>(object),
             <span class="dt">where =</span> pryr::<span class="kw">where</span>(object_str),
             <span class="dt">enclosing_env =</span> pryr::<span class="kw">enclosing_env</span>(object),
             <span class="dt">args =</span> pryr::<span class="kw">fun_args</span>(object)
             )

  <span class="kw">return</span>(flist)
}</code></pre></div>
<p>Note that we wanted to have non standard evaluation like the original <code>str()</code> function. Since <code>pryr::where()</code> doesn’t support non standard evaluation, we needed to catch the name of the supplied <code>object</code>. Therefore we used <code>expr_text()</code> from the <a href="https://github.com/hadley/lazyeval">lazyeval</a> package. As a result, <code>fstr(object = packagename::functionname)</code> will result in an error in contrast to <code>str()</code>.</p></li>
</ol>
</div>
<div id="binding-names-to-values" class="section level2">
<h2><span class="header-section-number">5.4</span> Binding names to values</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: What does this function do? How does it differ from <code>&lt;&lt;-</code> and why might you prefer it?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rebind &lt;-<span class="st"> </span>function(name, value, <span class="dt">env =</span> <span class="kw">parent.frame</span>()) {
  if (<span class="kw">identical</span>(env, <span class="kw">emptyenv</span>())) {
    <span class="kw">stop</span>(<span class="st">&quot;Can&#39;t find &quot;</span>, name, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  } else if (<span class="kw">exists</span>(name, <span class="dt">envir =</span> env, <span class="dt">inherits =</span> <span class="ot">FALSE</span>)) {
    <span class="kw">assign</span>(name, value, <span class="dt">envir =</span> env)
  } else {
    <span class="kw">rebind</span>(name, value, <span class="kw">parent.env</span>(env))
  }
}
<span class="kw">rebind</span>(<span class="st">&quot;a&quot;</span>, <span class="dv">10</span>)
<span class="co">#&gt; Error: Can&#39;t find a</span>
a &lt;-<span class="st"> </span><span class="dv">5</span>
<span class="kw">rebind</span>(<span class="st">&quot;a&quot;</span>, <span class="dv">10</span>)
a
<span class="co">#&gt; [1] 10</span></code></pre></div>
<p><strong><span style="color:green">A</span></strong>: The function does “more or less” the same as <code>&lt;&lt;-</code>. Additionally to <code>&lt;&lt;-</code> it has an <code>env</code> argument, but this is not a big advantage, since also <code>assign()</code> provides this functionality. The main difference is that <code>rebind()</code> only does an assignment, when it finds a binding in one of the parent environments of <code>env</code>. Whereas:</p>
<blockquote>
<p>If <code>&lt;&lt;-</code> doesn’t find an existing variable, it will create one in the global environment. This is usually undesirable, because global variables introduce non-obvious dependencies between functions.</p>
</blockquote></li>
<li><p><strong><span style="color:red">Q</span></strong>: Create a version of <code>assign()</code> that will only bind new names, never re-bind old names. Some programming languages only do this, and are known as [single assignment languages][single assignment].<br />
<strong><span style="color:green">A</span></strong>: We take the formals from <code>assign()</code>’s source code and define our new function. If <code>x</code> already exists, we give a message and return <code>NULL</code> (since this is the same as <code>return()</code>). Otherwise we let the body of the <code>assign()</code> function do the work:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">assign_non_existant &lt;-<span class="st"> </span>function(x, value, <span class="dt">pos =</span> -<span class="dv">1</span>, <span class="dt">envir =</span> <span class="kw">as.environment</span>(pos),
                            <span class="dt">inherits =</span> <span class="ot">FALSE</span>, <span class="dt">immediate =</span> <span class="ot">TRUE</span>) {
  if(<span class="kw">exists</span>(x)){
    <span class="kw">message</span>(<span class="st">&quot;No new assignment: &#39;&quot;</span>, x, <span class="st">&quot;&#39; already exists&quot;</span>)
    <span class="kw">return</span>(<span class="ot">NULL</span>)}
  <span class="kw">.Internal</span>(<span class="kw">assign</span>(x, value, envir, inherits))
}</code></pre></div>
<p>Note that <code>.Internal(assign(x, value, envir, inherits))</code>, is not inside an <code>else</code> block or any other function. This is important. Otherwise we would change more of <code>assign()</code> than we want (in case of the assignment of a new function, the enclosing environment for that function would differ).</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Write an assignment function that can do active, delayed, and locked bindings. What might you call it? What arguments should it take? Can you guess which sort of assignment it should do based on the input?<br />
<strong><span style="color:green">A</span></strong>: The following might be no optimal solution, but we can at least handle two of three cases via if statements. The problem already occured in the last exercise, were we had to do an assignment in an if statement and did a workaround. This workaround only works for one assignment (for logical reasons). We still use the workaround for the “delay case”, but we found a solution for the other two cases. The main aspect in it is to unify the environment were <code>assign()</code>, <code>makeActiveBinding()</code> and <code>delayedAssign()</code> act. We also had to test that cases like this</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">makeActiveBinding</span>(<span class="dt">sym =</span> <span class="st">&quot;test1&quot;</span>,
                  <span class="dt">fun =</span> function() function(x, <span class="dt">y =</span> <span class="kw">sample</span>(<span class="dv">1</span>:<span class="dv">3</span>, <span class="dv">1</span>)){x^y},
                  <span class="dt">env =</span> <span class="kw">parent.frame</span>())</code></pre></div>
<p>work with our new function and our function creates bindings (and so enclosing environments) in the same places as <code>assign()</code> would do, also when used inside funceions.</p>
<p>The usage of <code>pryr:::to_env()</code> simplified this process a lot:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># found at https://github.com/hadley/pryr/blob/master/R/utils.r</span>
function(x, <span class="dt">quiet =</span> <span class="ot">FALSE</span>) {
  if (<span class="kw">is.environment</span>(x)) {
    x
    } else if (<span class="kw">is.list</span>(x)) {
      <span class="kw">list2env</span>(x)
      } else if (<span class="kw">is.function</span>(x)) {
        <span class="kw">environment</span>(x)
        } else if (<span class="kw">length</span>(x) ==<span class="st"> </span><span class="dv">1</span> &amp;&amp;<span class="st"> </span><span class="kw">is.character</span>(x)) {
          if (!quiet) <span class="kw">message</span>(<span class="st">&quot;Using environment &quot;</span>, x)
          <span class="kw">as.environment</span>(x)
          } else if (<span class="kw">length</span>(x) ==<span class="st"> </span><span class="dv">1</span> &amp;&amp;<span class="st"> </span><span class="kw">is.numeric</span>(x) &amp;&amp;<span class="st"> </span>x &gt;<span class="st"> </span><span class="dv">0</span>) {
            if (!quiet) <span class="kw">message</span>(<span class="st">&quot;Using environment &quot;</span>, <span class="kw">search</span>()[x])
            <span class="kw">as.environment</span>(x)
            } else {
              <span class="kw">stop</span>(<span class="st">&quot;Input can not be coerced to an environment&quot;</span>, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
            }
}</code></pre></div>
<p>We used all these thoughts to create the following function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">special_assign &lt;-<span class="st"> </span>function(x, value, atype, <span class="dt">envir =</span> pryr:::<span class="kw">to_env</span>(<span class="kw">parent.frame</span>())){
  if(atype ==<span class="st"> &quot;locked&quot;</span>){
    <span class="kw">assign</span>(x, value, <span class="dt">envir =</span> envir, inherits)
    <span class="kw">lockBinding</span>(<span class="dt">sym =</span> x, <span class="dt">env =</span> envir)
  }

  if(atype ==<span class="st"> &quot;active&quot;</span>){<span class="kw">makeActiveBinding</span>(<span class="dt">sym =</span> x, <span class="dt">fun =</span> value, <span class="dt">env =</span> envir)}
  if(atype !=<span class="st"> &quot;delayed&quot;</span>){<span class="kw">stop</span>(<span class="st">&quot;atype must be `locked`, `active` or `delayed`&quot;</span>)}
  <span class="kw">delayedAssign</span>(x, value, <span class="dt">eval.env =</span> <span class="kw">environment</span>(), <span class="dt">assign.env =</span> envir)
}</code></pre></div>
<p>At the moment we have no idea for a good default guess routine, so that a specific <code>atype</code> of assignment would be done based on the input.</p></li>
</ol>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="oo-field-guide.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="exceptions-and-debugging.html" class="navigation navigation-next " aria-label="Next page""><i class="fa fa-angle-right"></i></a>

<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/Tazinho/Advanced-R-Solutions/edit/master/05-Environments.Rmd",
"text": "Edit"
},
"download": null,
"toc": {
"collapse": "section",
"scroll_highlight": true
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
