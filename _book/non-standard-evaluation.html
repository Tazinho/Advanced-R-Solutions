<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Advanced R Solutions</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="Solutions to the exercises in Hadley Wickham’s book Advanced R.">
  <meta name="generator" content="bookdown 0.3 and GitBook 2.6.7">

  <meta property="og:title" content="Advanced R Solutions" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="images/advrs_cover.png" />
  <meta property="og:description" content="Solutions to the exercises in Hadley Wickham’s book Advanced R." />
  <meta name="github-repo" content="Tazinho/Advanced-R-Solutions" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Advanced R Solutions" />
  
  <meta name="twitter:description" content="Solutions to the exercises in Hadley Wickham’s book Advanced R." />
  <meta name="twitter:image" content="images/advrs_cover.png" />

<meta name="author" content="Malte Grosser &amp; Henning Bumann">


<meta name="date" content="2017-04-10">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="function-operators.html">
<link rel="next" href="expressions.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<!-- COLLAPSIBLE TEXT WITH OPEN ALL/CLOSE ALL LINK -->

<!-- This goes into the HEAD of the html file -->

<script language="JavaScript" type="text/javascript">
<!-- Copyright 2007, Sandeep Gangadharan -->
<!-- For more free scripts go to http://www.sivamdesign.com/scripts/ -->
<!--
if (document.getElementById) {
 document.write('<style type="text/css">.texter {display:none; border-left:white 20px solid; color:#404040; font-family:verdana,arial,helvetica,sans-serif; font-size:9pt} @media print {.texter {display:block;}}</style>') }

 var divNum = new Array("a1","a2","a3");  // at the left you should add a1, a2 etc. for each header you wish to include
                                          // so if you want 4 headers you should add a1, a2, a3, a4 in the format shown
                                          // enclosed in double quotes
function openClose(theID) {
 for(var i=0; i < divNum.length; i++) {
  if (divNum[i] == theID) {
   if (document.getElementById(divNum[i]).style.display == "block") { document.getElementById(divNum[i]).style.display = "none" }
   else { document.getElementById(divNum[i]).style.display = "block" }
  }
  else { document.getElementById(divNum[i]).style.display = "none"; }
 }
}

function openAll() {
 for(var i=0; i < divNum.length; i++) {
   document.getElementById(divNum[i]).style.display = "block";
 }
}

function closeAll() {
 for(var i=0; i < divNum.length; i++) {
   document.getElementById(divNum[i]).style.display = "none";
 }
}
// -->
</script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>


  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="1" data-path="data-structures.html"><a href="data-structures.html"><i class="fa fa-check"></i><b>1</b> Data structures</a><ul>
<li class="chapter" data-level="1.1" data-path="data-structures.html"><a href="data-structures.html#vectors"><i class="fa fa-check"></i><b>1.1</b> Vectors</a></li>
<li class="chapter" data-level="1.2" data-path="data-structures.html"><a href="data-structures.html#attributes"><i class="fa fa-check"></i><b>1.2</b> Attributes</a></li>
<li class="chapter" data-level="1.3" data-path="data-structures.html"><a href="data-structures.html#matrices-and-arrays"><i class="fa fa-check"></i><b>1.3</b> Matrices and arrays</a></li>
<li class="chapter" data-level="1.4" data-path="data-structures.html"><a href="data-structures.html#data-frames"><i class="fa fa-check"></i><b>1.4</b> Data frames</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="subsetting.html"><a href="subsetting.html"><i class="fa fa-check"></i><b>2</b> Subsetting</a><ul>
<li class="chapter" data-level="2.1" data-path="subsetting.html"><a href="subsetting.html#data-types"><i class="fa fa-check"></i><b>2.1</b> Data types</a></li>
<li class="chapter" data-level="2.2" data-path="subsetting.html"><a href="subsetting.html#subsetting-operators"><i class="fa fa-check"></i><b>2.2</b> Subsetting operators</a></li>
<li class="chapter" data-level="2.3" data-path="subsetting.html"><a href="subsetting.html#applications"><i class="fa fa-check"></i><b>2.3</b> Applications</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="functions.html"><a href="functions.html"><i class="fa fa-check"></i><b>3</b> Functions</a><ul>
<li class="chapter" data-level="3.1" data-path="functions.html"><a href="functions.html#function-components"><i class="fa fa-check"></i><b>3.1</b> Function components</a></li>
<li class="chapter" data-level="3.2" data-path="functions.html"><a href="functions.html#lexical-scoping"><i class="fa fa-check"></i><b>3.2</b> Lexical Scoping</a></li>
<li class="chapter" data-level="3.3" data-path="functions.html"><a href="functions.html#function-arguments"><i class="fa fa-check"></i><b>3.3</b> Function arguments</a></li>
<li class="chapter" data-level="3.4" data-path="functions.html"><a href="functions.html#special-calls"><i class="fa fa-check"></i><b>3.4</b> Special calls</a></li>
<li class="chapter" data-level="3.5" data-path="functions.html"><a href="functions.html#return-values"><i class="fa fa-check"></i><b>3.5</b> Return Values</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="oo-field-guide.html"><a href="oo-field-guide.html"><i class="fa fa-check"></i><b>4</b> OO field guide</a><ul>
<li class="chapter" data-level="4.1" data-path="oo-field-guide.html"><a href="oo-field-guide.html#s3"><i class="fa fa-check"></i><b>4.1</b> S3</a></li>
<li class="chapter" data-level="4.2" data-path="oo-field-guide.html"><a href="oo-field-guide.html#s4"><i class="fa fa-check"></i><b>4.2</b> S4</a></li>
<li class="chapter" data-level="4.3" data-path="oo-field-guide.html"><a href="oo-field-guide.html#rc"><i class="fa fa-check"></i><b>4.3</b> RC</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="environments.html"><a href="environments.html"><i class="fa fa-check"></i><b>5</b> Environments</a><ul>
<li class="chapter" data-level="5.1" data-path="environments.html"><a href="environments.html#environment-basics"><i class="fa fa-check"></i><b>5.1</b> Environment basics</a></li>
<li class="chapter" data-level="5.2" data-path="environments.html"><a href="environments.html#recursing-over-environments"><i class="fa fa-check"></i><b>5.2</b> Recursing over environments</a></li>
<li class="chapter" data-level="5.3" data-path="environments.html"><a href="environments.html#function-environments"><i class="fa fa-check"></i><b>5.3</b> Function environments</a></li>
<li class="chapter" data-level="5.4" data-path="environments.html"><a href="environments.html#binding-names-to-values"><i class="fa fa-check"></i><b>5.4</b> Binding names to values</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="exceptions-and-debugging.html"><a href="exceptions-and-debugging.html"><i class="fa fa-check"></i><b>6</b> Exceptions and debugging</a><ul>
<li class="chapter" data-level="6.1" data-path="exceptions-and-debugging.html"><a href="exceptions-and-debugging.html#condition-handling"><i class="fa fa-check"></i><b>6.1</b> Condition handling</a></li>
<li class="chapter" data-level="6.2" data-path="exceptions-and-debugging.html"><a href="exceptions-and-debugging.html#defensive-programming"><i class="fa fa-check"></i><b>6.2</b> Defensive programming</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="functional-programming.html"><a href="functional-programming.html"><i class="fa fa-check"></i><b>7</b> Functional programming</a><ul>
<li class="chapter" data-level="7.1" data-path="functional-programming.html"><a href="functional-programming.html#annonymous-functions"><i class="fa fa-check"></i><b>7.1</b> Annonymous functions</a></li>
<li class="chapter" data-level="7.2" data-path="functional-programming.html"><a href="functional-programming.html#closures"><i class="fa fa-check"></i><b>7.2</b> Closures</a></li>
<li class="chapter" data-level="7.3" data-path="functional-programming.html"><a href="functional-programming.html#lists-of-functions"><i class="fa fa-check"></i><b>7.3</b> Lists of functions</a></li>
<li class="chapter" data-level="7.4" data-path="functional-programming.html"><a href="functional-programming.html#case-study-numerical-integration"><i class="fa fa-check"></i><b>7.4</b> Case study: numerical integration</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="functionals.html"><a href="functionals.html"><i class="fa fa-check"></i><b>8</b> Functionals</a><ul>
<li class="chapter" data-level="8.1" data-path="functionals.html"><a href="functionals.html#my-first-functional-lapply"><i class="fa fa-check"></i><b>8.1</b> My first functional: lapply()</a></li>
<li class="chapter" data-level="8.2" data-path="functionals.html"><a href="functionals.html#for-loops-functionals-friends-of-lapply"><i class="fa fa-check"></i><b>8.2</b> For loops functionals: friends of lapply():</a></li>
<li class="chapter" data-level="8.3" data-path="functionals.html"><a href="functionals.html#manipulating-matrices-and-data-frames"><i class="fa fa-check"></i><b>8.3</b> Manipulating matrices and data frames</a></li>
<li class="chapter" data-level="8.4" data-path="functionals.html"><a href="functionals.html#manipulating-lists"><i class="fa fa-check"></i><b>8.4</b> Manipulating lists</a></li>
<li class="chapter" data-level="8.5" data-path="functionals.html"><a href="functionals.html#mathematical-functionals"><i class="fa fa-check"></i><b>8.5</b> Mathematical functionals</a></li>
<li class="chapter" data-level="8.6" data-path="functionals.html"><a href="functionals.html#a-family-of-functions"><i class="fa fa-check"></i><b>8.6</b> A family of functions</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="function-operators.html"><a href="function-operators.html"><i class="fa fa-check"></i><b>9</b> Function operators</a><ul>
<li class="chapter" data-level="9.1" data-path="function-operators.html"><a href="function-operators.html#behavioural-fos"><i class="fa fa-check"></i><b>9.1</b> Behavioural FOs</a></li>
<li class="chapter" data-level="9.2" data-path="function-operators.html"><a href="function-operators.html#output-fos"><i class="fa fa-check"></i><b>9.2</b> Output FOs</a></li>
<li class="chapter" data-level="9.3" data-path="function-operators.html"><a href="function-operators.html#input-fos"><i class="fa fa-check"></i><b>9.3</b> Input FOs</a></li>
<li class="chapter" data-level="9.4" data-path="function-operators.html"><a href="function-operators.html#combining-fos"><i class="fa fa-check"></i><b>9.4</b> Combining FOs</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html"><i class="fa fa-check"></i><b>10</b> Non standard evaluation</a><ul>
<li class="chapter" data-level="10.1" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#capturing-expressions"><i class="fa fa-check"></i><b>10.1</b> Capturing expressions</a></li>
<li class="chapter" data-level="10.2" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#non-standard-evaluation-in-subset"><i class="fa fa-check"></i><b>10.2</b> Non standard evaluation in subset</a></li>
<li class="chapter" data-level="10.3" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#scoping-issues"><i class="fa fa-check"></i><b>10.3</b> Scoping issues</a></li>
<li class="chapter" data-level="10.4" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#calling-from-another-function"><i class="fa fa-check"></i><b>10.4</b> Calling from another function</a></li>
<li class="chapter" data-level="10.5" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#substitute"><i class="fa fa-check"></i><b>10.5</b> Substitute</a></li>
<li class="chapter" data-level="10.6" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#the-downsides-of-non-standard-evaluation"><i class="fa fa-check"></i><b>10.6</b> The downsides of non-standard evaluation</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="expressions.html"><a href="expressions.html"><i class="fa fa-check"></i><b>11</b> Expressions</a><ul>
<li class="chapter" data-level="11.1" data-path="expressions.html"><a href="expressions.html#structure-of-expressions"><i class="fa fa-check"></i><b>11.1</b> Structure of expressions</a></li>
<li class="chapter" data-level="11.2" data-path="expressions.html"><a href="expressions.html#names"><i class="fa fa-check"></i><b>11.2</b> Names</a></li>
<li class="chapter" data-level="11.3" data-path="expressions.html"><a href="expressions.html#calls"><i class="fa fa-check"></i><b>11.3</b> Calls</a></li>
<li class="chapter" data-level="11.4" data-path="expressions.html"><a href="expressions.html#capturing-the-current-call"><i class="fa fa-check"></i><b>11.4</b> Capturing the current call</a></li>
<li class="chapter" data-level="11.5" data-path="expressions.html"><a href="expressions.html#pairlists"><i class="fa fa-check"></i><b>11.5</b> Pairlists</a></li>
<li class="chapter" data-level="11.6" data-path="expressions.html"><a href="expressions.html#parsing-and-deparsing"><i class="fa fa-check"></i><b>11.6</b> Parsing and deparsing</a></li>
<li class="chapter" data-level="11.7" data-path="expressions.html"><a href="expressions.html#walking-the-ast-with-recursive-functions"><i class="fa fa-check"></i><b>11.7</b> Walking the AST with recursive functions</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="domain-specific-languages.html"><a href="domain-specific-languages.html"><i class="fa fa-check"></i><b>12</b> Domain specific languages</a><ul>
<li class="chapter" data-level="12.1" data-path="domain-specific-languages.html"><a href="domain-specific-languages.html#html"><i class="fa fa-check"></i><b>12.1</b> HTML</a></li>
<li class="chapter" data-level="12.2" data-path="domain-specific-languages.html"><a href="domain-specific-languages.html#latex"><i class="fa fa-check"></i><b>12.2</b> LaTeX</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="performance.html"><a href="performance.html"><i class="fa fa-check"></i><b>13</b> Performance</a><ul>
<li class="chapter" data-level="13.1" data-path="performance.html"><a href="performance.html#microbenchmarking"><i class="fa fa-check"></i><b>13.1</b> Microbenchmarking</a></li>
<li class="chapter" data-level="13.2" data-path="performance.html"><a href="performance.html#language-performance"><i class="fa fa-check"></i><b>13.2</b> Language performance</a></li>
<li class="chapter" data-level="13.3" data-path="performance.html"><a href="performance.html#implementations-performance"><i class="fa fa-check"></i><b>13.3</b> Implementations performance</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="profiling.html"><a href="profiling.html"><i class="fa fa-check"></i><b>14</b> Profiling</a><ul>
<li class="chapter" data-level="14.1" data-path="profiling.html"><a href="profiling.html#has-somebody-already-solved-the-problem"><i class="fa fa-check"></i><b>14.1</b> Has somebody already solved the problem?</a></li>
<li class="chapter" data-level="14.2" data-path="profiling.html"><a href="profiling.html#do-as-little-as-possible"><i class="fa fa-check"></i><b>14.2</b> Do as little as possible</a></li>
<li class="chapter" data-level="14.3" data-path="profiling.html"><a href="profiling.html#vectorise"><i class="fa fa-check"></i><b>14.3</b> Vectorise</a></li>
</ul></li>
<li class="chapter" data-level="15" data-path="memory.html"><a href="memory.html"><i class="fa fa-check"></i><b>15</b> Memory</a><ul>
<li class="chapter" data-level="15.1" data-path="memory.html"><a href="memory.html#object-size"><i class="fa fa-check"></i><b>15.1</b> Object size</a></li>
<li class="chapter" data-level="15.2" data-path="memory.html"><a href="memory.html#memory-profiling-with-lineprof"><i class="fa fa-check"></i><b>15.2</b> Memory profiling with lineprof</a></li>
<li class="chapter" data-level="15.3" data-path="memory.html"><a href="memory.html#modification-in-place"><i class="fa fa-check"></i><b>15.3</b> Modification in place</a></li>
</ul></li>
<li class="chapter" data-level="16" data-path="rcpp.html"><a href="rcpp.html"><i class="fa fa-check"></i><b>16</b> Rcpp</a><ul>
<li class="chapter" data-level="16.1" data-path="rcpp.html"><a href="rcpp.html#getting-started-with-c"><i class="fa fa-check"></i><b>16.1</b> Getting started with C++</a></li>
<li class="chapter" data-level="16.2" data-path="rcpp.html"><a href="rcpp.html#missing-values"><i class="fa fa-check"></i><b>16.2</b> Missing values</a></li>
<li class="chapter" data-level="16.3" data-path="rcpp.html"><a href="rcpp.html#the-stl"><i class="fa fa-check"></i><b>16.3</b> The STL</a></li>
</ul></li>
<li class="chapter" data-level="17" data-path="testchapter.html"><a href="testchapter.html"><i class="fa fa-check"></i><b>17</b> Testchapter</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Advanced R Solutions</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="non-standard-evaluation" class="section level1">
<h1><span class="header-section-number">10</span> Non standard evaluation</h1>
<div id="capturing-expressions" class="section level2">
<h2><span class="header-section-number">10.1</span> Capturing expressions</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: One important feature of <code>deparse()</code> to be aware of when programming is that it can return multiple strings if the input is too long. For example, the following call produces a vector of length two:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> </span>function(x) <span class="kw">deparse</span>(<span class="kw">substitute</span>(x))
<span class="kw">g</span>(a +<span class="st"> </span>b +<span class="st"> </span>c +<span class="st"> </span>d +<span class="st"> </span>e +<span class="st"> </span>f +<span class="st"> </span>g +<span class="st"> </span>h +<span class="st"> </span>i +<span class="st"> </span>j +<span class="st"> </span>k +<span class="st"> </span>l +<span class="st"> </span>m +
<span class="st">  </span>n +<span class="st"> </span>o +<span class="st"> </span>p +<span class="st"> </span>q +<span class="st"> </span>r +<span class="st"> </span>s +<span class="st"> </span>t +<span class="st"> </span>u +<span class="st"> </span>v +<span class="st"> </span>w +<span class="st"> </span>x +<span class="st"> </span>y +<span class="st"> </span>z)</code></pre></div>
<p>Why does this happen? Carefully read the documentation for <code>?deparse</code>. Can you write a wrapper around <code>deparse()</code> so that it always returns a single string?</p>
<p><strong><span style="color:green">A</span></strong>: <code>deparse()</code> has a <code>width.cutoff</code> argument, which is according to <code>?deparse</code> an:</p>
<blockquote>
<p>integer in [20, 500] determining the cutoff (in bytes) at which line-breaking is tried.</p>
</blockquote>
<p>Further:</p>
<blockquote>
<p>width.cutoff is a lower bound for the line lengths: deparsing a line proceeds until at least width.cutoff bytes have been output and e.g. arg = value expressions will not be split across lines.</p>
</blockquote>
<p>You can wrap it with <code>paste0()</code> for example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deparse_without_cutoff &lt;-<span class="st"> </span>function(x){
  <span class="kw">paste0</span>(<span class="kw">deparse</span>(x), <span class="dt">collapse =</span> <span class="st">&quot;&quot;</span>)
}</code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: Why does <code>as.Date.default()</code> use <code>substitute()</code> and <code>deparse()</code>? Why does <code>pairwise.t.test()</code> use them? Read the source code.</p>
<p><strong><span style="color:green">A</span></strong>: <code>as.Date.default()</code> uses them to convert unexpected input expressions (neither dates, nor <code>NAs</code>) into a character string and return it within an error message.</p>
<p><code>pairwise.t.test()</code> uses them to convert the names of its datainputs (response vector <code>x</code> and grouping factor <code>g</code>) into character strings to format these further into a part of the desired output.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: <code>pairwise.t.test()</code> assumes that <code>deparse()</code> always returns a length one character vector. Can you construct an input that violates this expectation? What happens?</p>
<p><strong><span style="color:green">A</span></strong>: We can pass an expression to one of <code>pairwise.t.test()</code>’s data input arguments, which exceeds the default cutoff width in <code>deparse()</code>. The expression will be split into a character vector of length greater 1. Since the deparsed data inputs are directly pasted (read the source code!) with “and” as separator, and the result is just used to be displayed in the output. Just the data.name output will change (it will include more than one “and”).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d=<span class="dv">1</span>
<span class="kw">pairwise.t.test</span>(<span class="dv">2</span>, d+d+d+d+d+d+d+d+d+d+d+d+d+d+d+d+d)
<span class="co">#&gt; </span>
<span class="co">#&gt;  Pairwise comparisons using t tests with pooled SD </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; data:  2 and d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d +  2 and     d </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; &lt;0 x 0 matrix&gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; P value adjustment method: holm</span></code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: <code>f()</code>, defined above, just calls <code>substitute()</code>. Why can’t we use it to define <code>g()</code>? In other words, what will the following code return? First make a prediction. Then run the code and think about the results.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span>function(x) <span class="kw">substitute</span>(x) 
g &lt;-<span class="st"> </span>function(x) <span class="kw">deparse</span>(<span class="kw">f</span>(x)) 
<span class="kw">g</span>(<span class="dv">1</span>:<span class="dv">10</span>)                             <span class="co"># -&gt; x</span>
<span class="kw">g</span>(x)                                <span class="co"># -&gt; x</span>
<span class="kw">g</span>(x +<span class="st"> </span>y ^<span class="st"> </span><span class="dv">2</span> /<span class="st"> </span>z +<span class="st"> </span><span class="kw">exp</span>(a *<span class="st"> </span><span class="kw">sin</span>(b)))  <span class="co"># -&gt; x</span></code></pre></div>
<p><strong><span style="color:green">A</span></strong>: All return x, because <code>substitute()</code>’s second argument <code>env</code> is the current evaluation environment <code>environment()</code>. If you call <code>substitute</code> from another function, you may want to set the <code>env</code> argument to <code>parent.frame()</code>, which refers to the calling environment:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span>function(x) <span class="kw">substitute</span>(x, <span class="dt">env =</span> <span class="kw">parent.frame</span>()) 
g &lt;-<span class="st"> </span>function(x) <span class="kw">deparse</span>(<span class="kw">f</span>(x)) 
<span class="kw">g</span>(<span class="dv">1</span>:<span class="dv">10</span>)                             <span class="co"># -&gt; 1:10</span>
<span class="kw">g</span>(x)                                <span class="co"># -&gt; x</span>
<span class="kw">g</span>(x +<span class="st"> </span>y ^<span class="st"> </span><span class="dv">2</span> /<span class="st"> </span>z +<span class="st"> </span><span class="kw">exp</span>(a *<span class="st"> </span><span class="kw">sin</span>(b)))  <span class="co"># -&gt; x + y ^ 2 / z + exp(a * sin(b))</span></code></pre></div></li>
</ol>
</div>
<div id="non-standard-evaluation-in-subset" class="section level2">
<h2><span class="header-section-number">10.2</span> Non standard evaluation in subset</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: Predict the results of the following lines of code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">eval</span>(<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="dv">2</span> +<span class="st"> </span><span class="dv">2</span>))))))        <span class="co"># -&gt; 4</span>
<span class="kw">eval</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="dv">2</span> +<span class="st"> </span><span class="dv">2</span>)))))))  <span class="co"># -&gt; 4</span>
<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="dv">2</span> +<span class="st"> </span><span class="dv">2</span>))))))) 
    <span class="co"># eval(quote(eval(quote(eval(quote(2 + 2))))))</span></code></pre></div>
<p><strong><span style="color:green">A</span></strong>: An outside <code>quote()</code> always wins…</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: <code>subset2()</code> has a bug if you use it with a single column data frame. What should the following code return? How can you modify <code>subset2()</code> so it returns the correct type of object?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">subset2 &lt;-<span class="st"> </span>function(x, condition) {
  condition_call &lt;-<span class="st"> </span><span class="kw">substitute</span>(condition)
  r &lt;-<span class="st"> </span><span class="kw">eval</span>(condition_call, x)
  x[r, ]
}
sample_df2 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">10</span>)
<span class="kw">subset2</span>(sample_df2, x &gt;<span class="st"> </span><span class="dv">8</span>)
<span class="co">#&gt; [1]  9 10</span></code></pre></div>
<p><strong><span style="color:green">A</span></strong>: The output is an atomic vector. To return always a data.frame change the last row in <code>subset2</code> to <code>x[r, , drop = FALSE]</code>.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: The real subset function (<code>subset.data.frame()</code>) removes missing values in the condition. Modify <code>subset2()</code> to do the same: drop the offending rows.</p>
<p><strong><span style="color:green">A</span></strong>: This time change the last row to <code>x[!is.na(r) &amp; r, , drop = FALSE]</code>.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: What happens if you use <code>quote()</code> instead of <code>substitute()</code> inside of <code>subset2()</code>?</p>
<p><strong><span style="color:orange">A</span></strong>: We will get <code>&quot;Error in eval(expr, envir, enclos) : object 'x' not found&quot;</code> in the above example. We are not sure if the problem relates to finding the right expression or the correct environment for evaluation.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: The second argument in <code>subset()</code> allows you to select variables. It treats variable names as if they were positions. This allows you to do things like <code>subset(mtcars, , -cyl)</code> to drop the cylinder variable, or <code>subset(mtcars, , disp:drat)</code> to select all the variables between <code>disp</code> and <code>drat</code>. How does this work? I’ve made this easier to understand by extracting it out into its own function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">select &lt;-<span class="st"> </span>function(df, vars) {
  vars &lt;-<span class="st"> </span><span class="kw">substitute</span>(vars)
  var_pos &lt;-<span class="st"> </span><span class="kw">setNames</span>(<span class="kw">as.list</span>(<span class="kw">seq_along</span>(df)), <span class="kw">names</span>(df))
  pos &lt;-<span class="st"> </span><span class="kw">eval</span>(vars, var_pos)
  df[, pos, drop =<span class="st"> </span><span class="ot">FALSE</span>]
}
<span class="kw">select</span>(mtcars, -cyl)</code></pre></div>
<p><strong><span style="color:green">A</span></strong>: We can comment what happens</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">select &lt;-<span class="st"> </span>function(df, vars) {
  vars &lt;-<span class="st"> </span><span class="kw">substitute</span>(vars)
  var_pos &lt;-<span class="st"> </span><span class="kw">setNames</span>(<span class="kw">as.list</span>(<span class="kw">seq_along</span>(df)), <span class="kw">names</span>(df)) <span class="co"># We create a list with </span>
  <span class="co"># columnnumbers and -names of the original data.frame.</span>
  pos &lt;-<span class="st"> </span><span class="kw">eval</span>(vars, var_pos) <span class="co"># We evaluate the supplied variable names within</span>
  <span class="co"># the list of all names of the data.frame and return the values of the mathing</span>
  <span class="co"># variable names and list elements (the positions of supplied variables </span>
  <span class="co"># within the supplied data.frame).</span>
  df[, pos, drop =<span class="st"> </span><span class="ot">FALSE</span>] <span class="co"># now we just subset the data.frame by its column index.</span>
}
<span class="kw">select</span>(mtcars, -cyl)</code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: What does <code>evalq()</code> do? Use it to reduce the amount of typing for the examples above that use both <code>eval()</code> and <code>quote()</code>.</p>
<p><strong><span style="color:green">A</span></strong>: From the help of <code>eval()</code>:</p>
<blockquote>
<p>The evalq form is equivalent to eval(quote(expr), …). eval evaluates its first argument in the current scope before passing it to the evaluator: evalq avoids this.</p>
</blockquote>
<p>In other “words”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">identical</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(x)), <span class="kw">evalq</span>(x)) <span class="co"># -&gt; TRUE</span></code></pre></div>
<p>The examples above can be written as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">eval</span>(<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="dv">2</span> +<span class="st"> </span><span class="dv">2</span>)))))) <span class="co">#-&gt;</span>
<span class="kw">evalq</span>(<span class="kw">evalq</span>(<span class="kw">evalq</span>(<span class="dv">2</span> +<span class="st"> </span><span class="dv">2</span>)))

<span class="kw">eval</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="dv">2</span> +<span class="st"> </span><span class="dv">2</span>))))))) <span class="co">#-&gt;</span>
<span class="kw">eval</span>(<span class="kw">evalq</span>(<span class="kw">evalq</span>(<span class="kw">evalq</span>(<span class="dv">2</span> +<span class="st"> </span><span class="dv">2</span>))))

<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(<span class="dv">2</span> +<span class="st"> </span><span class="dv">2</span>))))))) <span class="co">#-&gt;</span>
<span class="kw">quote</span>(<span class="kw">evalq</span>(<span class="kw">evalq</span>(<span class="kw">evalq</span>(<span class="dv">2</span> +<span class="st"> </span><span class="dv">2</span>)))) </code></pre></div></li>
</ol>
</div>
<div id="scoping-issues" class="section level2">
<h2><span class="header-section-number">10.3</span> Scoping issues</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: <code>plyr::arrange()</code> works similarly to <code>subset()</code>, but instead of selecting rows, it reorders them. How does it work? What does <code>substitute(order(...))</code> do? Create a function that does only that and experiment with it.</p>
<p><strong><span style="color:green">A</span></strong>: <code>substitute(order(...))</code> orders the indices of the supplied columns in <code>...</code> in the context of the submitted data.frame argument, beginning with the first submitted column.</p>
<p>We can just copy the part of the source code and see if it does what we expect:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">arrange_indices &lt;-<span class="st"> </span>function (df, ...){
  <span class="kw">stopifnot</span>(<span class="kw">is.data.frame</span>(df))
  ord &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">substitute</span>(<span class="kw">order</span>(...)), df, <span class="kw">parent.frame</span>())
  ord
  }

<span class="kw">identical</span>(<span class="kw">arrange_indices</span>(iris, Species, Sepal.Length),
          <span class="kw">order</span>(iris$Species, iris$Sepal.Length))</code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: What does <code>transform()</code> do? Read the documentation. How does it work? Read the source code for <code>transform.data.frame()</code>. What does <code>substitute(list(...))</code> do?</p>
<p><strong><span style="color:green">A</span></strong>: As stated in the next question <code>transform()</code> is similar to <code>plyr::mutate()</code> but <code>plyr::mutate()</code> applies the transformations sequentially so that transformation can refer to columns that were just created. The rest of the question can be answered, by just commenting the source code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Setting &quot;...&quot; as function argument allows the user to specify any kind of extra </span>
<span class="co"># argument to the function. In this case we can expect arguments of the form </span>
<span class="co"># new_col1 = foo(col_in_data_argument), new_col2 = foo(col_in_data_argument),... </span>
&gt;<span class="st"> </span>transform.data.frame
function (<span class="st">`</span><span class="dt">_data</span><span class="st">`</span>, ...) 
{
  <span class="co"># subsitute(list(...)) takes the dots into a list and just returns the expression</span>
  <span class="co"># `list(...)`. Nothing is evaluated until now (which is important). </span>
  <span class="co"># Evaluation of the expression happens with the `eval()` function.</span>
  <span class="co"># This means: all the names of the arguments in `...` like new_col1, new_col2,...</span>
  <span class="co"># become names of the list `e`.</span>
  <span class="co"># All functions/variables like foo(column_in_data_argument) are evaluated within</span>
  <span class="co"># the context (environment) of the `_data` argument supplied to the `transform()` </span>
  <span class="co"># function (this is specified by the second argument of the eval() function).</span>
  e &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">substitute</span>(<span class="kw">list</span>(...)), <span class="st">`</span><span class="dt">_data</span><span class="st">`</span>, <span class="kw">parent.frame</span>())

  <span class="co"># Everything that happens from now on is just about formatting and</span>
  <span class="co"># returning the correct columns:</span>
  <span class="co"># We save the names of the list (the names of the added columns)</span>
  tags &lt;-<span class="st"> </span><span class="kw">names</span>(e)
  <span class="co"># We create a numeric vector and check if the tags (names of the added columns) </span>
  <span class="co"># appear in the names of the supplied `_data` argument. If yes, we save the </span>
  <span class="co"># column number, if not we save an NA.</span>
  inx &lt;-<span class="st"> </span><span class="kw">match</span>(tags, <span class="kw">names</span>(<span class="st">`</span><span class="dt">_data</span><span class="st">`</span>))
  <span class="co"># We create a logical vector, which is telling us if a column_name is already in the</span>
  <span class="co"># data.frame (TRUE) or really new (FALSE)</span>
  matched &lt;-<span class="st"> </span>!<span class="kw">is.na</span>(inx)
  <span class="co"># If any new column is corresponding to an old column name,</span>
  <span class="co"># the correspong old columns will be overwritten</span>
  if (<span class="kw">any</span>(matched)) {
    <span class="st">`</span><span class="dt">_data</span><span class="st">`</span>[inx[matched]] &lt;-<span class="st"> </span>e[matched]
    <span class="st">`</span><span class="dt">_data</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="st">`</span><span class="dt">_data</span><span class="st">`</span>)
  }
  <span class="co"># If there is at least one new column name, all of these new columns will be bound</span>
  <span class="co"># on the old data.frame (which might have changed a bit during the first if). Then the</span>
  <span class="co"># transformed `data_` is returned</span>
  if (!<span class="kw">all</span>(matched)) 
    <span class="kw">do.call</span>(<span class="st">&quot;data.frame&quot;</span>, <span class="kw">c</span>(<span class="kw">list</span>(<span class="st">`</span><span class="dt">_data</span><span class="st">`</span>), e[!matched]))
  <span class="co"># Also in case of no new column names the transformed `data_` is returned</span>
  else <span class="st">`</span><span class="dt">_data</span><span class="st">`</span>
}</code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: <code>plyr::mutate()</code> is similar to <code>transform()</code> but it applies the transformations sequentially so that transformation can refer to columns that were just created:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">5</span>)
<span class="kw">transform</span>(df, <span class="dt">x2 =</span> x *<span class="st"> </span>x, <span class="dt">x3 =</span> x2 *<span class="st"> </span>x)
plyr::<span class="kw">mutate</span>(df, <span class="dt">x2 =</span> x *<span class="st"> </span>x, <span class="dt">x3 =</span> x2 *<span class="st"> </span>x)</code></pre></div>
<p>How does mutate work? What’s the key difference between <code>mutate()</code> and <code>transform()</code>?</p>
<p><strong><span style="color:green">A</span></strong>: The main difference is the possibility of sequential transformations. Another difference is that unnamed added columns will be thrown away. For the implementation many ideas are are the same. However the key difference is that for the sequential transformations, a for loop is created which iterates over a list of expressions and simultaneously changes the environment for the evaluation of the next expression (which is the supplied data). This should become clear with some comments on the code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>mutate
function (.data, ...) 
{
  <span class="kw">stopifnot</span>(<span class="kw">is.data.frame</span>(.data) ||<span class="st"> </span><span class="kw">is.list</span>(.data) ||<span class="st"> </span><span class="kw">is.environment</span>(.data))
  <span class="co"># we catch everything supplied in `...`. But this time we save this in a list of expressions.</span>
  <span class="co"># However, again the added column names will be the names of this list.</span>
  cols &lt;-<span class="st"> </span><span class="kw">as.list</span>(<span class="kw">substitute</span>(<span class="kw">list</span>(...))[-<span class="dv">1</span>])
  cols &lt;-<span class="st"> </span>cols[<span class="kw">names</span>(cols) !=<span class="st"> &quot;&quot;</span>] <span class="co"># all unnamed arguments in `...` will be thrown away, in </span>
  <span class="co"># contrast to `transform()` above, which just creates new columnnames.</span>

  <span class="co"># Now a for loop evaluates all added columns iteratively in the context (environment)</span>
  <span class="co"># of the data. </span>
  <span class="co"># We start with the first added column:.</span>
  <span class="co"># If the column name is already in the data, the old column will be overritten. </span>
  <span class="co"># If the column name is new, it will be created</span>
  <span class="co"># Since the underlying data (the environment for the evaluation) gets automatically</span>
  <span class="co"># &quot;updated&quot; in every iteration of the for loop, it will be possible to use the new columns</span>
  <span class="co"># directly in the next iteration (which relates to the next added column)</span>
  for (col in <span class="kw">names</span>(cols)) {
    .data[[col]] &lt;-<span class="st"> </span><span class="kw">eval</span>(cols[[col]], .data, <span class="kw">parent.frame</span>())
  }
  <span class="co"># Afterwards the data gets returned</span>
  .data
}</code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: What does <code>with()</code> do? How does it work? Read the source code for <code>with.default()</code>. What does <code>within()</code> do? How does it work? Read the source code for <code>within.data.frame()</code>. Why is the code so much more complex than <code>with()</code>?</p>
<p><strong><span style="color:orange">A</span></strong>: <code>with()</code> is a generic function that allows writing an expression (second argument) that refers to variablenames of <code>data</code> (first argument) as if the corresponding variables were objects themselves.</p>
<p><code>with()</code> evaluates the expression via an</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">eval</span>(<span class="kw">substitute</span>(expr), data, <span class="dt">enclos =</span> <span class="kw">parent.frame</span>())</code></pre></div>
<p>construct in a temporary environment, which has the calling frame as a parent. This also means that variables that aren’t found in <code>data</code>, will be looked up in <code>with()</code>’s calling environment. As stated in <code>?with</code>, this is useful for modelling functions.</p>
<p>In contrast to <code>with()</code>, which returns the value of the evaluated expression, <code>within()</code> returns the modified object. So <code>within()</code> can be used as an alternative to <code>base::transform()</code>. There is also a subtile difference regarding the non standard evaluation technique (which I don’t understand in detail). <code>within()</code> first creates an environment with <code>data</code> as parent and <code>within()</code>’s calling environment as grandparent. This environment becomes changed, since afterwards the expression is evaluated inside of it. The rest of the code converts this environment into a list and ensures that new variables are not overriden by the former ones.</p></li>
</ol>
</div>
<div id="calling-from-another-function" class="section level2">
<h2><span class="header-section-number">10.4</span> Calling from another function</h2>
<ol style="list-style-type: decimal">
<li><strong><span style="color:red">Q</span></strong>: The following R functions all use NSE. For each, describe how it uses NSE, and read the documentation to determine its escape hatch.
<ul>
<li><code>rm()</code></li>
<li><code>library()</code> and <code>require()</code></li>
<li><code>substitute()</code></li>
<li><code>data()</code></li>
<li><code>data.frame()</code></li>
</ul>
<p><strong><span style="color:green">A</span></strong>: For NSE in <code>rm()</code>, we just look at its first two arguments: <code>...</code> and <code>list = character()</code>. If we supply expressions to <code>...</code> (which can also be character vectors) , these will be caught by <code>match.call()</code> and become an unevaluated call (in this case a pairlist). However, <code>rm()</code> copies and converts the expressions into a character representation and concatenates these with the character vector supplied to the list argument. Then the removing starts… The escape hatch is to supply the objects to be removed as a character vector to <code>rm()</code>’s list argument.</p>
<p>You can supply the input to <code>library()</code>’s and <code>require()</code>’s first argument (<code>package</code>) with or without quotes. In the default case (<code>character.only = FALSE</code>) the input to <code>package</code> will be converted via <code>as.character(substitute(package))</code>. To ommit this, just supply a character vector and set <code>character.only = TRUE</code>.</p>
<p><code>substitute()</code> and <code>eval()</code>/<code>quote</code> are the basic functions for NSE. To see how it’s done one has to understand parse trees and/or look into the underlying C code. The problematic behaviour of <code>substitute()</code> is pretty obvious. There might be some insights that make it predictable, but since <code>substitute()</code> is written for NSE and only contains the arguments <code>expr</code> and <code>env</code>, it seems that no escape hatch exists.</p>
<p>Like <code>rm()</code> <code>data()</code> has the first arguments <code>...</code> and <code>list = character()</code>. Again you can supply unquoted or quoted names to <code>...</code>. These will be caught, converted to character via <code>as.character(substitute(list(...))[-1L])</code> and concatenated with the character input of the <code>list</code> argument. The escape hatch is similar to <code>rm()</code>: use explicitly the <code>list</code> argument.</p>
<p><code>data.frame()</code>’s first argument, <code>...</code>, gets caught once via <code>object &lt;- as.list(substitute(list(...)))[-1L]</code> and once <code>x &lt;- list(...)</code>. First one is used among others to create rownames. This can be suppressed via the setting of the argument <code>row.names</code>, which lets you supply a vector or specifing a column of the data.frame for the explicit naming of rows. <code>x</code> will be deparsed later and is then used to create the columnnames. Since this process underlies several complex rules in cases of “special namings”, <code>data.frame()</code> provides the <code>check.names</code> argument. One can set <code>check.names = FALSE</code>, to ensure that columns will be named however they are supplied to <code>data.frame()</code>.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Base functions <code>match.fun()</code>, <code>page()</code>, and <code>ls()</code> all try to automatically determine whether you want standard or non-standard evaluation. Each uses a different approach. Figure out the essence of each approach then compare and contrast.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Add an escape hatch to <code>plyr::mutate()</code> by splitting it into two functions. One function should capture the unevaluated inputs. The other should take a data frame and list of expressions and perform the computation.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: What’s the escape hatch for <code>ggplot2::aes()</code>? What about <code>plyr::.()</code>? What do they have in common? What are the advantages and disadvantages of their differences?</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: The version of <code>subset2_q()</code> I presented is a simplification of real code. Why is the following version better?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">subset2_q &lt;-<span class="st"> </span>function(x, cond, <span class="dt">env =</span> <span class="kw">parent.frame</span>()) {
  r &lt;-<span class="st"> </span><span class="kw">eval</span>(cond, x, env)
  x[r, ]
}</code></pre></div>
<p>Rewrite <code>subset2()</code> and <code>subscramble()</code> to use this improved version.</p></li>
</ol>
</div>
<div id="substitute" class="section level2">
<h2><span class="header-section-number">10.5</span> Substitute</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: Use <code>pryr::subs()</code> to convert the LHS to the RHS for each of the following pairs:</p>
<ul>
<li><code>a + b + c</code> -&gt; <code>a * b * c</code></li>
<li><code>f(g(a, b), c)</code> -&gt; <code>(a + b) * c</code></li>
<li><code>f(a &lt; b, c, d)</code> -&gt; <code>if (a &lt; b) c else d</code></li>
</ul>
<p><strong><span style="color:green">A</span></strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">subs</span>(a +<span class="st"> </span>b +<span class="st"> </span>c, <span class="kw">list</span>(<span class="st">&quot;+&quot;</span> =<span class="st"> </span><span class="kw">quote</span>(<span class="st">`</span><span class="dt">*</span><span class="st">`</span>)))     <span class="co"># -&gt; `a * b * c`</span>
<span class="kw">subs</span>(<span class="kw">f</span>(<span class="kw">g</span>(a, b), c), <span class="kw">list</span>(<span class="dt">g =</span> <span class="kw">quote</span>(<span class="st">`</span><span class="dt">+</span><span class="st">`</span>),
                         <span class="dt">f =</span> <span class="kw">quote</span>(<span class="st">`</span><span class="dt">*</span><span class="st">`</span>)))   <span class="co"># -&gt; `(a + b) * c`</span>
<span class="kw">subs</span>(<span class="kw">f</span>(a &lt;<span class="st"> </span>b, c, d), <span class="kw">list</span>(<span class="dt">f =</span> <span class="kw">quote</span>(<span class="st">`</span><span class="dt">if</span><span class="st">`</span>))) <span class="co"># -&gt; `if (a &lt; b) c else d`</span></code></pre></div></li>
<li><strong><span style="color:red">Q</span></strong>: For each of the following pairs of expressions, describe why you can’t use <code>subs()</code> to convert one to the other.
<ul>
<li><code>a + b + c</code> -&gt; <code>a + b * c</code></li>
<li><code>f(a, b)</code> -&gt; <code>f(a, b, c)</code></li>
<li><code>f(a, b, c)</code> -&gt; <code>f(a, b)</code></li>
</ul></li>
<li><p><strong><span style="color:red">Q</span></strong>: How does <code>pryr::named_dots()</code> work? Read the source.</p></li>
</ol>
</div>
<div id="the-downsides-of-non-standard-evaluation" class="section level2">
<h2><span class="header-section-number">10.6</span> The downsides of non-standard evaluation</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: What does the following function do? What’s the escape hatch? Do you think that this is an appropriate use of NSE?</p>
<p>nl &lt;- function(…) { dots &lt;- named_dots(…) lapply(dots, eval, parent.frame()) }</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Instead of relying on promises, you can use formulas created with ~ to explicitly capture an expression and its environment. What are the advantages and disadvantages of making quoting explicit? How does it impact referential transparency?</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Read the standard non-standard evaluation rules found at <a href="http://developer.r-project.org/nonstandard-eval.pdf" class="uri">http://developer.r-project.org/nonstandard-eval.pdf</a>.</p></li>
</ol>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="function-operators.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="expressions.html" class="navigation navigation-next " aria-label="Next page""><i class="fa fa-angle-right"></i></a>

<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/Tazinho/Advanced-R-Solutions/edit/master/10-Non_standard_evaluation.Rmd",
"text": "Edit"
},
"download": null,
"toc": {
"collapse": "section",
"scroll_highlight": true
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
