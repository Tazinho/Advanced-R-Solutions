#Build network graph for advanced R solutions book cover
#Dec 2020
#Authors: Henning Bumann, Tobias Stalder


# set working dir and load packages ---------------------------------------


setwd(r"(C:\Users\tobia\OneDrive\Desktop\ownprojects\cover_advanced_R)")

packages <- c("tidyverse", "Cairo", "ggpubr", "ggalt", "ggbump", "scales", "prismatic", "treemapify","GGally",
              "intergraph", "ggraph", "visNetwork", "threejs", "networkD3", "ndtv", "igraph", "gtools")

package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)


# load and clean data to long format (snippet Henning) --------------------


df_long <- read.csv2(r"(progress_data.csv)", stringsAsFactors = FALSE, 
                     header = TRUE) %>% 
  as_tibble() %>% 
  mutate(status = "finalised") %>% 
  modify_at("status", factor,
            levels = c("open", "started", "solved", "reviewed", "finalised")) %>% 
  tibble::rowid_to_column("id") %>% 
  separate(chapter, "nr", sep = " ", remove = FALSE, extra = "drop") %>% 
  mutate(nr = as.integer(nr), 
         chapter = factor(chapter),
         chapter = fct_reorder(chapter, nr, .desc = FALSE),
         part = case_when(nr < 9 ~ "Foundations",
                          nr < 12 ~ "Functional\nProgramming",
                          nr < 17 ~ "Object Oriented\nProgramming",
                          nr < 22 ~ "Metaprogramming",
                          TRUE    ~ "Techniques"),
         part = factor(part, levels = c("Foundations", "Functional\nProgramming",
                                        "Object Oriented\nProgramming",
                                        "Metaprogramming", "Techniques"))) %>% 
  add_count(chapter)
df_long$subchapter = factor(df_long$subchapter)
head(df_long)
df_long <- data.frame(df_long)


# build network -----------------------------------------------------------
#Workflow: First off just transform data to nodes and edges and add attributes later on.
#data structure: For edges we basically need a from-to structure in 2 columns
                  #for nodes we need all from-to of the edges in one single column
                  #for nodes and edges, every columns after the inital ones will be stored as attributes.

#0) catch col values and row values together to get e.g. part_Foundations, repeat for parts and exercises
df_long %>%
  pivot_longer(part) %>%
  data.frame() %>%
  
  #build factors where we clearly see later if its a part, chapter etc.
  mutate(part_name = factor(paste0(name,"_", value)),
         exercise_name = factor(paste0("exercise_", id)),
         chapter_name = factor(paste0("chapter_", chapter))) %>%
  rename(subchapter_name = subchapter) %>%
  
  #unselect data
  select(-c(name, value, rawid, exercise, updated_by, updated_when, status, nr, chapter)) %>%

  
  #relocate columns to order part, chapter, subchapter, exercise
  relocate(part_name, .before= subchapter_name) %>%
  relocate(chapter_name, .after = part_name) %>%
  relocate(n, .after = exercise_name) -> df_ordered

df_ordered

# 1) Build network from parts to chapters (nodes = all unique parts and all unique chapters, edges = from P to C in desired connections)

# ♦nodes
#map (purr) 

df_ordered %>%
  select(part_name, chapter_name) %>%
  distinct() %>%
  data.frame() %>%
  {. ->> parts} %>%
  {. ->> chapters}

parts %>%
  select(part_name) %>%
  rename(ID = part_name) %>%
  distinct(ID) -> parts

chapters %>%
  select(chapter_name) %>%
  rename(ID = chapter_name) -> chapters

nodes <- rbind(parts, chapters)


#edges (parts must be connected and parts must be connected to respective chapters)

#get chapters per part
chapters_part_edges <- df_ordered %>%
  select(part_name, chapter_name) %>%
  group_by(part_name, chapter_name) %>%
  distinct() %>%
  rename(from = part_name,
         to = chapter_name)#these are already all connections from the parts to their respective chapters

#TO DO: Henning fragen, wie man pair-wise dubplicates identifizieren könnte (Resultat: parts sollen nur mit jeweils 1 anderem part verbunden sein?)
#sonst kann man diese part to part edges dann auch selektiv aus dem finalen svg löschen..

#get connections from to for chapters in the respective parts e.g. C1 should be connected C2 and C3 in P1 or sth
# chapter_edges <- df_ordered %>%
#   select(part_name, chapter_name) %>%
#   group_by(part_name)%>%
#   mutate(chapter_name2 = chapter_name) %>%
#   expand_grid() %>%
#   distinct() %>%
#   crossing_() %>%
#   filter(chapter_name != chapter_name2) %>%
#   rename(from = chapter_name, to = chapter_name2)
# 
# chapter_edges <- data.frame(chapter_edges)

#now we need data that connects each part to one another
#TODO Henning fragen, ob parts auch miteinander verbunden sein sollen!
part_edges <- df_ordered %>%
  select(part_name) %>%
  mutate(part_name2 = part_name) %>%
  # expand_grid() %>%
  distinct() %>%
  crossing_() %>%
  filter(part_name != part_name2) %>%
  rename(from = part_name, to = part_name2) 

part_edges <- data.frame(part_edges)

#now we still have vice-verca connections in part_edges...



#rbind the edges
edges <- rbind(chapters_part_edges, part_edges)

#build network
graph_from_data_frame(d =edges, vertices = nodes) -> net_ex

ggraph(net_ex, layout = "kk") +
  geom_edge_link(color = "grey") +
  geom_node_point(size = 3) +
  geom_node_text(aes(label = name), color = "blue", nudge_y = .2)

#2) Add complexity: Subchapters


#3) Add complexity: Exercises



