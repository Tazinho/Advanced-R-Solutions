# S4

## Classes

1. __<span style="color:red">Q</span>__: What happens if you define a new S4 class that doesn't "contain" an existing class?  (Hint: read about virtual classes in `?setClass`.)
    
   __<span style="color:green">A</span>__: It depends on the other arguments.
   If we supply a class that doesn't exist, we'll get an error
    
    ```{r, error = TRUE}
    setClass("Programmer", slots = c(skill = "ANY"), contains = "Human")
    ```
    
   However, we can get around that, if we register the class before
    
    ```{r}
    setOldClass("Human")
    .Programmer <- setClass("Programmer", slots = c(Skill = "ANY"), contains = "Human")
    ```
    
   Supplying neither `slots`, nor `contains` results in a contructor for virtual classes 
    
    ```{r}
    .VirtualProgrammer <- setClass("VirtualProgrammer")
    # The same as contains = "VIRTUAL" (here you could also supply slots)
    .VirtualProgrammer <- setClass("VirtualProgrammer", contains = "VIRTUAL")
    ```
    
   Just leaving out `contains`, but supplying slots results in a constructor without superclass
    
    ```{r}
    .DataScientist <- setClass("RProgrammer", slots = c(stats = "ANY",
                                                        math = "ANY",
                                                        programming = "ANY"))
    ```

2. __<span style="color:red">Q</span>__: Imagine you were going to reimplement ordered factors, dates, and data frames in S4. Sketch out the `setClass()` calls that you would use to define the classes. What should they inherit from? What slots should they use?

   __<span style="color:orange">A</span>__: The basic idea is to use a slot for the base type and one slot per attribute. Inheritance matters for ordered factors and dates. Special checks like equal lengths of list elements for columns of a data frame should be done within a validator.

## Generics and methods

1. __<span style="color:red">Q</span>__: In the defintion of the generic, why is it necessary to repeat the name of the generic twice?

   __<span style="color:green">A</span>__: The first time it is needed as name of the generic and the second time it is needed to explicitly incorporate method dispacth via `standardGeneric()` within the generic's body (`def` parameter). This is similar to `UseMethod()` within S3.

2. __<span style="color:red">Q</span>__: What's the difference between the generics generated by these two calls?
    
    ```{r, eval = FALSE}
    setGeneric("myGeneric", function(x) standardGeneric("myGeneric"))
    setGeneric("myGeneric", function(x) {
      standardGeneric("myGeneric")
    })
    ```
    
   __<span style="color:green">A</span>__: The first call defines a standard generic and the second one creates a nonstandard generic. One can confirm this directly whlie printing (showing in S4 jargon) the function.
    
    ```{r, eval = TRUE}
    setGeneric("myGeneric", function(x) standardGeneric("myGeneric"))
    myGeneric
    
    setGeneric("myGeneric", function(x) {
      standardGeneric("myGeneric")
    })
    myGeneric
    ```
    
3. __<span style="color:red">Q</span>__: What happens if you define a method with different argument names to the generic?

   __<span style="color:green">A</span>__: It depends. Lets first create the object `hadley` of class "Person":
    
    ```{r, eval = TRUE}
    .Person <- setClass("Person", 
                        slots = c(
                          name = "character", 
                          age = "numeric"
                        )
                      )
    
    hadley <- .Person(name = "Hadley")
    hadley
    ```
    
   Now let us see, which arguments can be supplied to the `show()` generic
    
    ```{r, eval = TRUE}
    formals("show")
    ```
    
   Usually we would use this argument when defining a new method
    
    ```{r, eval = TRUE}
    setMethod("show", "Person", 
              function(object){
                cat(object@name, "creates hard exercises")
              })
    hadley
    ```
    
   When we supply another name, for example `x` instead of `object`, as a first element of our method, this becomes matched to the correct `object` argument and we get a warning.
   However, our method will work
    
    ```{r, eval = TRUE}
    setMethod("show", "Person", 
              function(x){
                cat(x@name, "creates hard exercises")
              })
    hadley
    ```
    
   If we add more arguments to our method than our generic can handle, we will get an error
    
    ```{r, eval = TRUE, error = TRUE}
    setMethod("show", "Person", 
              function(x, y){
                cat(x@name, "is", x@age, "years old")
              })
    ```
    
   However, if we do this with arguments added to the correctly written `object` argument, we will get the informative error message, that we could in general add other argument names for generics, which can take the `...` argument
    
    ```{r, eval = TRUE, error = TRUE}
    setMethod("show", "Person", 
              function(object, y){
                cat(object@name, "is", object@age, "years old")
              })
    ```

4. __<span style="color:red">Q</span>__: What other ways can you find help for a method? Read `?"?"` and summarise the details.

   __<span style="color:green">A</span>__: We can get
    
   * general documentation of the generic via `?genericName`
   * general documentation of the methods from a generic via `methods?genericName`
   * documentation of a specific method via `ClassName?methodName`
    
   Regarding the latter, we can also get help on a specific method via adding a `?` in front of a function call, like `?show(hadley)`.


## Method dispatch 

1. __<span style="color:red">Q</span>__: Take the last example which shows multiple dispatch over two classes that use multiple inheritance. What happens if you define a method for all terminal classes? Why does method dispatch not save us much work here?

   __<span style="color:green">A</span>__: We will introduce ambiguity, since one class has distance 2 to all terminal nodes and the other 4 have distance 1 to two terminal nodes each. To resolve this ambiguity we have to define 5 more methods, one per class combination.
