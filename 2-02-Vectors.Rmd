# Vectors

## Atomic vectors

1. __<span style="color:red">Q</span>__: How do you create scalars of type raw and complex? (See `?raw` and `?complex`)

   __<span style="color:green">A</span>__: In R scalars are represented as vectors of length one. For raw and complex types these can be created via `raw()` and `complex()`, i.e.:
  
    ```{r}
    raw(1)
    complex(1)
    ```
  
   Raw vectors can easily be created from numeric or character values.
  
    ```{r}
    as.raw(42)
    charToRaw("A")
    ```
  
   For complex numbers real and imaginary parts may be provided directly.
  
    ```{r}
    complex(length.out = 1, real = 1, imaginary = 1)
    ```

2. __<span style="color:red">Q</span>__: Test your knowledge of vector coercion rules by predicting the output of the following uses of `c()`: 

    ```{r, eval=FALSE}
    c(1, FALSE)      # will be coerced to numeric   -> 1 0
    c("a", 1)        # will be coerced to character -> "a" "1"
    c(TRUE, 1L)      # will be coerced to integer   -> 1 1
    ```

3. __<span style="color:red">Q</span>__: Why is `1 == "1"` true? Why is `-1 < FALSE` true? Why is `"one" < 2` false?  

   __<span style="color:green">A</span>__: These comparisons are carried out by operator-functions, which coerce their arguments to a common type. In the examples above these cases will be character, double and character: `1` will be coerced to `"1"`, `FALSE` is represented as `0` and `2` turns into `"2"` (and numerals preceed letters in ASCII).

4. __<span style="color:red">Q</span>__: Why is the default missing value, `NA`, a logical vector? What's special about logical vectors? (Hint: think about `c(FALSE, NA_character_)`.)  
   
   __<span style="color:green">A</span>__: The presence of missing values shouldn´t affect the type of an object. Recall that there is a type-hierarchy for coercion from character >> double >> integer >> logical. When combining `NA`s  with other atomic types, the `NA`s will be coerced to integer (`NA_integer_`), double (`NA_real_`) or character (`NA_character_`) and not the other way round.  If `NA` was a character and added to a set of other values all of these would be coerced to character as well.

5. __<span style="color:red">Q</span>__: Precisely what do `is.atomic()`, `is.numeric()`, and `is.vector()` test for?
   
   __<span style="color:green">A</span>__: The documentation states that:
   - **`is.atomic()`** tests if an object has one of these types: `"logical"`, `"integer"`, `"double"`, `"complex"`, `"character"`, `"raw"` or `"NULL"` (!).
   - **`is.numeric()`** tests if an object has integer or double type and is not of `"factor"`, `"Date"`, `"POSIXt"` or `"difftime"` class.
   - **`is.vector()`** tests if an object has no attributes, except of names and if its `mode()` is atomic (`"logical"`, `"integer"`, `"double"`, `"complex"`, `"character"`, `"raw"`), `"list"` or `"expression"`.

## Attributes

1. __<span style="color:red">Q</span>__: How is `setNames()` implemented? How is `unname()` implemented? Read the source code.
   
   __<span style="color:green">A</span>__: `setNames()` is implemented as:
   
    ```{r}
    setNames
    ```
   
   Because the data argument comes first `setNames()` also works well with the magrittr-pipe operator. When no first argument is given, the result is a named vector:
   
    ```{r}
   setNames( , c("a", "b", "c"))
    ```
   
   `setNames()` only affects the names-attribute and ignores other more specific name-related attributes such as dimnames (for matrices and arrays).
   
   `unname()` is implemented in the following way:
   
    ```{r}
    unname
    ```
   
   `unname()` removes existing names- and dimnames-attributes. Note that by default the dimnames attribute (names and row names) won't be affected for data frames.
   
2. __<span style="color:red">Q</span>__: What does `dim()` return when applied to a 1d vector? When might you use `NROW()` or `NCOL()`?
    
   __<span style="color:green">A</span>__: From `?nrow`:
    
   > `dim()` will return `NULL` when applied to a 1d vector.
   
   One may want to use `NROW()` or `NCOL()` to handle atomic vectors, lists and NULL values similar to one column matrices or data frames. For these objects `nrow()` and `ncol()` return `NULL`. This may occurr in interactive data analysis, while subsetting data frames. 

    ```{r}
    NROW(iris[, 1])  # default drop = TRUE results in vector
    NCOL(iris[, 1])
    nrow(iris[, 1])
    ncol(iris[, 1])
    ```

3. __<span style="color:red">Q</span>__: How would you describe the following three objects? What makes them different to `1:5`?

    ```{r}
    x1 <- array(1:5, c(1, 1, 5))  # 1 row,  1 column,  5 in third dimension
    x2 <- array(1:5, c(1, 5, 1))  # 1 row,  5 columns, 1 in third dimension
    x3 <- array(1:5, c(5, 1, 1))  # 5 rows, 1 column,  1 in third dimension
    ```
    
   __<span style="color:green">A</span>__: These objects have the class array instead of vector. Their dimensions are stored in the `dim` attribute.

4. __<span style="color:red">Q</span>__: An early draft used this code to illustrate `structure()`:

    ```{r}
    structure(1:5, comment = "my attribute")
    ```

   But when you print that object you don't see the comment attribute. Why? Is the attribute missing, or is there something else special about it? (Hint: try using help.) \index{attributes!comment}
    
   __<span style="color:green">A</span>__: The documentation states (see `?comment`):  
    
   > Contrary to other attributes, the comment is not printed (by print or print.default).
    
   Also, from `?attributes`:
    
   > Note that some attributes (namely class, comment, dim, dimnames, names, row.names and tsp) are treated specially and have restrictions on the values which can be set.
   
   We can retrieve comment attributes by calling them explicitly:

    ```{r}
    foo <- structure(1:5, comment = "my attribute")
    
    attributes(foo)
    attr(foo, which = "comment")
    ```


## S3 atomic vectors
1. __<span style="color:red">Q</span>__: What sort of object does `table()` return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?
    
   __<span style="color:green">A</span>__: `table()` returns a cross tabulation of its input. The result is an S3 table object, which is an array (implicit class) of integers (type) under the hood. Attributes are dim (dimension of the underlying array) and dimnames (one for each input column). The dimensionality equals to the number of unique values (accordingly factor levels) of the input arguments, i.e.:
  
    ```{r}
    dim(table(iris))
    sapply(iris, function(x) length(unique(levels(as.factor(x)))))
    ```
    
2. __<span style="color:red">Q</span>__: What happens to a factor when you modify its levels? 
    
    ```{r, results = "none"}
    f1 <- factor(letters)
    levels(f1) <- rev(levels(f1))
    ```
    
   __<span style="color:green">A</span>__: Both, the entries of the factor and also its levels are being reversed:
    
    ```{r}
    f1
    ```
    
3. __<span style="color:red">Q</span>__: What does this code do? How do `f2` and `f3` differ from `f1`?

    ```{r, results = "none"}
    f2 <- rev(factor(letters)) # changes only the entries of the factor
    f3 <- factor(letters, levels = rev(letters)) # changes only the levels of the factor
    ```
    
   __<span style="color:green">A</span>__: Unlike `f1` `f2` and `f3` change only one thing. They change the order of the factor or its levels, but not both at the same time.


## Lists
1. __<span style="color:red">Q</span>__: List all the ways that a list differs from an atomic vector.

   __<span style="color:green">A</span>__: 
   
   - Atomic vectors are homogeneous (all contents must be of the same type). Lists are heterogeneous (all contents can be of different types). 
   
   - Atomic vectors point to one value, while lists contain references which point to one value each:

    ```{r}
    lobstr::ref(1:3)
    lobstr::ref(list(1:3,2,3))
    ```
    
   - Subsetting with out of bound values and `NA`s leads to `NA`s for atomics and `NULL` values for lists:
    
    ```{r}
    (1:2)[3]
    as.list(1:2)[3]
    
    (1:2)[NA]
    as.list(1:2)[NA]
    ```
   
2. __<span style="color:red">Q</span>__: Why do you need to use `unlist()` to convert a list to an atomic vector? Why doesn't `as.vector()` work?  
   
   __<span style="color:green">A</span>__: To get rid of (flatten) the nested structure `as.vector()` doesn't work, because a list is already a vector.

3. __<span style="color:red">Q</span>__: Compare and contrast `c()` and `unlist()` when combining a date and date-time into a single vector.

   __<span style="color:green">A</span>__: Date and date-time objects are build upon doubles. Dates are represented as days, while date-time-objects (POSIXct) represent seconds (counted in regard to the reference date 1970-01-01, also known as "The Epoch").
   
   Let's define date and date-time objects:

    ```{r}
    date    <- as.Date("1970-01-02")
    dttm_ct <- as.POSIXct("1970-01-01 01:00", tz = "UTC")
    ```
    
   When combining these objects method-dispatch leads to surprising output:

    ```{r}
    c(date, dttm_ct)  # equal to c.Date(date, dttm_ct) 
    c(dttm_ct, date)  # equal to c.POSIXct(date, dttm_ct)
    ```

   The generic function dispatches based on the class of its first argument. When `c.Date()` is executed, `dttm_ct` is converted to a date, but the 3600 seconds are mistaken for 3600 days! When `c.POSIXct()` is called on `date`, one day counts as one second only, as illustrated by the following line:

    ```{r}
    unclass(c(date, dttm_ct))  # internal representation
    date + 3599
    ```

   Some of these problems may be avoided via explicit conversion of the classes:

    ```{r}
    c(as.Date(dttm_ct, tz = "UTC"), date)
    ```

   Let's look at `unlist()`, which operates on list input.

    ```{r}    
    # attributes are stripped
    unlist(list(date, dttm_ct))  
    ```

   We see that internally dates(-times) are doubles. Unfortunately this is all we are left with, when unlist strips the attributes of the list. (This wouldn't happen for vector input, but then we would have to combine the different classes into one vector, which is tricky as seen above.)

   To summarise: `c()` coerces types and errors may occur because of inappropriate method dispatch. `unlist()` strips attributes.
   
<!-- ```{r} -->
<!-- # interestingly combining date and POSIXlt is working -->
<!-- dttm_lt <- as.POSIXlt(dttm_ct) -->
<!-- c.POSIXlt(date, dttm_lt)  # o.k. -->
<!-- ``` -->
<!-- ```{r} -->
<!-- c(date,    dttm_ct) -->
<!-- unlist(c(date,    dttm_ct)) # no difference -->
<!-- ``` -->


## Data frames and tibbles
1. __<span style="color:red">Q</span>__: Can you have a data frame with 0 rows? What about 0 columns?  

   __<span style="color:green">A</span>__: Yes, you can create one easily and in many ways. Also both dimensions can be 0. The fastest way is to subset the regarding dimension with one of `0`, `NULL` or a valid 0-length atomic (`logical(0)`, `character(0)`, `integer(0)`, `double(0)`). Also a negative integer sequence would work. Here we use the recycling rules for logical subsetting:

    ```{r}
    iris[FALSE,]
    
    iris[ , FALSE] # or iris[FALSE]
    
    iris[FALSE, FALSE] # or just data.frame()
    ```

2. __<span style="color:red">Q</span>__: What happens if you attempt to set rownames that are not unique?

   __<span style="color:green">A</span>__ For matrices this will work without any problems. For data frames it is not possible and what happens depends on the approach. When using the `row.names<-` replacement function, no further arguments can be set and the underlying `.rowNamesDF<-` will throw an error (and an additional warning):
    
    ```{r, error = TRUE, warning = TRUE}
    row.names(mtcars) <- rep(1, nrow(mtcars))
    ```
    
   However, by calling `.rowNamesDF<-` directly one can set the `make.names` argument to `NA` or `TRUE`. When set to `NA`, any non unique row name will trigger the new row names to become `seq_len(nrow(x))`. When `make.names = TRUE`, row names will automatically converted into unique ones via `make.names(value, unique = TRUE)`. The same behaviour is caused, when a matrix with non unique row names is converted into a data frame.

3. __<span style="color:red">Q</span>__: If `df` is a data frame, what can you say about `t(df)`, and `t(t(df))`? Perform some experiments, making sure to try different column types.

   __<span style="color:green">A</span>__ Both will return matrices with dimensions regarding the typical transposition rules. As `t()` uses `as.matrix.data.frame()` for the preprocessing in front of applying `t.default()` and elements of matrices need to be of the same type, all elements get coerced in the usual order (logical << integer << double << character), while factors, dates and datetimes are treated as characters during coercion.

4. __<span style="color:red">Q</span>__: What does `as.matrix()` do when applied to a data frame with columns of different types? How does it differ from `data.matrix()`?
    
   __<span style="color:green">A</span>__: From `?as.matrix`:
    
   > The method for data frames will return a character matrix if there is only atomic columns and any non-(numeric/logical/complex) column, applying as.vector to factors and format to other non-character columns. Otherwise the usual coercion hierarchy (logical < integer < double < complex) will be used, e.g., all-logical data frames will be coerced to a logical matrix, mixed logical-integer will give a integer matrix, etc.
    
   Let´s tranform a dummy data frame into a character matrix. Note that `format()` is applied to the characters, which may complicate conversion back to the previous type. (For example `TRUE` is transformed to `" TRUE"` (starting with a space))

    ```{r}
    df_coltypes <- data.frame(a = c("a", "b"),
                              b = c(TRUE, FALSE),
                              c = c("TRUE", "FALSE"),
                              d = c(1L, 0L),
                              e = c(1.5, 2),
                              f = c("one" = 1, "two" = 2),
                              g = factor(c("f1", "f2")),
                              stringsAsFactors = FALSE)
    
    as.matrix(df_coltypes)
    ```
    
   From `?as.data.matrix`:
    
   > Return the matrix obtained by converting all the variables in a data frame to numeric mode and then binding them together as the columns of a matrix. Factors and ordered factors are replaced by their internal codes.
    
   `data.matrix()` returns a numeric matrix, where characters are replace by missing values:
    
    ```{r}
    data.matrix(df_coltypes)
    ```


## Old exercises

1. __<span style="color:red">Q</span>__: What does `dim()` return when applied to a vector?  
   __<span style="color:green">A</span>__: `NULL`

2. __<span style="color:red">Q</span>__: If `is.matrix(x)` is `TRUE`, what will `is.array(x)` return?  
   __<span style="color:green">A</span>__: `TRUE`, as also documented in `?array`:
    
   > A two-dimensional array is the same thing as a matrix.

3. __<span style="color:red">Q</span>__: What attributes does a data frame possess?  
   __<span style="color:green">A</span>__: names, row.names and class.

4. __<span style="color:red">Q</span>__: What are the six types of atomic vector? How does a list differ from an
   atomic vector?  
   __<span style="color:green">A</span>__: The six types are logical, integer, double, character, complex and raw. The elements of a list
don't have to be of the same type.

5. __<span style="color:red">Q</span>__: What makes `is.vector()` and `is.numeric()` fundamentally different to
   `is.list()` and `is.character()`?  
   __<span style="color:green">A</span>__: The first two tests don't check for a specific type.  
