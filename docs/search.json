[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced R Solutions",
    "section": "",
    "text": "Welcome\nThis is the website for “Advanced R Solutions” which provides solutions to the exercises from Hadley Wickham’s Advanced R, 2nd edition. A print version of this book will soon be released as part of Chapman & Hall’s R Series. Working through the exercises and their solutions will give you a deep understanding of a variety of programming challenges, many of which are relevant to everyday work.\nSolutions to the first edition of Advanced R can be found at https://advanced-r-solutions-ed1.netlify.com."
  },
  {
    "objectID": "index.html#about-the-authors",
    "href": "index.html#about-the-authors",
    "title": "Advanced R Solutions",
    "section": "About the authors",
    "text": "About the authors\nMalte Grosser is a business mathematician from Hamburg, who has been programming in R regularly since the beginning of his career. He is currently finishing his PhD on machine learning for stroke outcome prediction and develops solutions in business as a data scientist.\nHenning Bumann is a psychologist and statistician who enjoys making sense of data and is motivated to build data-driven solutions that are beautiful and meaningful. He prefers free programming tools to support effective and transparent collaboration.\nHadley Wickham is Chief Scientist at RStudio, an Adjunct Professor at Stanford University and the University of Auckland, and a member of the R Foundation. He is the lead developer of the tidyverse, a collection of R packages, including ggplot2 and dplyr, designed to support data science.\nMauricio “Pacha” Vargas Sepulveda is completing a PhD in Political Science at the University of Toronto, specializing in International Relations and Public Policy. His research primarily focuses on the political dynamics of trade agreements and sanctions, which had led him to learn R, Python, and C++."
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Advanced R Solutions",
    "section": "License",
    "text": "License\nThis work, as a whole, is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License."
  },
  {
    "objectID": "02_Names_and_values.html#prerequisites",
    "href": "02_Names_and_values.html#prerequisites",
    "title": "2 - Names and values",
    "section": "Prerequisites",
    "text": "Prerequisites\nIn this chapter we will use the {lobstr} package (Wickham 2019) to help answer questions regarding the internal representation of R objects.\n\nlibrary(lobstr)"
  },
  {
    "objectID": "02_Names_and_values.html#binding-basics",
    "href": "02_Names_and_values.html#binding-basics",
    "title": "2 - Names and values",
    "section": "Binding basics",
    "text": "Binding basics\nQ1: Explain the relationship between a, b, c, and d in the following code:\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\nA: a, b, and c point to the same object (with the same address in memory). This object has the value 1:10. d points to a different object with the same value.\n\nlist_of_names &lt;- list(a, b, c, d)\nobj_addrs(list_of_names)\n#&gt; [1] \"0x579852a52008\" \"0x579852a52008\" \"0x579852a52008\" \"0x579852b9b088\"\n\nQ2: The following code accesses the mean function in multiple ways. Do they all point to the same underlying function object? Verify this with lobstr::obj_addr().\n\nmean\nbase::mean\nget(\"mean\")\nevalq(mean)\nmatch.fun(\"mean\")\n\nA: Yes, they point to the same object. We confirm this by inspecting the address of the underlying function object.\n\nmean_functions &lt;- list(\n  mean,\n  base::mean,\n  get(\"mean\"),\n  evalq(mean),\n  match.fun(\"mean\")\n)\n\nunique(obj_addrs(mean_functions))\n#&gt; [1] \"0x5798501620b8\"\n\nQ3: By default, base R data import functions, like read.csv(), will automatically convert non-syntactic names to syntactic ones. Why might this be problematic? What option allows you to suppress this behaviour?\nA: Column names are often data, and the underlying make.names() transformation is non-invertible, so the default behaviour corrupts data. To avoid this, set check.names = FALSE.\nQ4: What rules does make.names() use to convert non-syntactic names into syntactic ones?\nA: A valid name must start with a letter or a dot (not followed by a number) and may further contain numbers and underscores (\"_\"s are allowed since R version 1.9.0).\nThree main mechanisms ensure syntactically valid names (see ?make.names):\n\nNames that do not start with a letter or a dot will be prepended with an \"X\".\n::: {.cell layout-align=“center” hash=‘02_Names_and_values_cache/html/unnamed-chunk-7_f6ccd6953d5a91424d54eb5b450943a0’}\nmake.names(\"\") # prepending \"x\"\n#&gt; [1] \"X\"\n:::\nThe same holds for names that begin with a dot followed by a number.\n::: {.cell layout-align=“center” hash=‘02_Names_and_values_cache/html/unnamed-chunk-8_3c866f40ef56f4f8e63bf8e89559c7e8’}\nmake.names(\".1\") # prepending \"X\"\n#&gt; [1] \"X.1\"\n:::\nAdditionally, non-valid characters are replaced by a dot.\n::: {.cell layout-align=“center” hash=‘02_Names_and_values_cache/html/unnamed-chunk-9_860c452c7c7ee11fe572d39a98a28b68’}\nmake.names(\"non-valid\") # \".\" replacement\n#&gt; [1] \"non.valid\"\nmake.names(\"@\") # prepending \"X\" + \".\" replacement\n#&gt; [1] \"X.\"\nmake.names(\"  R\") # prepending \"X\" + \"..\" replacement\n#&gt; [1] \"X..R\"\n:::\nReserved R keywords (see ?reserved) are suffixed by a dot.\n::: {.cell layout-align=“center” hash=‘02_Names_and_values_cache/html/unnamed-chunk-10_424c337c3ffcfb23561e4b66ebfe240a’}\nmake.names(\"if\") # \".\" suffix\n#&gt; [1] \"if.\"\n:::\n\nInterestingly, some of these transformations are influenced by the current locale. From ?make.names:\n\nThe definition of a letter depends on the current locale, but only ASCII digits are considered to be digits.\n\nQ5: I slightly simplified the rules that govern syntactic names. Why is .123e1 not a syntactic name? Read ?make.names for the full details.\nA: .123e1 is not a syntactic name, because it starts with one dot which is followed by a number. This makes it a double, 1.23."
  },
  {
    "objectID": "02_Names_and_values.html#copy-on-modify",
    "href": "02_Names_and_values.html#copy-on-modify",
    "title": "2 - Names and values",
    "section": "Copy-on-modify",
    "text": "Copy-on-modify\nQ1: Why is tracemem(1:10) not useful?\nA: When 1:10 is called an object with an address in memory is created, but it is not bound to a name. Therefore, the object cannot be called or manipulated from R. As no copies will be made, it is not useful to track the object for copying.\n\nobj_addr(1:10) # the object exists, but has no name\n#&gt; [1] \"0x5798525d5010\"\n\nQ2: Explain why tracemem() shows two copies when you run this code. Hint: carefully look at the difference between this code and the code shown earlier in the section.\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\nx[[3]] &lt;- 4\n\nA: Initially the vector x has integer type. The replacement call assigns a double to the third element of x, which triggers copy-on-modify.\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n#&gt; &lt;0x66a4a70&gt;\n\nx[[3]] &lt;- 4\n#&gt; tracemem[0x55eec7b3af38 -&gt; 0x55eec774cc18]:\n\nWe can avoid the copy by sub-assigning an integer instead of a double:\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n#&gt; &lt;0x55eec6940ae0&gt;\n\nx[[3]] &lt;- 4L\n\nPlease be aware that running this code in RStudio will result in additional copies because of the reference from the environment pane.\nQ3: Sketch out the relationship between the following objects:\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\nA: a contains a reference to an address with the value 1:10. b contains a list of two references to the same address as a. c contains a list of b (containing two references to a), a (containing the same reference again) and a reference pointing to a different address containing the same value (1:10).\n\n\n\n\n\n\n\n\n\nWe can confirm these relationships by inspecting the reference tree in R.\n\nref(c)\n#&gt; █ [1:0x55erc93cbdd8] &lt;list&gt;    # c\n#&gt; ├─█ [2:0x55efcb8246e8] &lt;list&gt;  # - b\n#&gt; │ ├─[3:0x55eac7df4e98] &lt;int&gt;   # -- a\n#&gt; │ └─[3:0x55eac7df4e98]         # -- a\n#&gt; ├─[3:0x55eac7df4e98]           # - a\n#&gt; └─[4:0x55etc7aa6968] &lt;int&gt;     # - 1:10\n\nQ4: What happens when you run this code:\n\nx &lt;- list(1:10)\nx[[2]] &lt;- x\n\nDraw a picture.\nA: The initial reference tree of x shows that the name x binds to a list object. This object contains a reference to the integer vector 1:10.\n\nx &lt;- list(1:10)\n\nref(x)\n#&gt; █ [1:0x55853b74ff40] &lt;list&gt;\n#&gt; └─[2:0x534t3abffad8] &lt;int&gt;\n\n\n\n\n\n\n\n\n\n\nWhen x is assigned to an element of itself, copy-on-modify takes place and the list is copied to a new address in memory.\n\ntracemem(x)\nx[[2]] &lt;- x\n#&gt; tracemem[0x55853b74ff40 -&gt; 0x5d553bacdcd8]:\n\nThe list object previously bound to x is now referenced in the newly created list object. It is no longer bound to a name. The integer vector is referenced twice.\n\nref(x)\n#&gt; █ [1:0x5d553bacdcd8] &lt;list&gt;\n#&gt; ├─[2:0x534t3abffad8] &lt;int&gt;\n#&gt; └─█ [3:0x55853b74ff40] &lt;list&gt;\n#&gt;   └─[2:0x534t3abffad8]"
  },
  {
    "objectID": "02_Names_and_values.html#object-size",
    "href": "02_Names_and_values.html#object-size",
    "title": "2 - Names and values",
    "section": "Object size",
    "text": "Object size\n\nQ1: In the following example, why are object.size(y) and obj_size(y) so radically different? Consult the documentation of object.size().\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n#&gt; 8005648 bytes\nobj_size(y)\n#&gt; 80.90 kB\n\nA: object.size() doesn’t account for shared elements within lists. Therefore, the results differ by a factor of ~ 100.\nQ2: Take the following list. Why is its size somewhat misleading?\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n#&gt; 17.55 kB\n\nA: All three functions are built-in to R as part of the {base} and {stats} packages and hence always available. So, what does it mean to measure the size of something that’s already included in R?\n(There’s typically a more general question about what you want to know when you ask for the size of something — do you want to know how much data you’d need to send to communicate the object to someone else (e.g. serialise it), or do you want to know how much memory you’d free if you deleted it?)\nLet us look for how many other objects this applies to as well.\nThe following packages are usually loaded by default.\n\nbase_pkgs &lt;- c(\n  \"package:stats\", \"package:graphics\", \"package:grDevices\",\n  \"package:utils\", \"package:datasets\", \"package:methods\",\n  \"package:base\"\n)\n\nTo look up all functions from these packages we iterate over base_pkgs and apply ls() and mget() within each iteration.\n\nbase_objs &lt;- base_pkgs %&gt;%\n  lapply(as.environment) %&gt;%\n  lapply(function(x) mget(ls(x, all.names = TRUE), x)) %&gt;%\n  setNames(base_pkgs)\n\nThis gives us more than 2700 objects which are usually available by default.\n\nsum(lengths(base_objs))\n#&gt; [1] 2776\n\n# We can also show the sizes in MB per package\nvapply(base_objs, obj_size, double(1)) / 1024^2\n#&gt;     package:stats  package:graphics package:grDevices     package:utils \n#&gt;            11.150             3.114             2.315             7.283 \n#&gt;  package:datasets   package:methods      package:base \n#&gt;             0.558            13.962            21.310\n\n# Check if we've over-counted\nas.numeric(obj_size(!!!base_objs)) / 1024^2\n#&gt; [1] 57.9\n\nQ3: Predict the output of the following code:\n\na &lt;- runif(1e6)\nobj_size(a)\n\nb &lt;- list(a, a)\nobj_size(b)\nobj_size(a, b)\n\nb[[1]][[1]] &lt;- 10\nobj_size(b)\nobj_size(a, b)\n\nb[[2]][[1]] &lt;- 10\nobj_size(b)\nobj_size(a, b)\n\nA: In R (on most platforms) a length-0 vector has 48 bytes of overhead.\n\nobj_size(list())\n#&gt; 48 B\nobj_size(double())\n#&gt; 48 B\nobj_size(character())\n#&gt; 48 B\n\nA single double takes up an additional 8 bytes of memory.\n\nobj_size(double(1))\n#&gt; 56 B\nobj_size(double(2))\n#&gt; 64 B\n\nSo, a 1 million double should take up 8,000,048 bytes.\n\na &lt;- runif(1e6)\nobj_size(a)\n#&gt; 8.00 MB\n\n(If you look carefully at the amount of memory occupied by short vectors, you will notice that the pattern is actually more complicated. This has to do with how R allocates memory and is not that important. If you want to know the full details, they’re discussed in the 1st edition of Advanced R: http://adv-r.had.co.nz/memory.html#object-size).\nFor b &lt;- list(a, a) both list elements contain references to the same memory address.\n\nb &lt;- list(a, a)\nref(a, b)\n#&gt; [1:0x579859a76fc0] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [2:0x579852b66208] &lt;list&gt; \n#&gt; ├─[1:0x579859a76fc0] \n#&gt; └─[1:0x579859a76fc0]\n\nTherefore, no additional memory is required for the second list element. The list itself requires 64 bytes, 48 bytes for an empty list and 8 bytes for each element (obj_size(vector(\"list\", 2))). This lets us predict 8,000,048 B + 64 B = 8,000,112 B.\n\nobj_size(b)\n#&gt; 8.00 MB\n\nWhen we modify the first element of b[[1]] copy-on-modify occurs. Both elements will still have the same size (8,000,040 B), but the first one gets a new address in memory. As b’s elements don’t share references anymore, its object size adds up to the sum of the elements and the length-2 list: 8,000,048 B + 8,000,048 B + 64 B = 16,000,160 B (16 MB).\n\nb[[1]][[1]] &lt;- 10\nobj_size(b)\n#&gt; 16.00 MB\n\nThe second element of b still references the same address as a, so the combined size of a and b is the same as b.\n\nobj_size(a, b)\n#&gt; 16.00 MB\nref(a, b)\n#&gt; [1:0x579859a76fc0] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [2:0x5798587d8828] &lt;list&gt; \n#&gt; ├─[3:0x57985cdf4fa0] &lt;dbl&gt; \n#&gt; └─[1:0x579859a76fc0]\n\nWhen we modify the second element of b, this element will also point to a new memory address. This does not affect the size of the list.\n\nb[[2]][[1]] &lt;- 10\nobj_size(b)\n#&gt; 16.00 MB\n\nHowever, as b doesn’t share references with a anymore, the memory usage of the combined objects increases.\n\nref(a, b)\n#&gt; [1:0x579859a76fc0] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [2:0x579858188b58] &lt;list&gt; \n#&gt; ├─[3:0x57985cdf4fa0] &lt;dbl&gt; \n#&gt; └─[4:0x57985af6c830] &lt;dbl&gt;\nobj_size(a, b)\n#&gt; 24.00 MB"
  },
  {
    "objectID": "02_Names_and_values.html#modify-in-place",
    "href": "02_Names_and_values.html#modify-in-place",
    "title": "2 - Names and values",
    "section": "Modify-in-place",
    "text": "Modify-in-place\n\nQ1: Explain why the following code doesn’t create a circular list.\n\nx &lt;- list()\nx[[1]] &lt;- x\n\nA: In this situation copy-on-modify prevents the creation of a circular list. Let us step through the details:\n\nx &lt;- list() # creates initial object\nobj_addr(x)\n#&gt; [1] \"0x55862f23ab80\"\n\ntracemem(x)\n#&gt; [1] \"&lt;0x55862f23ab80&gt;\"\nx[[1]] &lt;- x # Copy-on-modify triggers new copy\n#&gt; tracemem[0x55862f23ab80 -&gt; 0x55862e8ce028]:\n\nobj_addr(x) # copied object has new memory address\n#&gt; [1] \"0x55862e8ce028\"\nobj_addr(x[[1]]) # list element contains old memory address\n#&gt; [1] \"0x55862f23ab80\"\n\nQ2: Wrap the two methods for subtracting medians into two functions, then use the {bench} package to carefully compare their speeds. How does performance change as the number of columns increase?\nA: First, we define a function to create some random data.\n\ncreate_random_df &lt;- function(nrow, ncol) {\n  random_matrix &lt;- matrix(runif(nrow * ncol), nrow = nrow)\n  as.data.frame(random_matrix)\n}\n\ncreate_random_df(2, 2)\n#&gt;      V1     V2\n#&gt; 1 0.972 0.0116\n#&gt; 2 0.849 0.4339\n\nNext, we wrap the two approaches to subtract numerical values (in our case medians) from each column of a data frame in their own function. We name these functions depending on whether the approach operates on a data frame or a list. For a fairer comparison, the second function also contains the overhead code to convert between data frame and list objects.\n\nsubtract_df &lt;- function(x, medians) {\n  for (i in seq_along(medians)) {\n    x[[i]] &lt;- x[[i]] - medians[[i]]\n  }\n  x\n}\n\nsubtract_list &lt;- function(x, medians) {\n  x &lt;- as.list(x)\n  x &lt;- subtract_df(x, medians)\n  list2DF(x)\n}\n\nThis lets us profile the performance, via benchmarks on data frames with differing numbers of columns. Therefore, we create a small helper that creates our random data frame and its medians before it benchmarks the two approaches by employing the {bench} package (Hester 2020).\n\nbenchmark_medians &lt;- function(ncol) {\n  df &lt;- create_random_df(nrow = 1e4, ncol = ncol)\n  medians &lt;- vapply(df, median, numeric(1), USE.NAMES = FALSE)\n\n  bench::mark(\n    \"data frame\" = subtract_df(df, medians),\n    \"list\" = subtract_list(df, medians),\n    time_unit = \"ms\"\n  )\n}\n\nbenchmark_medians(1)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression    min median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 data frame 0.0130 0.0149    60947.    99.1KB     61.0\n#&gt; 2 list       0.0124 0.0141    65028.    78.2KB     65.1\n\nThe bench::press() function allows us to run our helper across a grid of parameters. We will use it to slowly increase the number of data frame columns in our benchmark.\n\nresults &lt;- bench::press(\n  ncol = c(1, 10, 50, 100, 250, 300, 400, 500, 750, 1000),\n  benchmark_medians(ncol)\n)\n#&gt; Running with:\n#&gt;     ncol\n#&gt;  1     1\n#&gt;  2    10\n#&gt;  3    50\n#&gt;  4   100\n#&gt;  5   250\n#&gt;  6   300\n#&gt;  7   400\n#&gt;  8   500\n#&gt;  9   750\n#&gt; 10  1000\n\nFinally, we can plot and interpret our results.\n\nlibrary(ggplot2)\n\nggplot(\n  results,\n  aes(ncol, median, col = attr(expression, \"description\"))\n) +\n  geom_point(size = 2) +\n  geom_smooth() +\n  labs(\n    x = \"Number of Columns\",\n    y = \"Execution Time (ms)\",\n    colour = \"Data Structure\"\n  ) +\n  theme(legend.position = \"top\")\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\nWhen working directly with the data frame, the execution time grows quadratically with the number of columns in the input data. This is because (e.g.) the first column must be copied n times, the second column n-1 times, and so on. When working with a list, the execution time increases only linearly.\nObviously in the long run, linear growth creates shorter run-times, but there is some cost to this strategy — we have to convert between data structures with as.list() and list2DF(). Even though this is fast and probably doesn’t hurt much, the improved approach doesn’t really pay off in this scenario until we get to a data frame that is about 300 columns wide (with the exact value depending on the characteristics of the system running the code).\nQ3: What happens if you attempt to use tracemem() on an environment?\nA: tracemem() cannot be used to mark and trace environments.\n\nx &lt;- new.env()\ntracemem(x)\n#&gt; Error in tracemem(x): 'tracemem' is not useful for promise and environment objects\n\nThe error occurs because “it is not useful to trace NULL, environments, promises, weak references, or external pointer objects, as these are not duplicated” (see ?tracemem). Environments are always modified in place."
  },
  {
    "objectID": "02_Names_and_values.html#references",
    "href": "02_Names_and_values.html#references",
    "title": "2 - Names and values",
    "section": "References",
    "text": "References\n\n\n\n\nHester, Jim. 2020. Bench: High Precision Timing of r Expressions. https://github.com/r-lib/bench.\n\n\nWickham, Hadley. 2019. Lobstr: Visualize r Data Structures with Trees. https://github.com/r-lib/lobstr."
  },
  {
    "objectID": "03_Vectors.html#atomic-vectors",
    "href": "03_Vectors.html#atomic-vectors",
    "title": "3 - Vectors",
    "section": "Atomic vectors",
    "text": "Atomic vectors\nQ1: How do you create raw and complex scalars? (See ?raw and ?complex.)\nA: In R, scalars are represented as vectors of length one. However, there’s no built-in syntax like there is for logicals, integers, doubles, and character vectors to create individual raw and complex values. Instead, you have to create them by calling a function.\nFor raw vectors you can use either as.raw() or charToRaw() to create them from numeric or character values.\n\nas.raw(42)\n#&gt; [1] 2a\ncharToRaw(\"A\")\n#&gt; [1] 41\n\nIn the case of complex numbers, real and imaginary parts may be provided directly to the complex() constructor.\n\ncomplex(length.out = 1, real = 1, imaginary = 1)\n#&gt; [1] 1+1i\n\nYou can create purely imaginary numbers (e.g.) 1i, but there is no way to create complex numbers without + (e.g. 1i + 1).\nQ2: Test your knowledge of vector coercion rules by predicting the output of the following uses of c():\n\nc(1, FALSE) # will be coerced to double    -&gt; 1 0\nc(\"a\", 1) # will be coerced to character -&gt; \"a\" \"1\"\nc(TRUE, 1L) # will be coerced to integer   -&gt; 1 1\n\nQ3: Why is 1 == \"1\" true? Why is -1 &lt; FALSE true? Why is \"one\" &lt; 2 false?\nA: These comparisons are carried out by operator-functions (==, &lt;), which coerce their arguments to a common type. In the examples above, these types will be character, double and character: 1 will be coerced to \"1\", FALSE is represented as 0 and 2 turns into \"2\" (and numbers precede letters in lexicographic order (may depend on locale)).\nQ4: Why is the default missing value, NA, a logical vector? What’s special about logical vectors? (Hint: think about c(FALSE, NA_character_).)\nA: The presence of missing values shouldn’t affect the type of an object. Recall that there is a type-hierarchy for coercion from character → double → integer → logical. When combining NAs with other atomic types, the NAs will be coerced to integer (NA_integer_), double (NA_real_) or character (NA_character_) and not the other way round. If NA were a character and added to a set of other values all of these would be coerced to character as well.\nQ5: Precisely what do is.atomic(), is.numeric(), and is.vector() test for?\nA: The documentation states that:\n\nis.atomic() tests if an object is an atomic vector (as defined in Advanced R) or is NULL (!).\nis.numeric() tests if an object has type integer or double and is not of class factor, Date, POSIXt or difftime.\nis.vector() tests if an object is a vector (as defined in Advanced R) or an expression and has no attributes, apart from names.\n\nAtomic vectors are defined in Advanced R as objects of type logical, integer, double, complex, character or raw. Vectors are defined as atomic vectors or lists."
  },
  {
    "objectID": "03_Vectors.html#attributes",
    "href": "03_Vectors.html#attributes",
    "title": "3 - Vectors",
    "section": "Attributes",
    "text": "Attributes\nQ1: How is setNames() implemented? How is unname() implemented? Read the source code.\nA: setNames() is implemented as:\n\nsetNames &lt;- function(object = nm, nm) {\n  names(object) &lt;- nm\n  object\n}\n\nBecause the data argument comes first, setNames() also works well with the magrittr-pipe operator. When no first argument is given, the result is a named vector (this is rather untypical as required arguments usually come first):\n\nsetNames(, c(\"a\", \"b\", \"c\"))\n#&gt;   a   b   c \n#&gt; \"a\" \"b\" \"c\"\n\nunname() is implemented in the following way:\n\nunname &lt;- function(obj, force = FALSE) {\n  if (!is.null(names(obj))) {\n    names(obj) &lt;- NULL\n  }\n  if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) {\n    dimnames(obj) &lt;- NULL\n  }\n  obj\n}\n\nunname() removes existing names (or dimnames) by setting them to NULL.\nQ2: What does dim() return when applied to a 1-dimensional vector? When might you use NROW() or NCOL()?\nA: From ?nrow:\n\ndim() will return NULL when applied to a 1d vector.\n\nOne may want to use NROW() or NCOL() to handle atomic vectors, lists and NULL values in the same way as one column matrices or data frames. For these objects nrow() and ncol() return NULL:\n\nx &lt;- 1:10\n\n# Return NULL\nnrow(x)\n#&gt; NULL\nncol(x)\n#&gt; NULL\n\n# Pretend it's a column vector\nNROW(x)\n#&gt; [1] 10\nNCOL(x)\n#&gt; [1] 1\n\nQ3: How would you describe the following three objects? What makes them different to 1:5?\n\nx1 &lt;- array(1:5, c(1, 1, 5)) # 1 row,  1 column,  5 in third dim.\nx2 &lt;- array(1:5, c(1, 5, 1)) # 1 row,  5 columns, 1 in third dim.\nx3 &lt;- array(1:5, c(5, 1, 1)) # 5 rows, 1 column,  1 in third dim.\n\nA: These are all “one dimensional”. If you imagine a 3d cube, x1 is in the x-dimension, x2 is in the y-dimension, and x3 is in the z-dimension. In contrast to 1:5, x1, x2 and x3 have a dim attribute.\nQ4: An early draft used this code to illustrate structure():\n\nstructure(1:5, comment = \"my attribute\")\n#&gt; [1] 1 2 3 4 5\n\nBut when you print that object you don’t see the comment attribute. Why? Is the attribute missing, or is there something else special about it? (Hint: try using help.)\nA: The documentation states (see ?comment):\n\nContrary to other attributes, the comment is not printed (by print or print.default).\n\nAlso, from ?attributes:\n\nNote that some attributes (namely class, comment, dim, dimnames, names, row.names and tsp) are treated specially and have restrictions on the values which can be set.\n\nWe can retrieve comment attributes by calling them explicitly:\n\nfoo &lt;- structure(1:5, comment = \"my attribute\")\n\nattributes(foo)\n#&gt; $comment\n#&gt; [1] \"my attribute\"\nattr(foo, which = \"comment\")\n#&gt; [1] \"my attribute\""
  },
  {
    "objectID": "03_Vectors.html#s3-atomic-vectors",
    "href": "03_Vectors.html#s3-atomic-vectors",
    "title": "3 - Vectors",
    "section": "S3 atomic vectors",
    "text": "S3 atomic vectors\nQ1: What sort of object does table() return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?\nA: table() returns a contingency table of its input variables. It is implemented as an integer vector with class table and dimensions (which makes it act like an array). Its attributes are dim (dimensions) and dimnames (one name for each input column). The dimensions correspond to the number of unique values (factor levels) in each input variable.\n\nx &lt;- table(mtcars[c(\"vs\", \"cyl\", \"am\")])\n\ntypeof(x)\n#&gt; [1] \"integer\"\nattributes(x)\n#&gt; $dim\n#&gt; [1] 2 3 2\n#&gt; \n#&gt; $dimnames\n#&gt; $dimnames$vs\n#&gt; [1] \"0\" \"1\"\n#&gt; \n#&gt; $dimnames$cyl\n#&gt; [1] \"4\" \"6\" \"8\"\n#&gt; \n#&gt; $dimnames$am\n#&gt; [1] \"0\" \"1\"\n#&gt; \n#&gt; \n#&gt; $class\n#&gt; [1] \"table\"\n\n# Subset x like it's an array\nx[, , 1]\n#&gt;    cyl\n#&gt; vs   4  6  8\n#&gt;   0  0  0 12\n#&gt;   1  3  4  0\nx[, , 2]\n#&gt;    cyl\n#&gt; vs  4 6 8\n#&gt;   0 1 3 2\n#&gt;   1 7 0 0\n\nQ2: What happens to a factor when you modify its levels?\n\nf1 &lt;- factor(letters)\nlevels(f1) &lt;- rev(levels(f1))\n\nA: The underlying integer values stay the same, but the levels are changed, making it look like the data has changed.\n\nf1 &lt;- factor(letters)\nf1\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\nas.integer(f1)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#&gt; [26] 26\n\nlevels(f1) &lt;- rev(levels(f1))\nf1\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\nas.integer(f1)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#&gt; [26] 26\n\nQ3: What does this code do? How do f2 and f3 differ from f1?\n\nf2 &lt;- rev(factor(letters))\n\nf3 &lt;- factor(letters, levels = rev(letters))\n\nA: For f2 and f3 either the order of the factor elements or its levels are being reversed. For f1 both transformations are occurring.\n\n# Reverse element order\n(f2 &lt;- rev(factor(letters)))\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\nas.integer(f2)\n#&gt;  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2\n#&gt; [26]  1\n\n# Reverse factor levels (when creating factor)\n(f3 &lt;- factor(letters, levels = rev(letters)))\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\nas.integer(f3)\n#&gt;  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2\n#&gt; [26]  1"
  },
  {
    "objectID": "03_Vectors.html#lists",
    "href": "03_Vectors.html#lists",
    "title": "3 - Vectors",
    "section": "Lists",
    "text": "Lists\nQ1: List all the ways that a list differs from an atomic vector.\nA: To summarise:\n\nAtomic vectors are always homogeneous (all elements must be of the same type). Lists may be heterogeneous (the elements can be of different types) as described in the introduction of the vectors chapter.\nAtomic vectors point to one address in memory, while lists contain a separate reference for each element. (This was described in the list sections of the vectors and the names and values chapters.)\n::: {.cell layout-align=“center” hash=‘03_Vectors_cache/html/unnamed-chunk-17_0058a5e26b51d7db0318a76d78964418’}\nlobstr::ref(1:2)\n#&gt; [1:0x64f19ae18cf8] &lt;int&gt;\nlobstr::ref(list(1:2, 2))\n#&gt; █ [1:0x64f19c1af298] &lt;list&gt; \n#&gt; ├─[2:0x64f19b1df130] &lt;int&gt; \n#&gt; └─[3:0x64f19b417d30] &lt;dbl&gt;\n:::\nSubsetting with out-of-bounds and NA values leads to different output. For example, [ returns NA for atomics and NULL for lists. (This is described in more detail within the subsetting chapter.)\n::: {.cell layout-align=“center” hash=‘03_Vectors_cache/html/unnamed-chunk-18_96e783346fc71ba0391dc1e6eefae75a’}\n# Subsetting atomic vectors\n(1:2)[3]\n#&gt; [1] NA\n(1:2)[NA]\n#&gt; [1] NA NA\n\n# Subsetting lists\nas.list(1:2)[3]\n#&gt; [[1]]\n#&gt; NULL\nas.list(1:2)[NA]\n#&gt; [[1]]\n#&gt; NULL\n#&gt; \n#&gt; [[2]]\n#&gt; NULL\n:::\n\nQ2: Why do you need to use unlist() to convert a list to an atomic vector? Why doesn’t as.vector() work?\nA: A list is already a vector, though not an atomic one!\nNote that as.vector() and is.vector() use different definitions of “vector”!\n\nis.vector(as.vector(mtcars))\n#&gt; [1] TRUE\n\nQ3: Compare and contrast c() and unlist() when combining a date and date-time into a single vector.\nA: Date and date-time objects are both built upon doubles. While dates store the number of days since the reference date 1970-01-01 (also known as “the Epoch”) in days, date-time-objects (POSIXct) store the time difference to this date in seconds.\n\ndate &lt;- as.Date(\"1970-01-02\")\ndttm_ct &lt;- as.POSIXct(\"1970-01-01 01:00\", tz = \"UTC\")\n\n# Internal representations\nunclass(date)\n#&gt; [1] 1\nunclass(dttm_ct)\n#&gt; [1] 3600\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"UTC\"\n\nAs the c() generic only dispatches on its first argument, combining date and date-time objects via c() could lead to surprising results in older R versions (pre R 4.0.0):\n\n# Output in R version 3.6.2\nc(date, dttm_ct) # equal to c.Date(date, dttm_ct)\n#&gt; [1] \"1970-01-02\" \"1979-11-10\"\nc(dttm_ct, date) # equal to c.POSIXct(date, dttm_ct)\n#&gt; [1] \"1970-01-01 02:00:00 CET\" \"1970-01-01 01:00:01 CET\"\n\nIn the first statement above c.Date() is executed, which incorrectly treats the underlying double of dttm_ct (3600) as days instead of seconds. Conversely, when c.POSIXct() is called on a date, one day is counted as one second only.\nWe can highlight these mechanics by the following code:\n\n# Output in R version 3.6.2\nunclass(c(date, dttm_ct)) # internal representation\n#&gt; [1] 1 3600\ndate + 3599\n#&gt; \"1979-11-10\"\n\nAs of R 4.0.0 these issues have been resolved and both methods now convert their input first into POSIXct and Date, respectively.\n\nc(dttm_ct, date)\n#&gt; [1] \"1970-01-01 01:00:00 UTC\" \"1970-01-02 00:00:00 UTC\"\nunclass(c(dttm_ct, date))\n#&gt; [1]  3600 86400\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"UTC\"\n\nc(date, dttm_ct)\n#&gt; [1] \"1970-01-02\" \"1970-01-01\"\nunclass(c(date, dttm_ct))\n#&gt; [1] 1 0\n\nHowever, as c() strips the time zone (and other attributes) of POSIXct objects, some caution is still recommended.\n\n(dttm_ct &lt;- as.POSIXct(\"1970-01-01 01:00\", tz = \"HST\"))\n#&gt; [1] \"1970-01-01 01:00:00 HST\"\nattributes(c(dttm_ct))\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"HST\"\n\nA package that deals with these kinds of problems in more depth and provides a structural solution for them is the {vctrs} package (Wickham, Henry, and Vaughan 2020) which is also used throughout the tidyverse (Wickham et al. 2019).\nLet’s look at unlist(), which operates on list input.\n\n# Attributes are stripped\nunlist(list(date, dttm_ct))\n#&gt; [1]     1 39600\n\nWe see again that dates and date-times are internally stored as doubles. Unfortunately, this is all we are left with, when unlist strips the attributes of the list.\nTo summarise: c() coerces types and strips time zones. Errors may have occurred in older R versions because of inappropriate method dispatch/immature methods. unlist() strips attributes."
  },
  {
    "objectID": "03_Vectors.html#data-frames-and-tibbles",
    "href": "03_Vectors.html#data-frames-and-tibbles",
    "title": "3 - Vectors",
    "section": "Data frames and tibbles",
    "text": "Data frames and tibbles\nQ1: Can you have a data frame with zero rows? What about zero columns?\nA: Yes, you can create these data frames easily; either during creation or via subsetting. Even both dimensions can be zero.\nCreate a 0-row, 0-column, or an empty data frame directly:\n\ndata.frame(a = integer(), b = logical())\n#&gt; [1] a b\n#&gt; &lt;0 rows&gt; (or 0-length row.names)\n\ndata.frame(row.names = 1:3) # or data.frame()[1:3, ]\n#&gt; data frame with 0 columns and 3 rows\n\ndata.frame()\n#&gt; data frame with 0 columns and 0 rows\n\nCreate similar data frames via subsetting the respective dimension with either 0, NULL, FALSE or a valid 0-length atomic (logical(0), character(0), integer(0), double(0)). Negative integer sequences would also work. The following example uses a zero:\n\nmtcars[0, ]\n#&gt;  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb\n#&gt; &lt;0 rows&gt; (or 0-length row.names)\n\nmtcars[, 0] # or mtcars[0]\n#&gt; data frame with 0 columns and 32 rows\n\nmtcars[0, 0]\n#&gt; data frame with 0 columns and 0 rows\n\nQ2: What happens if you attempt to set rownames that are not unique?\nA: Matrices can have duplicated row names, so this does not cause problems.\nData frames, however, require unique rownames and you get different results depending on how you attempt to set them. If you set them directly or via row.names(), you get an error:\n\ndata.frame(row.names = c(\"x\", \"y\", \"y\"))\n#&gt; Error in data.frame(row.names = c(\"x\", \"y\", \"y\")): duplicate row.names: y\n\ndf &lt;- data.frame(x = 1:3)\nrow.names(df) &lt;- c(\"x\", \"y\", \"y\")\n#&gt; Warning: non-unique value when setting 'row.names': 'y'\n#&gt; Error in `.rowNamesDF&lt;-`(x, value = value): duplicate 'row.names' are not allowed\n\nIf you use subsetting, [ automatically deduplicates:\n\nrow.names(df) &lt;- c(\"x\", \"y\", \"z\")\ndf[c(1, 1, 1), , drop = FALSE]\n#&gt;     x\n#&gt; x   1\n#&gt; x.1 1\n#&gt; x.2 1\n\nQ3: If df is a data frame, what can you say about t(df), and t(t(df))? Perform some experiments, making sure to try different column types.\nA: Both of t(df) and t(t(df)) will return matrices:\n\ndf &lt;- data.frame(x = 1:3, y = letters[1:3])\nis.matrix(df)\n#&gt; [1] FALSE\nis.matrix(t(df))\n#&gt; [1] TRUE\nis.matrix(t(t(df)))\n#&gt; [1] TRUE\n\nThe dimensions will respect the typical transposition rules:\n\ndim(df)\n#&gt; [1] 3 2\ndim(t(df))\n#&gt; [1] 2 3\ndim(t(t(df)))\n#&gt; [1] 3 2\n\nBecause the output is a matrix, every column is coerced to the same type. (It is implemented within t.data.frame() via as.matrix() which is described below).\n\ndf\n#&gt;   x y\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\nt(df)\n#&gt;   [,1] [,2] [,3]\n#&gt; x \"1\"  \"2\"  \"3\" \n#&gt; y \"a\"  \"b\"  \"c\"\n\nQ4: What does as.matrix() do when applied to a data frame with columns of different types? How does it differ from data.matrix()?\nA: The type of the result of as.matrix depends on the types of the input columns (see ?as.matrix):\n\nThe method for data frames will return a character matrix if there is only atomic columns and any non-(numeric/logical/complex) column, applying as.vector to factors and format to other non-character columns. Otherwise the usual coercion hierarchy (logical &lt; integer &lt; double &lt; complex) will be used, e.g. all-logical data frames will be coerced to a logical matrix, mixed logical-integer will give an integer matrix, etc.\n\nOn the other hand, data.matrix will always return a numeric matrix (see ?data.matrix()).\n\nReturn the matrix obtained by converting all the variables in a data frame to numeric mode and then binding them together as the columns of a matrix. Factors and ordered factors are replaced by their internal codes. […] Character columns are first converted to factors and then to integers.\n\nWe can illustrate and compare the mechanics of these functions using a concrete example. as.matrix() makes it possible to retrieve most of the original information from the data frame but leaves us with characters. To retrieve all information from data.matrix()’s output, we would need a lookup table for each column.\n\ndf_coltypes &lt;- data.frame(\n  a = c(\"a\", \"b\"),\n  b = c(TRUE, FALSE),\n  c = c(1L, 0L),\n  d = c(1.5, 2),\n  e = factor(c(\"f1\", \"f2\"))\n)\n\nas.matrix(df_coltypes)\n#&gt;      a   b       c   d     e   \n#&gt; [1,] \"a\" \"TRUE\"  \"1\" \"1.5\" \"f1\"\n#&gt; [2,] \"b\" \"FALSE\" \"0\" \"2.0\" \"f2\"\ndata.matrix(df_coltypes)\n#&gt;      a b c   d e\n#&gt; [1,] 1 1 1 1.5 1\n#&gt; [2,] 2 0 0 2.0 2"
  },
  {
    "objectID": "03_Vectors.html#references",
    "href": "03_Vectors.html#references",
    "title": "3 - Vectors",
    "section": "References",
    "text": "References\n\n\n\n\nWickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D’Agostino McGowan, Romain François, Garrett Grolemund, et al. 2019. “Welcome to the tidyverse.” Journal of Open Source Software 4 (43): 1686. https://doi.org/10.21105/joss.01686.\n\n\nWickham, Hadley, Lionel Henry, and Davis Vaughan. 2020. Vctrs: Vector Helpers. https://github.com/r-lib/vctrs."
  },
  {
    "objectID": "04_Subsetting.html#selecting-multiple-elements",
    "href": "04_Subsetting.html#selecting-multiple-elements",
    "title": "4 - Subsetting",
    "section": "Selecting multiple elements",
    "text": "Selecting multiple elements\nQ1: Fix each of the following common data frame subsetting errors:\n\nmtcars[mtcars$cyl = 4, ]\n# use `==`              (instead of `=`)\n\nmtcars[-1:4, ]\n# use `-(1:4)`          (instead of `-1:4`)\n\nmtcars[mtcars$cyl &lt;= 5]\n# `,` is missing\n\nmtcars[mtcars$cyl == 4 | 6, ]\n# use `mtcars$cyl == 6` (instead of `6`)\n#  or `%in% c(4, 6)`    (instead of `== 4 | 6`)\n\nQ2: Why does the following code yield five missing values? (Hint: why is it different from x[NA_real_]?)\n\nx &lt;- 1:5\nx[NA]\n#&gt; [1] NA NA NA NA NA\n\nA: In contrast to NA_real, NA has logical type and logical vectors are recycled to the same length as the vector being subset, i.e. x[NA] is recycled to x[c(NA, NA, NA, NA, NA)].\nQ3: What does upper.tri() return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?\n\nx &lt;- outer(1:5, 1:5, FUN = \"*\")\nx[upper.tri(x)]\n\nA: upper.tri(x) returns a logical matrix, which contains TRUE values above the diagonal and FALSE values everywhere else. In upper.tri() the positions for TRUE and FALSE values are determined by comparing x’s row and column indices via .row(dim(x)) &lt; .col(dim(x)).\n\nx\n#&gt;      [,1] [,2] [,3] [,4] [,5]\n#&gt; [1,]    1    2    3    4    5\n#&gt; [2,]    2    4    6    8   10\n#&gt; [3,]    3    6    9   12   15\n#&gt; [4,]    4    8   12   16   20\n#&gt; [5,]    5   10   15   20   25\nupper.tri(x)\n#&gt;       [,1]  [,2]  [,3]  [,4]  [,5]\n#&gt; [1,] FALSE  TRUE  TRUE  TRUE  TRUE\n#&gt; [2,] FALSE FALSE  TRUE  TRUE  TRUE\n#&gt; [3,] FALSE FALSE FALSE  TRUE  TRUE\n#&gt; [4,] FALSE FALSE FALSE FALSE  TRUE\n#&gt; [5,] FALSE FALSE FALSE FALSE FALSE\n\nWhen subsetting with logical matrices, all elements that correspond to TRUE will be selected. Matrices extend vectors with a dimension attribute, so the vector forms of subsetting can be used (including logical subsetting). We should take care, that the dimensions of the subsetting matrix match the object of interest — otherwise unintended selections due to vector recycling may occur. Please also note, that this form of subsetting returns a vector instead of a matrix, as the subsetting alters the dimensions of the object.\n\nx[upper.tri(x)]\n#&gt;  [1]  2  3  6  4  8 12  5 10 15 20\n\nQ4: Why does mtcars[1:20] return an error? How does it differ from the similar mtcars[1:20, ]?\nA: When subsetting a data frame with a single vector, it behaves the same way as subsetting a list of columns. So, mtcars[1:20] would return a data frame containing the first 20 columns of the dataset. However, as mtcars has only 11 columns, the index will be out of bounds and an error is thrown. mtcars[1:20, ] is subsetted with two vectors, so 2d subsetting kicks in, and the first index refers to rows.\nQ5: Implement your own function that extracts the diagonal entries from a matrix (it should behave like diag(x) where x is a matrix).\nA: The elements in the diagonal of a matrix have the same row- and column indices. This characteristic can be used to create a suitable numeric matrix used for subsetting.\n\ndiag2 &lt;- function(x) {\n  n &lt;- min(nrow(x), ncol(x))\n  idx &lt;- cbind(seq_len(n), seq_len(n))\n\n  x[idx]\n}\n\n# Let's check if it works\n(x &lt;- matrix(1:30, 5))\n#&gt;      [,1] [,2] [,3] [,4] [,5] [,6]\n#&gt; [1,]    1    6   11   16   21   26\n#&gt; [2,]    2    7   12   17   22   27\n#&gt; [3,]    3    8   13   18   23   28\n#&gt; [4,]    4    9   14   19   24   29\n#&gt; [5,]    5   10   15   20   25   30\n\ndiag(x)\n#&gt; [1]  1  7 13 19 25\ndiag2(x)\n#&gt; [1]  1  7 13 19 25\n\nQ6: What does df[is.na(df)] &lt;- 0 do? How does it work?\nA: This expression replaces the NAs in df with 0. Here is.na(df) returns a logical matrix that encodes the position of the missing values in df. Subsetting and assignment are then combined to replace only the missing values."
  },
  {
    "objectID": "04_Subsetting.html#selecting-a-single-element",
    "href": "04_Subsetting.html#selecting-a-single-element",
    "title": "4 - Subsetting",
    "section": "Selecting a single element",
    "text": "Selecting a single element\nQ1: Brainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.\nA: Base R already provides an abundance of possibilities:\n\n# Select column first\nmtcars$cyl[[3]]\n#&gt; [1] 4\nmtcars[ , \"cyl\"][[3]]\n#&gt; [1] 4\nmtcars[[\"cyl\"]][[3]]\n#&gt; [1] 4\nwith(mtcars, cyl[[3]])\n#&gt; [1] 4\n\n# Select row first\nmtcars[3, ]$cyl\n#&gt; [1] 4\nmtcars[3, \"cyl\"]\n#&gt; [1] 4\nmtcars[3, ][ , \"cyl\"]\n#&gt; [1] 4\nmtcars[3, ][[\"cyl\"]]\n#&gt; [1] 4\n\n# Select simultaneously\nmtcars[3, 2]\n#&gt; [1] 4\nmtcars[[c(2, 3)]]\n#&gt; [1] 4\n\nQ2: Given a linear model, e.g. mod &lt;- lm(mpg ~ wt, data = mtcars), extract the residual degrees of freedom. Extract the R squared from the model summary (summary(mod)).\nA: mod is of type list, which opens up several possibilities. We use $ or [[ to extract a single element:\n\nmod &lt;- lm(mpg ~ wt, data = mtcars)\n\nmod$df.residual\n#&gt; [1] 30\nmod[[\"df.residual\"]]\n#&gt; [1] 30\n\nThe same also applies to summary(mod), so we could use, e.g.:\n\nsummary(mod)$r.squared\n#&gt; [1] 0.753\n\n(Tip: The {broom} package (Robinson, Hayes, and Couch 2020) provides a very useful approach to work with models in a tidy way.)"
  },
  {
    "objectID": "04_Subsetting.html#applications",
    "href": "04_Subsetting.html#applications",
    "title": "4 - Subsetting",
    "section": "Applications",
    "text": "Applications\nQ1: How would you randomly permute the columns of a data frame? (This is an important technique in random forests.) Can you simultaneously permute the rows and columns in one step?\nA: This can be achieved by combining [ and sample():\n\n# Permute columns\nmtcars[sample(ncol(mtcars))]\n\n# Permute columns and rows in one step\nmtcars[sample(nrow(mtcars)), sample(ncol(mtcars))]\n\nQ2: How would you select a random sample of m rows from a data frame? What if the sample had to be contiguous (i.e. with an initial row, a final row, and every row in between)?\nA: Selecting m random rows from a data frame can be achieved through subsetting.\n\nm &lt;- 10\nmtcars[sample(nrow(mtcars), m), ]\n\nHolding successive lines together as a blocked sample requires only a certain amount of caution in order to obtain the correct start and end index.\n\nstart &lt;- sample(nrow(mtcars) - m + 1, 1)\nend &lt;- start + m - 1\nmtcars[start:end, , drop = FALSE]\n\nQ3: How could you put the columns in a data frame in alphabetical order?\nA: We combine [ with order() or sort():\n\nmtcars[order(names(mtcars))]\nmtcars[sort(names(mtcars))]"
  },
  {
    "objectID": "04_Subsetting.html#references",
    "href": "04_Subsetting.html#references",
    "title": "4 - Subsetting",
    "section": "References",
    "text": "References\n\n\n\n\nRobinson, David, Alex Hayes, and Simon Couch. 2020. Broom: Convert Statistical Objects into Tidy Tibbles. https://github.com/tidymodels/broom."
  },
  {
    "objectID": "05_Control_flow.html#choices",
    "href": "05_Control_flow.html#choices",
    "title": "5 - Control flow",
    "section": "Choices",
    "text": "Choices\nQ1: What type of vector does each of the following calls to ifelse() return?\n\nifelse(TRUE, 1, \"no\")\nifelse(FALSE, 1, \"no\")\nifelse(NA, 1, \"no\")\n\nRead the documentation and write down the rules in your own words.\nA: The arguments of ifelse() are named test, yes and no. In general, ifelse() returns the entry for yes when test is TRUE, the entry for no when test is FALSE and NA when test is NA. Therefore, the expressions above return vectors of type double (1), character (\"no\") and logical (NA).\nTo be a little more precise, we will cite the part of the documentation on the return value of ifelse():\n\nA vector of the same length and attributes (including dimensions and “class”) as test and data values from the values of yes or no. The mode of the answer will be coerced from logical to accommodate first any values taken from yes and then any values taken from no.\n\nThis is surprising because it uses the type of test. In practice this means, that test is first converted to logical and if the result is neither TRUE nor FALSE, simply as.logical(test) is returned.\n\nifelse(logical(), 1, \"no\")\n#&gt; logical(0)\nifelse(NaN, 1, \"no\")\n#&gt; [1] NA\nifelse(NA_character_, 1, \"no\")\n#&gt; [1] NA\nifelse(\"a\", 1, \"no\")\n#&gt; [1] NA\nifelse(\"true\", 1, \"no\")\n#&gt; [1] 1\n\nQ2: Why does the following code work?\n\nx &lt;- 1:10\nif (length(x)) \"not empty\" else \"empty\"\n#&gt; [1] \"not empty\"\n\nx &lt;- numeric()\nif (length(x)) \"not empty\" else \"empty\"\n#&gt; [1] \"empty\"\n\nA: if() expects a logical condition, but also accepts a numeric vector where 0 is treated as FALSE and all other numbers are treated as TRUE. Numerical missing values (including NaN) lead to an error in the same way that a logical missing, NA, does."
  },
  {
    "objectID": "05_Control_flow.html#loops",
    "href": "05_Control_flow.html#loops",
    "title": "5 - Control flow",
    "section": "Loops",
    "text": "Loops\nQ1: Why does this code succeed without errors or warnings?\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\nfor (i in 1:length(x)) {\n  out[i] &lt;- x[i]^2\n}\nout\n\nA: This loop is a delicate issue, and we have to consider a few points to explain why it is evaluated without raising any errors or warnings.\nThe beginning of this code smell is the statement 1:length(x) which creates the index of the for loop. As x has length 0 1:length(x) counts down from 1 to 0. This issue is typically avoided via usage of seq_along(x) or similar helpers which would just generate integer(0) in this case.\nAs we use [&lt;- and [ for indexing 0-length vectors at their first and zeroth position, we need to be aware of their subsetting behaviour for out-of-bounds and zero indices.\nDuring the first iteration x[1] will generate an NA (out-of-bounds indexing for atomics). The resulting NA (from squaring) will be assigned to the empty length-1 list out[1] (out-of-bounds indexing for lists).\nIn the next iteration, x[0] will return numeric(0) (zero indexing for atomics). Again, squaring doesn’t change the value and numeric(0) is assigned to out[0] (zero indexing for lists). Assigning a 0-length vector to a 0-length subset works but doesn’t change the object.\nOverall, the code works, because each step includes valid R operations (even though the result may not be what the user intended).\nQ2: When the following code is evaluated, what can you say about the vector being iterated?\n\nxs &lt;- c(1, 2, 3)\nfor (x in xs) {\n  xs &lt;- c(xs, x * 2)\n}\nxs\n#&gt; [1] 1 2 3 2 4 6\n\nA: In this loop x takes on the values of the initial xs (1, 2 and 3), indicating that it is evaluated just once in the beginning of the loop, not after each iteration. (Otherwise, we would run into an infinite loop.)\nQ3: What does the following code tell you about when the index is updated?\n\nfor (i in 1:3) {\n  i &lt;- i * 2\n  print(i)\n}\n#&gt; [1] 2\n#&gt; [1] 4\n#&gt; [1] 6\n\nA: In a for loop the index is updated in the beginning of each iteration. Therefore, reassigning the index symbol during one iteration doesn’t affect the following iterations. (Again, we would otherwise run into an infinite loop.)"
  },
  {
    "objectID": "06_Functions.html#function-fundamentals",
    "href": "06_Functions.html#function-fundamentals",
    "title": "6 - Functions",
    "section": "Function fundamentals",
    "text": "Function fundamentals\nQ1: Given a name, like \"mean\", match.fun() lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R?\nA: In R there is no one-to-one mapping between functions and names. A name always points to a single object, but an object may have zero, one or many names.\nLet’s look at an example:\n\nfunction(x) sd(x) / mean(x)\n#&gt; function(x) sd(x) / mean(x)\n\nf1 &lt;- function(x) (x - min(x)) / (max(x) - min(x))\nf2 &lt;- f1\nf3 &lt;- f1\n\nWhile the function in the first line is not bound to a name multiple names (f1, f2 and f3) point to the second function. So, the main point is that the relation between name and object is only clearly defined in one direction.\nBesides that, there are obviously ways to search for function names. However, to be sure to find the right one(s), you should not only compare the code (body) but also the arguments (formals) and the creation environment. As formals(), body() and environment() all return NULL for primitive functions, the easiest way to check if two functions are exactly equal is just to use identical().\nQ2: It’s possible (although typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why?\n\nfunction(x) 3()\n#&gt; function(x) 3()\n(function(x) 3)()\n#&gt; [1] 3\n\nA: The second approach is correct.\nThe anonymous function function(x) 3 is surrounded by a pair of parentheses before it is called by (). These extra parentheses separate the function call from the anonymous function’s body. Without them a function with the invalid body 3() is returned, which throws an error when we call it. This is easier to see if we name the function:\n\nf &lt;- function(x) 3()\nf\n#&gt; function(x) 3()\nf()\n#&gt; Error in f(): attempt to apply non-function\n\nQ3: A good rule of thumb is that an anonymous function should fit on one line and shouldn’t need to use {}. Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function?\nA: The use of anonymous functions allows concise and elegant code in certain situations. However, they miss a descriptive name and when re-reading the code, it can take a while to figure out what they do. That’s why it’s helpful to give long and complex functions a descriptive name. It may be worthwhile to take a look at your own projects or other people’s code to reflect on this part of your coding style.\nQ4: What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?\nA: Use is.function() to test if an object is a function. Consider using is.primitive() to test specifically for primitive functions.\nQ5: This code makes a list of all functions in the {base} package.\n\nobjs &lt;- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns &lt;- Filter(is.function, objs)\n\nUse it to answer the following questions:\n\nWhich base function has the most arguments?\nHow many base functions have no arguments? What’s special about those functions?\nHow could you adapt the code to find all primitive functions?\n\nA: Let’s look at each sub-question separately:\n\nTo find the function with the most arguments, we first compute the length of formals().\n::: {.cell layout-align=“center” hash=‘06_Functions_cache/html/unnamed-chunk-6_6267cff5cf01cfe02ecd151e21d5a5fa’}\nlibrary(purrr)\n\nn_args &lt;- funs %&gt;%\n  map(formals) %&gt;%\n  map_int(length)\n:::\nThen we sort n_args in decreasing order and look at its first entries.\n::: {.cell layout-align=“center” hash=‘06_Functions_cache/html/unnamed-chunk-7_e2ebb773e25ecb466480bc13c7da9a54’}\nn_args %&gt;%\n  sort(decreasing = TRUE) %&gt;%\n  head()\n#&gt; scan format.default source\n#&gt; 22 16 16\n#&gt; formatC library merge.data.frame\n#&gt; 15 13 13\n:::\nWe can further use n_args to find the number of functions with no arguments:\n::: {.cell layout-align=“center” hash=‘06_Functions_cache/html/unnamed-chunk-8_c75252d5453caf2a84875fac9332cabc’}\nsum(n_args == 0)\n#&gt; [1] 253\n:::\nHowever, this over counts because formals() returns NULL for primitive functions, and length(NULL) is 0. To fix this, we can first remove the primitive functions:\n::: {.cell layout-align=“center” hash=‘06_Functions_cache/html/unnamed-chunk-9_26e9cc7827d73a0a237f756700c9bf1e’}\nn_args2 &lt;- funs %&gt;%\n  discard(is.primitive) %&gt;%\n  map(formals) %&gt;%\n  map_int(length)\n\nsum(n_args2 == 0)\n#&gt; [1] 48\n:::\nIndeed, most of the functions with no arguments are actually primitive functions.\nTo find all primitive functions, we can change the predicate in Filter() from is.function() to is.primitive():\n::: {.cell layout-align=“center” hash=‘06_Functions_cache/html/unnamed-chunk-10_ff0eddde09f29f9d6acb9dcb81dfbef0’}\nfuns &lt;- Filter(is.primitive, objs)\nlength(funs)\n#&gt; [1] 205\n:::\n\nQ6: What are the three important components of a function?\nA: These components are the function’s body(), formals() and environment(). However, as mentioned in Advanced R:\n\nThere is one exception to the rule that functions have three components. Primitive functions, like sum(), call C code directly with .Primitive() and contain no R code. Therefore, their formals(), body(), and environment() are all NULL.\n\nQ7: When does printing a function not show what environment it was created in?\nA: Primitive functions and functions created in the global environment do not print their environment."
  },
  {
    "objectID": "06_Functions.html#lexical-scoping",
    "href": "06_Functions.html#lexical-scoping",
    "title": "6 - Functions",
    "section": "Lexical scoping",
    "text": "Lexical scoping\nQ1: What does the following code return? Why? Describe how each of the three c’s is interpreted.\n\nc &lt;- 10\nc(c = c)\n\nA: This code returns a named numeric vector of length one — with one element of the value 10 and the name \"c\". The first c represents the c() function, the second c is interpreted as a (quoted) name and the third c as a value.\nQ2: What are the four principles that govern how R looks for values?\nA: R’s lexical scoping rules are based on these four principles:\n\nName masking\nFunctions vs. variables\nA fresh start\nDynamic lookup\n\nQ3: What does the following function return? Make a prediction before running the code yourself.\n\nf &lt;- function(x) {\n  f &lt;- function(x) {\n    f &lt;- function() {\n      x^2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)\n\nA: Within this nested function two more functions also named f are defined and called. Because the functions are each executed in their own environment R will look up and use the functions defined last in these environments. The innermost f() is called last, though it is the first function to return a value. Therefore, the order of the calculation passes “from the inside to the outside” and the function returns ((10 ^ 2) + 1) * 2, i.e. 202."
  },
  {
    "objectID": "06_Functions.html#lazy-evaluation",
    "href": "06_Functions.html#lazy-evaluation",
    "title": "6 - Functions",
    "section": "Lazy evaluation",
    "text": "Lazy evaluation\nQ1: What important property of && makes x_ok() work?\n\nx_ok &lt;- function(x) {\n  !is.null(x) && length(x) == 1 && x &gt; 0\n}\n\nx_ok(NULL)\n#&gt; [1] FALSE\nx_ok(1)\n#&gt; [1] TRUE\nx_ok(1:3)\n#&gt; [1] FALSE\n\nWhat is different with this code? Why is this behaviour undesirable here?\n\nx_ok &lt;- function(x) {\n  !is.null(x) & length(x) == 1 & x &gt; 0\n}\n\nx_ok(NULL)\n#&gt; logical(0)\nx_ok(1)\n#&gt; [1] TRUE\nx_ok(1:3)\n#&gt; [1] FALSE FALSE FALSE\n\nA: In summary: && short-circuits which means that if the left-hand side is FALSE it doesn’t evaluate the right-hand side (because it doesn’t matter). Similarly, if the left-hand side of || is TRUE it doesn’t evaluate the right-hand side.\nWe expect x_ok() to validate its input via certain criteria: it must not be NULL, have length 1 and be greater than 0. Meaningful outcomes for this assertion will be TRUE, FALSE or NA. The desired behaviour is reached by combining the assertions through && instead of &.\n&& does not perform elementwise comparisons; instead it uses the first element of each value only. It also uses lazy evaluation, in the sense that evaluation “proceeds only until the result is determined” (from ?Logic). This means that the RHS of && won’t be evaluated if the LHS already determines the outcome of the comparison (e.g. evaluate to FALSE). This behaviour is also known as “short-circuiting”. For some situations (x = 1) both operators will lead to the same result. But this is not always the case. For x = NULL, the &&-operator will stop after the !is.null statement and return the result. The following conditions won’t even be evaluated! (If the other conditions are also evaluated (by the use of &), the outcome would change. NULL &gt; 0 returns logical(0), which is not helpful in this case.)\nWe can also see the difference in behaviour, when we set x = 1:3. The &&-operator returns the result from length(x) == 1, which is FALSE. Using & as the logical operator leads to the (vectorised) x &gt; 0 condition being evaluated and also returned.\nQ2: What does this function return? Why? Which principle does it illustrate?\n\nf2 &lt;- function(x = z) {\n  z &lt;- 100\n  x\n}\nf2()\n\nA: The function returns 100. The default argument (x = z) gets lazily evaluated within the function environment when x gets accessed. At this time z has already been bound to the value 100. The illustrated principle here is lazy evaluation.\nQ3: What does this function return? Why? Which principle does it illustrate?\n\ny &lt;- 10\nf1 &lt;- function(x = {\n                 y &lt;- 1\n                 2\n               }, y = 0) {\n  c(x, y)\n}\nf1()\ny\n\nA: The function returns c(2, 1) which is due to name masking. When x is accessed within c(), the promise x = {y &lt;- 1; 2} is evaluated inside f1()’s environment. y gets bound to the value 1 and the return value of {() (2) gets assigned to x. When y gets accessed next within c(), it has already the value 1 and R doesn’t need to look it up any further. Therefore, the promise y = 0 won’t be evaluated. Also, as y is assigned within f1()’s environment, the value of the global variable y is left untouched.\nQ4: In hist(), the default value of xlim is range(breaks), the default value for breaks is \"Sturges\", and\n\nrange(\"Sturges\")\n#&gt; [1] \"Sturges\" \"Sturges\"\n\nExplain how hist() works to get a correct xlim value.\nA: The xlim argument of hist() defines the range of the histogram’s x-axis. In order to provide a valid axis xlim must contain a numeric vector of exactly two unique values. Consequently, for the default xlim = range(breaks)), breaks must evaluate to a vector with at least two unique values.\nDuring execution hist() overwrites the breaks argument. The breaks argument is quite flexible and allows the users to provide the breakpoints directly or compute them in several ways. Therefore, the specific behaviour depends highly on the input. But hist ensures that breaks evaluates to a numeric vector containing at least two unique elements before xlim is computed.\nQ5: Explain why this function works. Why is it confusing?\n\nshow_time &lt;- function(x = stop(\"Error!\")) {\n  stop &lt;- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n#&gt; [1] \"2024-01-24 11:45:19 EST\"\n\nA: Before show_time() accesses x (default stop(\"Error\")), the stop() function is masked by function(...) Sys.time(). As default arguments are evaluated in the function environment, print(x) will be evaluated as print(Sys.time()).\nThis function is confusing because its behaviour changes when x’s value is supplied directly. Now the value from the calling environment will be used and the overwriting of stop() won’t affect x anymore.\n\nshow_time(x = stop(\"Error!\"))\n#&gt; Error in print(x): Error!\n\nQ6: How many arguments are required when calling library()?\nA: library() doesn’t require any arguments. When called without arguments library() invisibly returns a list of class libraryIQR, which contains a results matrix with one row and three columns per installed package. These columns contain entries for the name of the package (“Package”), the path to the package (“LibPath”) and the title of the package (“Title”). library() also has its own print method (print.libraryIQR()), which displays this information conveniently in its own window.\nThis behaviour is also documented under the details section of library()’s help page (?library):\n\nIf library is called with no package or help argument, it lists all available packages in the libraries specified by lib.loc, and returns the corresponding information in an object of class “libraryIQR”. (The structure of this class may change in future versions.) Use .packages(all = TRUE) to obtain just the names of all available packages, and installed.packages() for even more information.\n\nBecause the package and help argument from library() do not show a default value, it’s easy to overlook the possibility to call library() without these arguments. (Instead of providing NULLs as default values library() uses missing() to check if these arguments were provided.)\n\nstr(formals(library))\n#&gt; Dotted pair list of 13\n#&gt;  $ package        : symbol \n#&gt;  $ help           : symbol \n#&gt;  $ pos            : num 2\n#&gt;  $ lib.loc        : NULL\n#&gt;  $ character.only : logi FALSE\n#&gt;  $ logical.return : logi FALSE\n#&gt;  $ warn.conflicts : symbol \n#&gt;  $ quietly        : logi FALSE\n#&gt;  $ verbose        : language getOption(\"verbose\")\n#&gt;  $ mask.ok        : symbol \n#&gt;  $ exclude        : symbol \n#&gt;  $ include.only   : symbol \n#&gt;  $ attach.required: language missing(include.only)"
  },
  {
    "objectID": "06_Functions.html#dot-dot-dot",
    "href": "06_Functions.html#dot-dot-dot",
    "title": "6 - Functions",
    "section": "... (dot-dot-dot)",
    "text": "... (dot-dot-dot)\nQ1: Explain the following results:\n\nsum(1, 2, 3)\n#&gt; [1] 6\nmean(1, 2, 3)\n#&gt; [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n#&gt; [1] 7\nmean(1, 2, 3, na.omit = TRUE)\n#&gt; [1] 1\n\nA: Let’s inspect the arguments and their order for both functions. For sum() these are ... and na.rm:\n\nstr(sum)\n#&gt; function (..., na.rm = FALSE)\n\nFor the ... argument sum() expects numeric, complex, or logical vector input (see ?sum). Unfortunately, when ... is used, misspelled arguments (!) like na.omit won’t raise an error (in case of no further input checks). So instead, na.omit is treated as a logical and becomes part of the ... argument. It will be coerced to 1 and be part of the sum. All other arguments are left unchanged. Therefore sum(1, 2, 3) returns 6 and sum(1, 2, 3, na.omit = TRUE) returns 7.\nIn contrast, the generic function mean() expects x, trim, na.rm and ... for its default method.\n\nstr(mean.default)\n#&gt; function (x, trim = 0, na.rm = FALSE, ...)\n\nAs na.omit is not one of mean()’s named arguments (x; and no candidate for partial matching), na.omit again becomes part of the ... argument. However, in contrast to sum() the elements of ... are not “part” of the mean. The other supplied arguments are matched by their order, i.e. x = 1, trim = 2 and na.rm = 3. As x is of length 1 and not NA, the settings of trim and na.rm do not affect the calculation of the mean. Both calls (mean(1, 2, 3) and mean(1, 2, 3, na.omit = TRUE)) return 1.\nQ2: Explain how to find the documentation for the named arguments in the following function call:\n\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")\n\n\n\n\n\n\n\n\nA: First we type ?plot in the console and check the “Usage” section which contains:\nplot(x, y, ...)\nThe arguments we want to learn more about (col, pch, xlab, col.lab) are part of the ... argument. There we can find information for the xlab argument and a recommendation to visit ?par for the other arguments. Under ?par we type “col” into the search bar, which leads us to the section “Color Specification”. We also search for the pch argument, which leads to the recommendation to check ?points. Finally, col.lab is also directly documented within ?par.\nQ3: Why does plot(1:10, col = \"red\") only colour the points, not the axes or labels? Read the source code of plot.default() to find out.\nA: To learn about the internals of plot.default() we add browser() to the first line of the code and interactively run plot(1:10, col = \"red\"). This way we can see how the plot is built and learn where the axes are added.\nThis leads us to the function call\n\nlocalTitle(main = main, sub = sub, xlab = xlab, ylab = ylab, ...)\n\nThe localTitle() function was defined in the first lines of plot.default() as:\n\nlocalTitle &lt;- function(..., col, bg, pch, cex, lty, lwd) title(...)\n\nThe call to localTitle() passes the col parameter as part of the ... argument to title(). ?title tells us that the title() function specifies four parts of the plot: Main (title of the plot), sub (sub-title of the plot) and both axis labels. Therefore, it would introduce ambiguity inside title() to use col directly. Instead, one has the option to supply col via the ... argument, via col.lab or as part of xlab in the form xlab = list(c(\"index\"), col = \"red\") (similar for ylab)."
  },
  {
    "objectID": "06_Functions.html#exiting-a-function",
    "href": "06_Functions.html#exiting-a-function",
    "title": "6 - Functions",
    "section": "Exiting a function",
    "text": "Exiting a function\nQ1: What does load() return? Why don’t you normally see these values?\nA: load() loads objects saved to disk in .Rdata files by save(). When run successfully, load() invisibly returns a character vector containing the names of the newly loaded objects. To print these names to the console, one can set the argument verbose to TRUE or surround the call in parentheses to trigger R’s auto-printing mechanism.\nQ2: What does write.table() return? What would be more useful?\nA: write.table() writes an object, usually a data frame or a matrix, to disk. The function invisibly returns NULL. It would be more useful if write.table() would (invisibly) return the input data, x. This would allow to save intermediate results and directly take on further processing steps without breaking the flow of the code (i.e. breaking it into different lines). One package which uses this pattern is the {readr} package (Wickham and Hester 2020), which is part of the tidyverse-ecosystem.\nQ3: How does the chdir parameter of source() compare to with_dir()? Why might you prefer one to the other?\nA: The with_dir() approach was given in Advanced R as:\n\nwith_dir &lt;- function(dir, code) {\n  old &lt;- setwd(dir)\n  on.exit(setwd(old))\n\n  force(code)\n}\n\nwith_dir() takes a path for a working directory (dir) as its first argument. This is the directory where the provided code (code) should be executed. Therefore, the current working directory is changed in with_dir() via setwd(). Then, on.exit() ensures that the modification of the working directory is reset to the initial value when the function exits. By passing the path explicitly, the user has full control over the directory to execute the code in.\nIn source() the code is passed via the file argument (a path to a file). The chdir argument specifies if the working directory should be changed to the directory containing the file. The default for chdir is FALSE, so you don’t have to provide a value. However, as you can only provide TRUE or FALSE, you are also less flexible in choosing the working directory for the code execution.\nQ4: Write a function that opens a graphics device, runs the supplied code, and closes the graphics device (always, regardless of whether or not the plotting code works).\nA: To control the graphics device we use pdf() and dev.off(). To ensure a clean termination on.exit() is used.\n\nplot_pdf &lt;- function(code) {\n  pdf(\"test.pdf\")\n  on.exit(dev.off(), add = TRUE)\n  code\n}\n\nQ5: We can use on.exit() to implement a simple version of capture.output().\n\ncapture.output2 &lt;- function(code) {\n  temp &lt;- tempfile()\n  on.exit(file.remove(temp), add = TRUE, after = TRUE)\n\n  sink(temp)\n  on.exit(sink(), add = TRUE, after = TRUE)\n\n  force(code)\n  readLines(temp)\n}\ncapture.output2(cat(\"a\", \"b\", \"c\", sep = \"\\n\"))\n#&gt; [1] \"a\" \"b\" \"c\"\n\nCompare capture.output() to capture.output2(). How do the functions differ? What features have I removed to make the key ideas easier to see? How have I rewritten the key ideas to be easier to understand?\nA: Using body(capture.output) we inspect the source code of the original capture.output() function: The implementation for capture.output() is quite a bit longer (39 lines vs. 7 lines).\nIn capture_output2() the code is simply forced, and the output is caught via sink() in a temporary file. An additional feature of capture_output() is that one can also capture messages by setting type = \"message\". As this is internally forwarded to sink(), this behaviour (and also sink()’s split argument) could be easily introduced within capture_output2() as well.\nThe main difference is that capture.output() calls print, i.e. compare the output of these two calls:\n\ncapture.output({\n  1\n})\n#&gt; [1] \"[1] 1\"\ncapture.output2({\n  1\n})\n#&gt; character(0)"
  },
  {
    "objectID": "06_Functions.html#function-forms",
    "href": "06_Functions.html#function-forms",
    "title": "6 - Functions",
    "section": "Function forms",
    "text": "Function forms\nQ1: Rewrite the following code snippets into prefix form:\n\n1 + 2 + 3\n\n1 + (2 + 3)\n\nif (length(x) &lt;= 5) x[[5]] else x[[n]]\n\nA: Let’s rewrite the expressions to match the exact syntax from the code above. Because prefix functions already define the execution order, we may omit the parentheses in the second expression.\n\n`+`(`+`(1, 2), 3)\n\n`+`(1, `(`(`+`(2, 3)))\n`+`(1, `+`(2, 3))\n\n`if`(`&lt;=`(length(x), 5), `[[`(x, 5), `[[`(x, n))\n\nQ2: Clarify the following list of odd function calls:\n\nx &lt;- sample(replace = TRUE, 20, x = c(1:10, NA))\ny &lt;- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)\n\nA: None of these functions provides a ... argument. Therefore, the function arguments are first matched exactly, then via partial matching and finally by position. This leads us to the following explicit function calls:\n\nx &lt;- sample(c(1:10, NA), size = 20, replace = TRUE)\ny &lt;- runif(20, min = 0, max = 1)\ncor(x, y, use = \"pairwise.complete.obs\", method = \"kendall\")\n\nQ3: Explain why the following code fails:\n\nmodify(get(\"x\"), 1) &lt;- 10\n#&gt; Error: target of assignment expands to non-language object\n\nA: First, let’s define x and recall the definition of modify() from Advanced R:\n\nx &lt;- 1:3\n\n`modify&lt;-` &lt;- function(x, position, value) {\n  x[position] &lt;- value\n  x\n}\n\nR internally transforms the code, and the transformed code reproduces the error above:\n\nget(\"x\") &lt;- `modify&lt;-`(get(\"x\"), 1, 10)\n#&gt; Error in get(\"x\") &lt;- `modify&lt;-`(get(\"x\"), 1, 10) :\n#&gt;   target of assignment expands to non-language object\n\nThe error occurs during the assignment because no corresponding replacement function, i.e. get&lt;-, exists for get(). To confirm this, we reproduce the error via the following simplified example.\n\nget(\"x\") &lt;- 2\n#&gt; Error in get(\"x\") &lt;- 2 :\n#&gt;   target of assignment expands to non-language object\n\nQ4: Create a replacement function that modifies a random location in a vector.\nA: Let’s define random&lt;- like this:\n\n`random&lt;-` &lt;- function(x, value) {\n  idx &lt;- sample(length(x), 1)\n  x[idx] &lt;- value\n  x\n}\n\nQ5: Write your own version of + that pastes its inputs together if they are character vectors but behaves as usual otherwise. In other words, make this code work:\n\n1 + 2\n#&gt; [1] 3\n\n\"a\" + \"b\"\n#&gt; [1] \"ab\"\n\nA: To achieve this behaviour, we need to override the + operator. We need to take care to not use the + operator itself inside of the function definition, as this would lead to an undesired infinite recursion. We also add b = 0L as a default value to keep the behaviour of + as a unary operator, i.e. to keep + 1 working and not throwing an error.\n\n`+` &lt;- function(a, b = 0L) {\n  if (is.character(a) && is.character(b)) {\n    paste0(a, b)\n  } else {\n    base::`+`(a, b)\n  }\n}\n\n# Test\n+1\n#&gt; [1] 1\n1 + 2\n#&gt; [1] 3\n\"a\" + \"b\"\n#&gt; [1] \"ab\"\n\n# Return back to the original `+` operator\nrm(`+`)\n\nQ6: Create a list of all the replacement functions found in the {base} package. Which ones are primitive functions? (Hint use apropos())\nA: The hint suggests to look for functions with a specific naming pattern: Replacement functions conventionally end on “&lt;-”. We can search for these objects by supplying the regular expression \"&lt;-$\" to apropos(). apropos() also allows to return the position on the search path (search()) for each of its matches via setting where = TRUE. Finally, we can set mode = function to narrow down our search to relevant objects only. This gives us the following statement to begin with:\n\nrepls &lt;- apropos(\"&lt;-\", where = TRUE, mode = \"function\")\nhead(repls, 30)\n#&gt;                     12                     12                     12 \n#&gt;        \".rowNamesDF&lt;-\"                 \"[[&lt;-\"      \"[[&lt;-.data.frame\" \n#&gt;                     12                     12                     12 \n#&gt;          \"[[&lt;-.factor\" \"[[&lt;-.numeric_version\"         \"[[&lt;-.POSIXlt\" \n#&gt;                     12                     12                     12 \n#&gt;                  \"[&lt;-\"       \"[&lt;-.data.frame\"             \"[&lt;-.Date\" \n#&gt;                     12                     12                     12 \n#&gt;         \"[&lt;-.difftime\"           \"[&lt;-.factor\"  \"[&lt;-.numeric_version\" \n#&gt;                     12                     12                     12 \n#&gt;          \"[&lt;-.POSIXct\"          \"[&lt;-.POSIXlt\"                  \"@&lt;-\" \n#&gt;                     12                     12                     12 \n#&gt;                   \"&lt;-\"                  \"&lt;&lt;-\"                  \"$&lt;-\" \n#&gt;                     12                     12                     10 \n#&gt;       \"$&lt;-.data.frame\"          \"$&lt;-.POSIXlt\"                 \"as&lt;-\" \n#&gt;                     12                     12                     10 \n#&gt;               \"attr&lt;-\"         \"attributes&lt;-\"               \"body&lt;-\" \n#&gt;                     12                     12                     10 \n#&gt;               \"body&lt;-\"              \"class&lt;-\"             \"coerce&lt;-\" \n#&gt;                     12                     12                      3 \n#&gt;           \"colnames&lt;-\"            \"comment&lt;-\"          \"contrasts&lt;-\"\n\nTo restrict repl to names of replacement functions from the {base} package, we select only matches containing the relevant position on the search path.\n\nrepls_base &lt;- repls[names(repls) == length(search())]\nrepls_base\n#&gt;                        12                        12                        12 \n#&gt;           \".rowNamesDF&lt;-\"                    \"[[&lt;-\"         \"[[&lt;-.data.frame\" \n#&gt;                        12                        12                        12 \n#&gt;             \"[[&lt;-.factor\"    \"[[&lt;-.numeric_version\"            \"[[&lt;-.POSIXlt\" \n#&gt;                        12                        12                        12 \n#&gt;                     \"[&lt;-\"          \"[&lt;-.data.frame\"                \"[&lt;-.Date\" \n#&gt;                        12                        12                        12 \n#&gt;            \"[&lt;-.difftime\"              \"[&lt;-.factor\"     \"[&lt;-.numeric_version\" \n#&gt;                        12                        12                        12 \n#&gt;             \"[&lt;-.POSIXct\"             \"[&lt;-.POSIXlt\"                     \"@&lt;-\" \n#&gt;                        12                        12                        12 \n#&gt;                      \"&lt;-\"                     \"&lt;&lt;-\"                     \"$&lt;-\" \n#&gt;                        12                        12                        12 \n#&gt;          \"$&lt;-.data.frame\"             \"$&lt;-.POSIXlt\"                  \"attr&lt;-\" \n#&gt;                        12                        12                        12 \n#&gt;            \"attributes&lt;-\"                  \"body&lt;-\"                 \"class&lt;-\" \n#&gt;                        12                        12                        12 \n#&gt;              \"colnames&lt;-\"               \"comment&lt;-\"                  \"diag&lt;-\" \n#&gt;                        12                        12                        12 \n#&gt;                   \"dim&lt;-\"              \"dimnames&lt;-\"   \"dimnames&lt;-.data.frame\" \n#&gt;                        12                        12                        12 \n#&gt;              \"Encoding&lt;-\"           \"environment&lt;-\"               \"formals&lt;-\" \n#&gt;                        12                        12                        12 \n#&gt;                 \"is.na&lt;-\"         \"is.na&lt;-.default\"          \"is.na&lt;-.factor\" \n#&gt;                        12                        12                        12 \n#&gt; \"is.na&lt;-.numeric_version\"                \"length&lt;-\"           \"length&lt;-.Date\" \n#&gt;                        12                        12                        12 \n#&gt;       \"length&lt;-.difftime\"         \"length&lt;-.factor\"        \"length&lt;-.POSIXct\" \n#&gt;                        12                        12                        12 \n#&gt;        \"length&lt;-.POSIXlt\"                \"levels&lt;-\"         \"levels&lt;-.factor\" \n#&gt;                        12                        12                        12 \n#&gt;                  \"mode&lt;-\"        \"mostattributes&lt;-\"                 \"names&lt;-\" \n#&gt;                        12                        12                        12 \n#&gt;         \"names&lt;-.POSIXlt\"              \"oldClass&lt;-\"            \"parent.env&lt;-\" \n#&gt;                        12                        12                        12 \n#&gt;            \"regmatches&lt;-\"             \"row.names&lt;-\"  \"row.names&lt;-.data.frame\" \n#&gt;                        12                        12                        12 \n#&gt;     \"row.names&lt;-.default\"              \"rownames&lt;-\"                 \"split&lt;-\" \n#&gt;                        12                        12                        12 \n#&gt;      \"split&lt;-.data.frame\"         \"split&lt;-.default\"          \"storage.mode&lt;-\" \n#&gt;                        12                        12                        12 \n#&gt;                \"substr&lt;-\"             \"substring&lt;-\"                 \"units&lt;-\" \n#&gt;                        12 \n#&gt;        \"units&lt;-.difftime\"\n\nTo find out which of these functions are primitives, we first search for these functions via mget() and then subset the result using Filter() and is.primitive().\n\nrepls_base_prim &lt;- mget(repls_base, envir = baseenv()) %&gt;%\n  Filter(is.primitive, .) %&gt;%\n  names()\n\nrepls_base_prim\n#&gt;  [1] \"[[&lt;-\"           \"[&lt;-\"            \"@&lt;-\"            \"&lt;-\"            \n#&gt;  [5] \"&lt;&lt;-\"            \"$&lt;-\"            \"attr&lt;-\"         \"attributes&lt;-\"  \n#&gt;  [9] \"class&lt;-\"        \"dim&lt;-\"          \"dimnames&lt;-\"     \"environment&lt;-\" \n#&gt; [13] \"length&lt;-\"       \"levels&lt;-\"       \"names&lt;-\"        \"oldClass&lt;-\"    \n#&gt; [17] \"storage.mode&lt;-\"\n\nOverall the {base} package contains 64 replacement functions of which 17 are primitive functions.\nQ7: What are valid names for user-created infix functions?\nA: Let’s cite from the section on function forms from Advanced R:\n\n… names of infix functions are more flexible than regular R functions: they can contain any sequence of characters except “%”.\n\nQ8: Create an infix xor() operator.\nA: We could create an infix %xor% like this:\n\n`%xor%` &lt;- function(a, b) {\n  xor(a, b)\n}\nTRUE %xor% TRUE\n#&gt; [1] FALSE\nFALSE %xor% TRUE\n#&gt; [1] TRUE\n\nQ9: Create infix versions of the set functions intersect(), union(), and setdiff(). You might call them %n%, %u%, and %/% to match conventions from mathematics.\nA: These infix operators could be defined in the following way. (%/% is chosen instead of %\\%, because \\ serves as an escape character.)\n\n`%n%` &lt;- function(a, b) {\n  intersect(a, b)\n}\n\n`%u%` &lt;- function(a, b) {\n  union(a, b)\n}\n\n`%/%` &lt;- function(a, b) {\n  setdiff(a, b)\n}\n\nx &lt;- c(\"a\", \"b\", \"d\")\ny &lt;- c(\"a\", \"c\", \"d\")\n\nx %u% y\n#&gt; [1] \"a\" \"b\" \"d\" \"c\"\nx %n% y\n#&gt; [1] \"a\" \"d\"\nx %/% y\n#&gt; [1] \"b\""
  },
  {
    "objectID": "06_Functions.html#references",
    "href": "06_Functions.html#references",
    "title": "6 - Functions",
    "section": "References",
    "text": "References\n\n\n\n\nWickham, Hadley, and Jim Hester. 2020. Readr: Read Rectangular Text Data. https://github.com/tidyverse/readr."
  },
  {
    "objectID": "07_Environments.html#prerequisites",
    "href": "07_Environments.html#prerequisites",
    "title": "7 Environments",
    "section": "Prerequisites",
    "text": "Prerequisites\nJust like in Advanced R, we mainly use the {rlang} package (Henry and Wickham 2020) to work with environments.\n\nlibrary(rlang)"
  },
  {
    "objectID": "07_Environments.html#environment-basics",
    "href": "07_Environments.html#environment-basics",
    "title": "7 Environments",
    "section": "Environment basics",
    "text": "Environment basics\nQ1: List three ways in which an environment differs from a list.\nA: The most important differences between environments and lists are:\n\nenvironments have reference semantics (i.e. they don’t copy-on-modify)\nenvironments have parents\nthe contents of an environment must have unique names\nthe contents of an environment are not ordered\n(environments can only be compared via identical(); not with ==)\n(environments can contain themselves)\n\nQ2: Create an environment as illustrated by this picture.\n\n\n\n\n\n\n\n\n\nA: Let’s create an environment that contains itself.\n\ne1 &lt;- env()\ne1$loop &lt;- e1\n\n# Print the environment\nenv_print(e1)\n#&gt; &lt;environment: 0x590c00c194d0&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • loop: &lt;env&gt;\n\n# Verify that it contains itself\nlobstr::ref(e1)\n#&gt; █ [1:0x590c00c194d0] &lt;env&gt; \n#&gt; └─loop = [1:0x590c00c194d0]\n\nQ3: Create a pair of environments as illustrated by this picture.\n\n\n\n\n\n\n\n\n\nA: These two environments contain each other:\n\ne1 &lt;- env()\ne2 &lt;- env()\n\ne1$loop &lt;- e2\ne2$dedoop &lt;- e1\n\nlobstr::ref(e1)\n#&gt; █ [1:0x590c00f0d1d8] &lt;env&gt; \n#&gt; └─loop = █ [2:0x590c00f8e0a8] &lt;env&gt; \n#&gt;          └─dedoop = [1:0x590c00f0d1d8]\nlobstr::ref(e2)\n#&gt; █ [1:0x590c00f8e0a8] &lt;env&gt; \n#&gt; └─dedoop = █ [2:0x590c00f0d1d8] &lt;env&gt; \n#&gt;            └─loop = [1:0x590c00f8e0a8]\n\nQ4: Explain why e[[1]] and e[c(\"a\", \"b\")] don’t make sense when e is an environment.\nA: The first option doesn’t make sense, because elements of an environment are not ordered. The second option would return two objects at the same time. What data structure would they be contained inside?\nQ5: Create a version of env_poke() that will only bind new names, never re-bind old names. Some programming languages only do this, and are known as single assignment languages.\nA: As described in Advanced R rlang::env_poke() takes a name (as string) and a value to assign (or reassign) a binding in an environment.\n\ne3 &lt;- new.env()\n\nenv_poke(e3, \"a\", 100)\ne3$a\n#&gt; [1] 100\nenv_poke(e3, \"a\", 200)\ne3$a\n#&gt; [1] 200\n\nSo, we want env_poke2() to test, if the supplied name is already present in the given environment. This can be checked via env_has(). If this is the case, an (informative) error is thrown.\n\nenv_poke2 &lt;- function(env, name, value) {\n  if (env_has(env, name)) {\n    abort(paste0(\"\\\"\", name, \"\\\" is already assigned to a value.\"))\n  }\n\n  env_poke(env, name, value)\n  invisible(env)\n}\n\n# Test\nenv_poke2(e3, \"b\", 100)\ne3$b\n#&gt; [1] 100\nenv_poke2(e3, \"b\", 200)\n#&gt; Error in `env_poke2()`:\n#&gt; ! \"b\" is already assigned to a value.\n\nQ6: What does this function do? How does it differ from &lt;&lt;- and why might you prefer it?\n\nrebind &lt;- function(name, value, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    stop(\"Can't find `\", name, \"`\", call. = FALSE)\n  } else if (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\nrebind(\"a\", 10)\n#&gt; Error: Can't find `a`\na &lt;- 5\nrebind(\"a\", 10)\na\n#&gt; [1] 10\n\nA: The primary difference between rebind() and &lt;&lt;- is that rebind() will only carry out an assignment when it finds an existing binding; unlike &lt;&lt;- it will never create a new one in the global environment. This behaviour of &lt;&lt;- is usually undesirable because global variables introduce non-obvious dependencies between functions."
  },
  {
    "objectID": "07_Environments.html#recursing-over-environments",
    "href": "07_Environments.html#recursing-over-environments",
    "title": "7 Environments",
    "section": "Recursing over environments",
    "text": "Recursing over environments\nQ1: Modify where() to return all environments that contain a binding for name. Carefully think through what type of object the function will need to return.\nA: where() searches (recursively) for a given name within a given environment and its ancestors. If where() finds the name in one of these environments, it returns the environment’s name. Otherwise, it throws an error.\nThe definition of where() was given in Advanced R as:\n\nwhere &lt;- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find `\", name, \"`.\", call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\n\nOur modified version of where() will always recurse until it reaches the empty environment. No matter if it has already found the name or not. Along the way, it will check each environment for the given name. Finally, it will return a list of environments where the binding was found; if no binding was found, the list will be empty.\nPlease also note how the list is initialised via the default argument, when the function is called for the first time. This is a bit confusing, which is why it’s common to wrap a recursive function inside another, more user friendly, function.\n\nwhere2 &lt;- function(name, env = caller_env(), results = list()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    results\n  } else {\n    # Recursive case\n    if (env_has(env, name)) {\n      results &lt;- c(results, env)\n    }\n    where2(name, env_parent(env), results)\n  }\n}\n\n# Test\ne1a &lt;- env(empty_env(), a = 1, b = 2)\ne1b &lt;- env(e1a, b = 10, c = 11)\ne1c &lt;- env(e1b, a = 12, d = 13)\n\nwhere2(\"a\", e1c)\n#&gt; [[1]]\n#&gt; &lt;environment: 0x590bff309938&gt;\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;environment: 0x590bff08c7a8&gt;\n\nQ2: Write a function called fget() that finds only function objects. It should have two arguments, name and env, and should obey the regular scoping rules for functions: if there’s an object with a matching name that’s not a function, look in the parent. For an added challenge, also add an inherits argument which controls whether the function recurses up the parents or only looks in one environment.\nA: We follow a similar approach to the previous exercise. This time we additionally check if the found object is a function and implement an argument to turn off the recursion, if desired.\n\nfget &lt;- function(name, env = caller_env(), inherits = TRUE) {\n  # Base case\n  if (env_has(env, name)) {\n    obj &lt;- env_get(env, name)\n\n    if (is.function(obj)) {\n      return(obj)\n    }\n  }\n\n  if (identical(env, emptyenv()) || !inherits) {\n    stop(\"Could not find a function called \\\"\", name, \"\\\".\",\n      call. = FALSE\n    )\n  }\n\n  # Recursive Case\n  fget(name, env_parent(env))\n}\n\n# Test\nmean &lt;- 10\nfget(\"mean\", inherits = TRUE)\n#&gt; function (x, ...) \n#&gt; UseMethod(\"mean\")\n#&gt; &lt;bytecode: 0x590bfe4e2010&gt;\n#&gt; &lt;environment: namespace:base&gt;"
  },
  {
    "objectID": "07_Environments.html#special-environments",
    "href": "07_Environments.html#special-environments",
    "title": "7 Environments",
    "section": "Special environments",
    "text": "Special environments\nQ1: How is search_envs() different to env_parents(global_env())?\nA: search_envs() returns all the environments on the search path, which is “a chain of environments containing exported functions of attached packages” (from ?search_envs). Every time you attach a new package, this search path will grow. The search path ends with the base-environment. The global environment is included, because functions present in the global environment will always be part of the search path.\n\nsearch_envs()\n#&gt;  [[1]] $ &lt;env: global&gt;\n#&gt;  [[2]] $ &lt;env: package:rlang&gt;\n#&gt;  [[3]] $ &lt;env: package:stats&gt;\n#&gt;  [[4]] $ &lt;env: package:graphics&gt;\n#&gt;  [[5]] $ &lt;env: package:grDevices&gt;\n#&gt;  [[6]] $ &lt;env: package:datasets&gt;\n#&gt;  [[7]] $ &lt;env: package:devtools&gt;\n#&gt;  [[8]] $ &lt;env: package:usethis&gt;\n#&gt;  [[9]] $ &lt;env: package:utils&gt;\n#&gt; [[10]] $ &lt;env: package:methods&gt;\n#&gt; [[11]] $ &lt;env: Autoloads&gt;\n#&gt; [[12]] $ &lt;env: package:base&gt;\n\nenv_parents(global_env()) will list all the ancestors of the global environment, therefore the global environment itself is not included. This also includes the “ultimate ancestor”, the empty environment. This environment is not considered part of the search path because it contains no objects.\n\nenv_parents(global_env())\n#&gt;  [[1]] $ &lt;env: package:rlang&gt;\n#&gt;  [[2]] $ &lt;env: package:stats&gt;\n#&gt;  [[3]] $ &lt;env: package:graphics&gt;\n#&gt;  [[4]] $ &lt;env: package:grDevices&gt;\n#&gt;  [[5]] $ &lt;env: package:datasets&gt;\n#&gt;  [[6]] $ &lt;env: package:devtools&gt;\n#&gt;  [[7]] $ &lt;env: package:usethis&gt;\n#&gt;  [[8]] $ &lt;env: package:utils&gt;\n#&gt;  [[9]] $ &lt;env: package:methods&gt;\n#&gt; [[10]] $ &lt;env: Autoloads&gt;\n#&gt; [[11]] $ &lt;env: package:base&gt;\n#&gt; [[12]] $ &lt;env: empty&gt;\n\nQ2: Draw a diagram that shows the enclosing environments of this function:\n\nf1 &lt;- function(x1) {\n  f2 &lt;- function(x2) {\n    f3 &lt;- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)\n\nA: This exercise urges us to think carefully about the function environment at creation time.\nWhen f1 is defined it binds its parent environment, which is the global environment. But f2 will only be created at runtime of f1 and will therefore bind f1’s execution environment. The value 1 will also bind to the name x1 at execution time. The same holds true for x2, f3 and x3.\nThe following diagram visualises the relations between the function environments.\n\n\n\n\n\n\n\n\n\nWe can also inspect the binding of the environments, adding print statements to the function definition. Please note that these print statements will be evaluated at execution time. Therefore, the execution of f1(1) will print different results each time we run it.\n\nf1 &lt;- function(x1) {\n  f2 &lt;- function(x2) {\n    f3 &lt;- function(x3) {\n      x1 + x2 + x3\n      print(\"f3\")\n      print(env_print())\n    }\n    f3(3)\n    print(\"f2\")\n    print(env_print())\n  }\n  f2(2)\n  print(\"f1\")\n  print(env_print())\n}\n\nf1(1)\n#&gt; [1] \"f3\"\n#&gt; &lt;environment: 0x590bfc014578&gt;\n#&gt; Parent: &lt;environment: 0x590bfc0143b8&gt;\n#&gt; Bindings:\n#&gt; • x3: &lt;dbl&gt;\n#&gt; &lt;environment: 0x590bfc014578&gt;\n#&gt; [1] \"f2\"\n#&gt; &lt;environment: 0x590bfc0143b8&gt;\n#&gt; Parent: &lt;environment: 0x590bfc013fc8&gt;\n#&gt; Bindings:\n#&gt; • f3: &lt;fn&gt;\n#&gt; • x2: &lt;dbl&gt;\n#&gt; &lt;environment: 0x590bfc0143b8&gt;\n#&gt; [1] \"f1\"\n#&gt; &lt;environment: 0x590bfc013fc8&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • f2: &lt;fn&gt;\n#&gt; • x1: &lt;dbl&gt;\n#&gt; &lt;environment: 0x590bfc013fc8&gt;\n\nQ3: Write an enhanced version of str() that provides more information about functions. Show where the function was found and what environment it was defined in.\nA: To solve this problem, we need to write a function that takes the name of a function and looks for that function returning both the function and the environment that it was found in.\n\nfget2 &lt;- function(name, env = caller_env()) {\n  # Base case\n  if (env_has(env, name)) {\n    obj &lt;- env_get(env, name)\n\n    if (is.function(obj)) {\n      return(list(fun = obj, env = env))\n    }\n  }\n\n  if (identical(env, emptyenv())) {\n    stop(\"Could not find a function called \\\"\", name, \"\\\"\",\n      call. = FALSE\n    )\n  }\n\n  # Recursive Case\n  fget2(name, env_parent(env))\n}\n\nfstr &lt;- function(fun_name, env = caller_env()) {\n  if (!is.character(fun_name) && length(fun_name) == 1) {\n    stop(\"`fun_name` must be a string.\", call. = FALSE)\n  }\n  fun_env &lt;- fget2(fun_name, env)\n\n  list(\n    where = fun_env$env,\n    enclosing = fn_env(fun_env$fun)\n  )\n}\n\n# Test\nfstr(\"mean\")\n#&gt; $where\n#&gt; &lt;environment: base&gt;\n#&gt; \n#&gt; $enclosing\n#&gt; &lt;environment: namespace:base&gt;\n\nOnce you have learned about tidy evaluation, you could rewrite fstr() to use enquo() so that you’d call it more like str(), i.e. fstr(sum)."
  },
  {
    "objectID": "07_Environments.html#call-stacks",
    "href": "07_Environments.html#call-stacks",
    "title": "7 Environments",
    "section": "Call stacks",
    "text": "Call stacks\nQ1: Write a function that lists all the variables defined in the environment in which it was called. It should return the same results as ls().\nA: We can implement this dynamic scoping behaviour by explicitly referencing the caller environment. Please note that this approach returns also variables starting with a dot, an option that ls() usually requires.\n\nls2 &lt;- function(env = caller_env()) {\n  sort(env_names(env))\n}\n\n# Test in global environment\nls(all.names = TRUE)\n#&gt;  [1] \".main\"           \".Random.seed\"    \"%&gt;%\"             \"a\"              \n#&gt;  [5] \"e1\"              \"e1a\"             \"e1b\"             \"e1c\"            \n#&gt;  [9] \"e2\"              \"e3\"              \"env_poke2\"       \"error_wrap\"     \n#&gt; [13] \"f1\"              \"fget\"            \"fget2\"           \"fstr\"           \n#&gt; [17] \"has_annotations\" \"ls2\"             \"mean\"            \"rebind\"         \n#&gt; [21] \"where\"           \"where2\"\nls2()\n#&gt;  [1] \".main\"           \".Random.seed\"    \"%&gt;%\"             \"a\"              \n#&gt;  [5] \"e1\"              \"e1a\"             \"e1b\"             \"e1c\"            \n#&gt;  [9] \"e2\"              \"e3\"              \"env_poke2\"       \"error_wrap\"     \n#&gt; [13] \"f1\"              \"fget\"            \"fget2\"           \"fstr\"           \n#&gt; [17] \"has_annotations\" \"ls2\"             \"mean\"            \"rebind\"         \n#&gt; [21] \"where\"           \"where2\"\n\n# Test in \"sandbox\" environment\ne1 &lt;- env(a = 1, b = 2)\nls(e1)\n#&gt; [1] \"a\" \"b\"\nls2(e1)\n#&gt; [1] \"a\" \"b\""
  },
  {
    "objectID": "07_Environments.html#references",
    "href": "07_Environments.html#references",
    "title": "7 Environments",
    "section": "References",
    "text": "References\n\n\n\n\nHenry, Lionel, and Hadley Wickham. 2020. Rlang: Functions for Base Types and Core r and ’Tidyverse’ Features. https://github.com/r-lib/rlang."
  },
  {
    "objectID": "08_Conditions.html#prerequisites",
    "href": "08_Conditions.html#prerequisites",
    "title": "8 - Conditions",
    "section": "Prerequisites",
    "text": "Prerequisites\nSimilar to the environments chapter, we also use functions from the {rlang} package to work with conditions.\n\nlibrary(rlang)"
  },
  {
    "objectID": "08_Conditions.html#signalling-conditions",
    "href": "08_Conditions.html#signalling-conditions",
    "title": "8 - Conditions",
    "section": "Signalling conditions",
    "text": "Signalling conditions\nQ1: Write a wrapper around file.remove() that throws an error if the file to be deleted does not exist.\nA: We prefer the following solution for its clarity and simplicity:\n\nfile_remove_strict &lt;- function(path) {\n  if (!file.exists(path)) {\n    stop(\"Can't delete the file \\\"\", path,\n      \"\\\" because it doesn't exist.\",\n      call. = FALSE\n    )\n  }\n  file.remove(path)\n}\n\n# Test\nsaveRDS(mtcars, \"mtcars.rds\")\nfile_remove_strict(\"mtcars.rds\")\n#&gt; [1] TRUE\nfile_remove_strict(\"mtcars.rds\")\n#&gt; Error: Can't delete the file \"mtcars.rds\" because it doesn't exist.\n\nQ2: What does the appendLF argument to message() do? How is it related to cat()?\nA: The appendLF argument automatically appends a new line to the message. Let’s illustrate this behaviour with a small example function:\n\nmultiline_msg &lt;- function(appendLF = TRUE) {\n  message(\"first\", appendLF = appendLF)\n  message(\"second\", appendLF = appendLF)\n  cat(\"third\")\n  cat(\"fourth\")\n}\n\nmultiline_msg(appendLF = TRUE)\n#&gt; first\n#&gt; second\n#&gt; thirdfourth\nmultiline_msg(appendLF = FALSE)\n#&gt; firstsecondthirdfourth\n\nComparable behaviour regarding line breaks for cat() can be achieved via setting its sep argument to \"\\n\"."
  },
  {
    "objectID": "08_Conditions.html#handling-conditions",
    "href": "08_Conditions.html#handling-conditions",
    "title": "8 - Conditions",
    "section": "Handling conditions",
    "text": "Handling conditions\nQ1: What extra information does the condition generated by abort() contain compared to the condition generated by stop(), i.e. what’s the difference between these two objects? Read the help for ?abort to learn more.\n\ncatch_cnd(stop(\"An error\"))\ncatch_cnd(abort(\"An error\"))\n\nA: In contrast to stop(), which contains the call, abort() stores the whole backtrace generated by rlang::trace_back(). This is a lot of extra data!\n\nstr(catch_cnd(stop(\"An error\")))\n#&gt; List of 2\n#&gt;  $ message: chr \"An error\"\n#&gt;  $ call   : language force(expr)\n#&gt;  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\nstr(catch_cnd(abort(\"An error\")))\n#&gt; List of 5\n#&gt;  $ message: chr \"An error\"\n#&gt;  $ trace  :Classes 'rlang_trace', 'rlib_trace', 'tbl' and 'data.frame':  9 obs...\n#&gt;   ..$ call       :List of 9\n#&gt;   .. ..$ : language str(catch_cnd(abort(\"An error\")))\n#&gt;   .. ..$ : language catch_cnd(abort(\"An error\"))\n#&gt;   .. ..$ : language eval_bare(rlang::expr(tryCatch(!!!handlers, {     force(ex..\n#&gt;   .. ..$ : language tryCatch(condition = `&lt;fn&gt;`, {     force(expr) ...\n#&gt;   .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)\n#&gt;   .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#&gt;   .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)\n#&gt;   .. ..$ : language force(expr)\n#&gt;   .. ..$ : language abort(\"An error\")\n#&gt;   ..$ parent     : int [1:9] 0 0 2 2 4 5 6 2 0\n#&gt;   ..$ visible    : logi [1:9] FALSE FALSE FALSE FALSE FALSE FALSE ...\n#&gt;   ..$ namespace  : chr [1:9] \"utils\" \"rlang\" \"rlang\" \"base\" ...\n#&gt;   ..$ scope      : chr [1:9] \"::\" \"::\" \"::\" \"::\" ...\n#&gt;   ..$ error_frame: logi [1:9] FALSE FALSE FALSE FALSE FALSE FALSE ...\n#&gt;   ..- attr(*, \"version\")= int 2\n#&gt;  $ parent : NULL\n#&gt;  $ rlang  :List of 1\n#&gt;   ..$ inherit: logi TRUE\n#&gt;  $ call   : NULL\n#&gt;  - attr(*, \"class\")= chr [1:3] \"rlang_error\" \"error\" \"condition\"\n\nQ2: Predict the results of evaluating the following code\n\nshow_condition &lt;- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      NULL\n    }\n  )\n}\n\n\nshow_condition(stop(\"!\"))\nshow_condition(10)\nshow_condition(warning(\"?!\"))\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n\nA: The first three examples are straightforward:\n\nshow_condition(stop(\"!\")) # stop raises an error\n#&gt; [1] \"error\"\nshow_condition(10) # no condition is signalled\n#&gt; NULL\nshow_condition(warning(\"?!\")) # warning raises a warning\n#&gt; [1] \"warning\"\n\nThe last example is the most interesting and makes us aware of the exiting qualities of tryCatch(); it will terminate the evaluation of the code as soon as it is called.\n\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n#&gt; [1] \"message\"\n\nQ3: Explain the results of running this code:\n\nwithCallingHandlers( # (1)\n  message = function(cnd) message(\"b\"),\n  withCallingHandlers( # (2)\n    message = function(cnd) message(\"a\"),\n    message(\"c\")\n  )\n)\n#&gt; b\n#&gt; a\n#&gt; b\n#&gt; c\n\nA: It’s a little tricky to untangle the flow here:\nFirst, message(\"c\") is run, and it’s caught by (1). It then calls message(\"a\"), which is caught by (2), which calls message(\"b\"). message(\"b\") isn’t caught by anything, so we see a b on the console, followed by a. But why do we get another b before we see c? That’s because we haven’t handled the message, so it bubbles up to the outer calling handler.\nQ4: Read the source code for catch_cnd() and explain how it works. At the time Advanced R was written, the source for catch_cnd() was a little simpler:\n\ncatch_cnd &lt;- function(expr) {\n  tryCatch(\n    condition = function(cnd) cnd,\n    {\n      force(expr)\n      return(NULL)\n    }\n  )\n}\n\nA: catch_cnd() is a simple wrapper around tryCatch(). If a condition is signalled, it’s caught and returned. If no condition is signalled, execution proceeds sequentially and the function returns NULL.\nThe current version of catch_cnd() is a little more complex because it allows you to specify which classes of condition you want to capture. This requires some manual code generation because the interface of tryCatch() provides condition classes as argument names.\n\nrlang::catch_cnd\n#&gt; function (expr, classes = \"condition\") \n#&gt; {\n#&gt;     stopifnot(is_character(classes))\n#&gt;     handlers &lt;- rep_named(classes, list(identity))\n#&gt;     eval_bare(rlang::expr(tryCatch(!!!handlers, {\n#&gt;         force(expr)\n#&gt;         return(NULL)\n#&gt;     })))\n#&gt; }\n#&gt; &lt;bytecode: 0x59a31a9d0fd8&gt;\n#&gt; &lt;environment: namespace:rlang&gt;\n\nQ5: How could you rewrite show_condition() to use a single handler?\nA: show_condition() was defined in one of the previous questions. Let’s use the condition argument of tryCatch() as shown in rlang::catch_cond() above for our re-implementation:\n\nshow_condition2 &lt;- function(code) {\n  tryCatch(\n    condition = function(cnd) {\n      if (inherits(cnd, \"error\")) {\n        return(\"error\")\n      }\n      if (inherits(cnd, \"warning\")) {\n        return(\"warning\")\n      }\n      if (inherits(cnd, \"message\")) {\n        return(\"message\")\n      }\n    },\n    {\n      code\n      NULL\n    }\n  )\n}\n\n# Test\nshow_condition2(stop(\"!\"))\n#&gt; [1] \"error\"\nshow_condition2(10)\n#&gt; NULL\nshow_condition2(warning(\"?!\"))\n#&gt; [1] \"warning\"\nshow_condition2({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n#&gt; [1] \"message\"\n\ntryCatch() executes the code and captures any condition raised. The function provided as the condition handles this condition. In this case it dispatches on the class of the condition."
  },
  {
    "objectID": "08_Conditions.html#custom-conditions",
    "href": "08_Conditions.html#custom-conditions",
    "title": "8 - Conditions",
    "section": "Custom conditions",
    "text": "Custom conditions\nQ1: Inside a package, it’s occasionally useful to check that a package is installed before using it. Write a function that checks if a package is installed (with requireNamespace(\"pkg\", quietly = FALSE)) and if not, throws a custom condition that includes the package name in the metadata.\nA: We use rlang::abort() to supply error metadata:\n\ncheck_installed &lt;- function(package) {\n  if (!requireNamespace(package, quietly = FALSE)) {\n    abort(\n      \"error_pkg_not_found\",\n      message = paste0(\"package '\", package, \"' not installed.\"),\n      package = package\n    )\n  }\n\n  TRUE\n}\n\ncheck_installed(\"ggplot2\")\n#&gt; [1] TRUE\ncheck_installed(\"ggplot3\")\n#&gt; Loading required namespace: ggplot3\n#&gt; Error in `check_installed()`:\n#&gt; ! package 'ggplot3' not installed.\n\nQ2: Inside a package you often need to stop with an error when something is not right. Other packages that depend on your package might be tempted to check these errors in their unit tests. How could you help these packages to avoid relying on the error message which is part of the user interface rather than the API and might change without notice?\nA: Instead of returning an error it might be preferable to throw a customised condition and place a standardised error message inside the metadata. Then the downstream package could check for the class of the condition, rather than inspecting the message."
  },
  {
    "objectID": "08_Conditions.html#applications",
    "href": "08_Conditions.html#applications",
    "title": "8 - Conditions",
    "section": "Applications",
    "text": "Applications\nQ1: Create suppressConditions() that works like suppressMessages() and suppressWarnings() but suppresses everything. Think carefully about how you should handle errors.\nA: In general, we would like to catch errors, since they contain important information for debugging. To suppress the error message and hide the returned error object from the console, we handle errors within a tryCatch() and return the error object invisibly:\n\nsuppressErrors &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) invisible(cnd),\n    interrupt = function(cnd) {\n      stop(\"Terminated by the user.\",\n        call. = FALSE\n      )\n    },\n    expr\n  )\n}\n\nAfter we defined the error handling, we can just combine it with the other handlers to create suppressConditions():\n\nsuppressConditions &lt;- function(expr) {\n  suppressErrors(suppressWarnings(suppressMessages(expr)))\n}\n\nTo test the new function, we apply it to a set of conditions and inspect the returned error object.\n\n# The messages/warnings/conditions are suppressed successfully\nerror_obj &lt;- suppressConditions({\n  message(\"message\")\n  warning(\"warning\")\n  abort(\"error\")\n})\n\nerror_obj\n#&gt; &lt;error/rlang_error&gt;\n#&gt; Error:\n#&gt; ! error\n#&gt; ---\n#&gt; Backtrace:\n#&gt; ▆\n\nQ2: Compare the following two implementations of message2error(). What is the main advantage of withCallingHandlers() in this scenario? (Hint: look carefully at the traceback.)\n\nmessage2error &lt;- function(code) {\n  withCallingHandlers(code, message = function(e) stop(e))\n}\nmessage2error &lt;- function(code) {\n  tryCatch(code, message = function(e) stop(e))\n}\n\nA: Both functions differ in the way conditions are handled. withCallingHandlers() creates a calling handler, which is executed from within the signalling function. This makes it possible to record a detailed call stack, which helps us identify the signalling condition.\ntryCatch() defines an exiting handler, which means that the signalling function is terminated as soon as a condition is raised. It also returns control to the context where tryCatch() was called.\nIn this example the use of withCallingHandlers() returns more information than the use of tryCatch(). This allows us to determine the exact call that raised the condition.\n\nmessage2error1 &lt;- function(code) {\n  withCallingHandlers(code, message = function(e) stop(\"error\"))\n}\n\nmessage2error1({\n  1\n  message(\"hidden error\")\n  NULL\n})\n#&gt; Error in (function (e) : error\ntraceback()\n#&gt; 9: stop(\"error\") at #2\n#&gt; 8: (function (e)\n#&gt;    stop(\"error\"))(list(message = \"hidden error\\n\",\n#&gt;      call = message(\"hidden error\")))\n#&gt; 7: signalCondition(cond)\n#&gt; 6: doWithOneRestart(return(expr), restart)\n#&gt; 5: withOneRestart(expr, restarts[[1L]])\n#&gt; 4: withRestarts({\n#&gt;        signalCondition(cond)\n#&gt;        defaultHandler(cond)\n#&gt;    }, muffleMessage = function() NULL)\n#&gt; 3: message(\"hidden error\") at #1\n#&gt; 2: withCallingHandlers(code,\n#&gt;      message = function(e) stop(\"error\")) at #2\n#&gt; 1: message2error1({\n#&gt;        1\n#&gt;        message(\"hidden error\")\n#&gt;        NULL\n#&gt;    })\n\n\nmessage2error2 &lt;- function(code) {\n  tryCatch(code, message = function(e) (stop(\"error\")))\n}\n\nmessage2error2({\n  1\n  stop(\"hidden error\")\n  NULL\n})\n#&gt; Error in value[[3L]](cond) : error\ntraceback()\n#&gt; 6: stop(\"error\") at #2\n#&gt; 5: value[[3L]](cond)\n#&gt; 4: tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#&gt; 3: tryCatchList(expr, classes, parentenv, handlers)\n#&gt; 2: tryCatch(code, message = function(e) (stop(\"error\"))) at #2\n#&gt; 1: message2error2({\n#&gt;        1\n#&gt;        message(\"hidden error\")\n#&gt;        NULL\n#&gt;    })\n\nQ3: How would you modify the catch_cnds() definition if you wanted to recreate the original intermingling of warnings and messages?\nA: It looks like Hadley wrote a part of the chapter after the exercises, as the catch_cnds() function defined in the chapter already solves this problem by storing all messages and warnings in their original order within a list.\n\ncatch_cnds &lt;- function(expr) {\n  conds &lt;- list()\n  add_cond &lt;- function(cnd) {\n    conds &lt;&lt;- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n\n  tryCatch(\n    error = function(cnd) {\n      conds &lt;&lt;- append(conds, list(cnd))\n    },\n    withCallingHandlers(\n      message = add_cond,\n      warning = add_cond,\n      expr\n    )\n  )\n\n  conds\n}\n\n# Test\ncatch_cnds({\n  inform(\"message a\")\n  warn(\"warning b\")\n  inform(\"message c\")\n})\n#&gt; [[1]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; message a\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;warning/rlang_warning&gt;\n#&gt; Warning:\n#&gt; warning b\n#&gt; \n#&gt; [[3]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; message c\n\nQ4: Why is catching interrupts dangerous? Run this code to find out.\n\nbottles_of_beer &lt;- function(i = 99) {\n  message(\n    \"There are \", i,\n    \" bottles of beer on the wall, \", i,\n    \" bottles of beer.\"\n  )\n  while (i &gt; 0) {\n    tryCatch(\n      Sys.sleep(1),\n      interrupt = function(err) {\n        i &lt;&lt;- i - 1\n        if (i &gt; 0) {\n          message(\n            \"Take one down, pass it around, \", i,\n            \" bottle\", if (i &gt; 1) \"s\", \" of beer on the wall.\"\n          )\n        }\n      }\n    )\n  }\n  message(\n    \"No more bottles of beer on the wall, \",\n    \"no more bottles of beer.\"\n  )\n}\n\nA: When running the bottles_of_beer() function in your console, the output should look somehow like the following:\n\nbottles_of_beer()\n#&gt; There are 99 bottles of beer on the wall, 99 bottles of beer.\n#&gt; Take one down, pass it around, 98 bottles of beer on the wall.\n#&gt; Take one down, pass it around, 97 bottles of beer on the wall.\n#&gt; Take one down, pass it around, 96 bottles of beer on the wall.\n#&gt; Take one down, pass it around, 95 bottles of beer on the wall.\n#&gt;\n\nAt this point you’ll probably recognise how hard it is to get the number of bottles down from 99 to 0. There’s no way to break out of the function because we’re capturing the interrupt that you’d usually use!"
  },
  {
    "objectID": "09_Functionals.html#prerequisites",
    "href": "09_Functionals.html#prerequisites",
    "title": "9 - Functionals",
    "section": "Prerequisites",
    "text": "Prerequisites\nFor the functional programming part of the book, we will mainly use functions from the {purrr} package (Henry and Wickham 2020).\n\nlibrary(purrr)"
  },
  {
    "objectID": "09_Functionals.html#my-first-functional-map",
    "href": "09_Functionals.html#my-first-functional-map",
    "title": "9 - Functionals",
    "section": "My first functional: map()",
    "text": "My first functional: map()\nQ1: Use as_mapper() to explore how {purrr} generates anonymous functions for the integer, character, and list helpers. What helper allows you to extract attributes? Read the documentation to find out.\nA: map() offers multiple ways (functions, formulas, and extractor functions) to specify its function argument (.f). Initially, the various inputs have to be transformed into a valid function, which is then applied. The creation of this valid function is the job of as_mapper() and it is called every time map() is used.\nGiven character, numeric or list input as_mapper() will create an extractor function. Characters select by name, while numeric input selects by positions and a list allows a mix of these two approaches. This extractor interface can be very useful, when working with nested data.\nThe extractor function is implemented as a call to purrr::pluck(), which accepts a list of accessors (accessors “access” some part of your data object).\n\nas_mapper(c(1, 2)) # equivalent to function(x) x[[1]][[2]]\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(1, 2), .default = NULL)\n#&gt; &lt;environment: 0x5d63c648c988&gt;\nas_mapper(c(\"a\", \"b\")) # equivalent to function(x) x[[\"a\"]][[\"b]]\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(\"a\", \"b\"), .default = NULL)\n#&gt; &lt;environment: 0x5d63c64eb4d0&gt;\nas_mapper(list(1, \"b\")) # equivalent to function(x) x[[1]][[\"b]]\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(1, \"b\"), .default = NULL)\n#&gt; &lt;environment: 0x5d63c660f0b8&gt;\n\nBesides mixing positions and names, it is also possible to pass along an accessor function. This is basically an anonymous function that gets information about some aspect of the input data. You are free to define your own accessor functions.\nIf you need to access certain attributes, the helper attr_getter(y) is already predefined and will create the appropriate accessor function for you.\n\n# Define custom accessor function\nget_class &lt;- function(x) attr(x, \"class\")\npluck(mtcars, get_class)\n#&gt; [1] \"data.frame\"\n\n# Use attr_getter() as a helper\npluck(mtcars, attr_getter(\"class\"))\n#&gt; [1] \"data.frame\"\n\nQ2: map(1:3, ~ runif(2)) is a useful pattern for generating random numbers, but map(1:3, runif(2)) is not. Why not? Can you explain why it returns the result that it does?\nA: The first pattern creates multiple random numbers, because ~ runif(2) successfully uses the formula interface. Internally map() applies as_mapper() to this formula, which converts ~ runif(2) into an anonymous function. Afterwards runif(2) is applied three times (one time during each iteration), leading to three different pairs of random numbers.\nIn the second pattern runif(2) is evaluated once, then the results are passed to map(). Consequently as_mapper() creates an extractor function based on the return values from runif(2) (via pluck()). This leads to three NULLs (pluck()’s .default return), because no values corresponding to the index can be found.\n\nas_mapper(~ runif(2))\n#&gt; &lt;lambda&gt;\n#&gt; function (..., .x = ..1, .y = ..2, . = ..1) \n#&gt; runif(2)\n#&gt; attr(,\"class\")\n#&gt; [1] \"rlang_lambda_function\" \"function\"\nas_mapper(runif(2))\n#&gt; function (x, ...) \n#&gt; pluck_raw(x, list(0.0807501375675201, 0.834333037259057), .default = NULL)\n#&gt; &lt;environment: 0x5d63c462a700&gt;\n\nQ3: Use the appropriate map() function to:\n\nCompute the standard deviation of every column in a numeric data frame.\nCompute the standard deviation of every numeric column in a mixed data frame. (Hint: you’ll need to do it in two steps.)\nCompute the number of levels for every factor in a data frame.\n\nA: To solve this exercise we take advantage of calling the type stable variants of map(), which give us more concise output, and use map_lgl() to select the columns of the data frame (later you’ll learn about keep(), which simplifies this pattern a little).\n\nmap_dbl(mtcars, sd)\n#&gt;     mpg     cyl    disp      hp    drat      wt    qsec      vs      am    gear \n#&gt;   6.027   1.786 123.939  68.563   0.535   0.978   1.787   0.504   0.499   0.738 \n#&gt;    carb \n#&gt;   1.615\n\npenguins &lt;- palmerpenguins::penguins\n\npenguins_numeric &lt;- map_lgl(penguins, is.numeric)\nmap_dbl(penguins[penguins_numeric], sd, na.rm = TRUE)\n#&gt;    bill_length_mm     bill_depth_mm flipper_length_mm       body_mass_g \n#&gt;             5.460             1.975            14.062           801.955 \n#&gt;              year \n#&gt;             0.818\n\npenguins_factor &lt;- map_lgl(penguins, is.factor)\nmap_int(penguins[penguins_factor], ~ length(levels(.x)))\n#&gt; species  island     sex \n#&gt;       3       3       2\n\nQ4: The following code simulates the performance of a t-test for non-normal data. Extract the p-value from each test, then visualise.\n\ntrials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))\n\nA: There are many ways to visualise this data. However, since there are only 100 data points, we choose a dot plot to visualise the distribution. (Unfortunately, {ggplot2}s geom_dotplot() doesn’t compute proper counts as it was created to visualise distribution densities instead of frequencies, so a histogram would be a suitable alternative).\n\nlibrary(ggplot2)\n\ndf_trials &lt;- tibble::tibble(p_value = map_dbl(trials, \"p.value\"))\n\ndf_trials %&gt;%\n  ggplot(aes(x = p_value, fill = p_value &lt; 0.05)) +\n  geom_dotplot(binwidth = .01) + # geom_histogram() as alternative\n  theme(\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    legend.position = \"top\"\n  )\n\n\n\n\n\n\n\n\nQ5: The following code uses a map nested inside another map to apply a function to every element of a nested list. Why does it fail, and what do you need to do to make it work?\n\nx &lt;- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple &lt;- function(x) x * 3\nmap(x, map, .f = triple)\n#&gt; Error in `map()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error in `.f()`:\n#&gt; ! unused argument (function (.x, .f, ..., .progress = FALSE) \n#&gt; {\n#&gt;     map_(\"list\", .x, .f, ..., .progress = .progress)\n#&gt; })\n\nA: This function call fails, because triple() is specified as the .f argument and consequently belongs to the outer map(). The unnamed argument map is treated as an argument of triple(), which causes the error.\nThere are a number of ways we could resolve the problem. However, there is not much to choose between them for this simple example, although it is good to know your options for more complicated cases.\n\n# Don't name the argument\nmap(x, map, triple)\n\n# Use magrittr-style anonymous function\nmap(x, . %&gt;% map(triple))\n\n# Use purrr-style anonymous function\nmap(x, ~ map(.x, triple))\n\nQ6: Use map() to fit linear models to the mtcars dataset using the formulas stored in this list:\n\nformulas &lt;- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\n\nA: The data (mtcars) is constant for all these models and so we iterate over the formulas provided. As the formula is the first argument of lm(), we don’t need to specify it explicitly.\n\nmodels &lt;- map(formulas, lm, data = mtcars)\n\nQ7: Fit the model mpg ~ disp to each of the bootstrap replicates of mtcars in the list below, then extract the \\(R^2\\) of the model fit (Hint: you can compute the \\(R^2\\) with summary())\n\nbootstrap &lt;- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps &lt;- map(1:10, ~ bootstrap(mtcars))\n\nA: To accomplish this task, we take advantage of the “list in, list out”-functionality of map(). This allows us to chain multiple transformations together. We start by fitting the models. We then calculate the summaries and extract the \\(R^2\\) values. For the last call we use map_dbl(), which provides convenient output.\n\nbootstraps %&gt;%\n  map(~ lm(mpg ~ disp, data = .x)) %&gt;%\n  map(summary) %&gt;%\n  map_dbl(\"r.squared\")\n#&gt;  [1] 0.588 0.822 0.745 0.746 0.784 0.749 0.613 0.792 0.653 0.726"
  },
  {
    "objectID": "09_Functionals.html#map-variants",
    "href": "09_Functionals.html#map-variants",
    "title": "9 - Functionals",
    "section": "Map variants",
    "text": "Map variants\nQ1: Explain the results of modify(mtcars, 1).\nA: modify() is based on map(), and in this case, the extractor interface will be used. It extracts the first element of each column in mtcars. modify() always returns the same structure as its input: in this case it forces the first row to be recycled 32 times. (Internally modify() uses .x[] &lt;- map(.x, .f, ...) for assignment.)\n\nhead(modify(mtcars, 1))\n#&gt;   mpg cyl disp  hp drat   wt qsec vs am gear carb\n#&gt; 1  21   6  160 110  3.9 2.62 16.5  0  1    4    4\n#&gt; 2  21   6  160 110  3.9 2.62 16.5  0  1    4    4\n#&gt; 3  21   6  160 110  3.9 2.62 16.5  0  1    4    4\n#&gt; 4  21   6  160 110  3.9 2.62 16.5  0  1    4    4\n#&gt; 5  21   6  160 110  3.9 2.62 16.5  0  1    4    4\n#&gt; 6  21   6  160 110  3.9 2.62 16.5  0  1    4    4\n\nQ2: Rewrite the following code to use iwalk() instead of walk2(). What are the advantages and disadvantages?\n\ncyls &lt;- split(mtcars, mtcars$cyl)\npaths &lt;- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\n\nA: iwalk() allows us to use a single variable, storing the output path in the names.\n\ntemp &lt;- tempfile()\ndir.create(temp)\n\ncyls &lt;- split(mtcars, mtcars$cyl)\nnames(cyls) &lt;- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\niwalk(cyls, ~ write.csv(.x, .y))\n\nWe could do this in a single pipe by taking advantage of set_names():\n\nmtcars %&gt;%\n  split(mtcars$cyl) %&gt;%\n  set_names(~ file.path(temp, paste0(\"cyl-\", .x, \".csv\"))) %&gt;%\n  iwalk(~ write.csv(.x, .y))\n\nQ3: Explain how the following code transforms a data frame using functions stored in a list.\n\ntrans &lt;- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm &lt;- names(trans)\nmtcars[nm] &lt;- map2(trans, mtcars[nm], function(f, var) f(var))\n\nCompare and contrast the map2() approach to this map() approach:\n\nmtcars[nm] &lt;- map(nm, ~ trans[[.x]](mtcars[[.x]]))\n\nA: In the first approach\n\nmtcars[nm] &lt;- map2(trans, mtcars[nm], function(f, var) f(var))\n\nthe list of the 2 functions (trans) and the 2 appropriately selected data frame columns (mtcars[nm]) are supplied to map2(). map2() creates an anonymous function (f(var)) which applies the functions to the variables when map2() iterates over their (similar) indices. On the left-hand side, the respective 2 elements of mtcars are being replaced by their new transformations.\nThe map() variant\n\nmtcars[nm] &lt;- map(nm, ~ trans[[.x]](mtcars[[.x]]))\n\ndoes basically the same. However, it directly iterates over the names (nm) of the transformations. Therefore, the data frame columns are selected during the iteration.\nBesides the iteration pattern, the approaches differ in the possibilities for appropriate argument naming in the .f argument. In the map2() approach we iterate over the elements of x and y. Therefore, it is possible to choose appropriate placeholders like f and var. This makes the anonymous function more expressive at the cost of making it longer. We think using the formula interface in this way is preferable compared to the rather cryptic mtcars[nm] &lt;- map2(trans, mtcars[nm], ~ .x(.y)).\nIn the map() approach we map over the variable names. It is therefore not possible to introduce placeholders for the function and variable names. The formula syntax together with the .x pronoun is pretty compact. The object names and the brackets clearly indicate the application of transformations to specific columns of mtcars. In this case the iteration over the variable names comes in handy, as it highlights the importance of matching between trans and mtcars element names. Together with the replacement form on the left-hand side, this line is relatively easy to inspect.\nTo summarise, in situations where map() and map2() provide solutions for an iteration problem, several points may be considered before deciding for one or the other approach.\nQ4: What does write.csv() return, i.e. what happens if you use it with map2() instead of walk2()?\nA: write.csv() returns NULL. As we call the function for its side effect (creating a CSV file), walk2() would be appropriate here. Otherwise, we receive a rather uninformative list of NULLs.\n\ncyls &lt;- split(mtcars, mtcars$cyl)\npaths &lt;- file.path(tempdir(), paste0(\"cyl-\", names(cyls), \".csv\"))\n\nmap2(cyls, paths, write.csv)\n#&gt; $`4`\n#&gt; NULL\n#&gt; \n#&gt; $`6`\n#&gt; NULL\n#&gt; \n#&gt; $`8`\n#&gt; NULL"
  },
  {
    "objectID": "09_Functionals.html#predicate-functionals",
    "href": "09_Functionals.html#predicate-functionals",
    "title": "9 - Functionals",
    "section": "Predicate functionals",
    "text": "Predicate functionals\nQ1: Why isn’t is.na() a predicate function? What base R function is closest to being a predicate version of is.na()?\nA: is.na() is not a predicate function, because it returns a logical vector the same length as the input, not a single TRUE or FALSE.\nanyNA() is the closest equivalent because it always returns a single TRUE or FALSE if there are any missing values present. You could also imagine an allNA() which would return TRUE if all values were missing, but that’s considerably less useful so base R does not provide it.\nQ2: simple_reduce() has a problem when x is length 0 or length 1. Describe the source of the problem and how you might go about fixing it.\n\nsimple_reduce &lt;- function(x, f) {\n  out &lt;- x[[1]]\n  for (i in seq(2, length(x))) {\n    out &lt;- f(out, x[[i]])\n  }\n  out\n}\n\nA: The loop inside simple_reduce() always starts with the index 2, and seq() can count both up and down:\n\nseq(2, 0)\n#&gt; [1] 2 1 0\nseq(2, 1)\n#&gt; [1] 2 1\n\nTherefore, subsetting length-0 and length-1 vectors via [[ will lead to a subscript out of bounds error. To avoid this, we allow simple_reduce() to return before the for loop is started and include a default argument for 0-length vectors.\n\nsimple_reduce &lt;- function(x, f, default) {\n  if (length(x) == 0L) {\n    return(default)\n  }\n  if (length(x) == 1L) {\n    return(x[[1L]])\n  }\n\n  out &lt;- x[[1]]\n  for (i in seq(2, length(x))) {\n    out &lt;- f(out, x[[i]])\n  }\n  out\n}\n\nOur new simple_reduce() now works as intended:\n\nsimple_reduce(integer(0), `+`)\n#&gt; Error in simple_reduce(integer(0), `+`): argument \"default\" is missing, with no default\nsimple_reduce(integer(0), `+`, default = 0L)\n#&gt; [1] 0\nsimple_reduce(1, `+`)\n#&gt; [1] 1\nsimple_reduce(1:3, `+`)\n#&gt; [1] 6\n\nQ3: Implement the span() function from Haskell: given a list x and a predicate function f, span(x, f) returns the location of the longest sequential run of elements where the predicate is true. (Hint: you might find rle() helpful.)\nA: Our span_r() function returns the indices of the (first occurring) longest sequential run of elements where the predicate is true. If the predicate is never true, the longest run has length 0, in which case we return integer(0).\n\nspan_r &lt;- function(x, f) {\n  idx &lt;- unname(map_lgl(x, ~ f(.x)))\n  rle &lt;- rle(idx)\n\n  # Check if the predicate is never true\n  if (!any(rle$values)) {\n    return(integer(0))\n  }\n\n  # Find the length of the longest sequence of true values\n  longest &lt;- max(rle$lengths[rle$values])\n  # Find the positition of the (first) longest run in rle\n  longest_idx &lt;- which(rle$values & rle$lengths == longest)[1]\n\n  # Add up all lengths in rle before the longest run\n  ind_before_longest &lt;- sum(rle$lengths[seq_len(longest_idx - 1)])\n\n  out_start &lt;- ind_before_longest + 1L\n  out_end &lt;- ind_before_longest + longest\n  out_start:out_end\n}\n\n# Check that it works\nspan_r(c(0, 0, 0, 0, 0), is.na)\n#&gt; integer(0)\nspan_r(c(NA, 0, 0, 0, 0), is.na)\n#&gt; [1] 1\nspan_r(c(NA, 0, NA, NA, NA), is.na)\n#&gt; [1] 3 4 5\n\nQ4: Implement arg_max(). It should take a function and a vector of inputs, and return the elements of the input where the function returns the highest value. For example, arg_max(-10:5, function(x) x ^ 2) should return -10. arg_max(-5:5, function(x) x ^ 2) should return c(-5, 5). Also implement the matching arg_min() function.\nA: Both functions take a vector of inputs and a function as an argument. The function output is then used to subset the input accordingly.\n\narg_max &lt;- function(x, f) {\n  y &lt;- map_dbl(x, f)\n  x[y == max(y)]\n}\n\narg_min &lt;- function(x, f) {\n  y &lt;- map_dbl(x, f)\n  x[y == min(y)]\n}\n\narg_max(-10:5, function(x) x^2)\n#&gt; [1] -10\narg_min(-10:5, function(x) x^2)\n#&gt; [1] 0\n\nQ5: The function below scales a vector so it falls in the range [0, 1]. How would you apply it to every column of a data frame? How would you apply it to every numeric column in a data frame?\n\nscale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\nA: To apply a function to every column of a data frame, we can use purrr::modify() (or purrr::map_dfr()), which also conveniently returns a data frame. To limit the application to numeric columns, the scoped version modify_if() can be used.\n\nmodify_if(mtcars, is.numeric, scale01)"
  },
  {
    "objectID": "09_Functionals.html#base-functionals",
    "href": "09_Functionals.html#base-functionals",
    "title": "9 - Functionals",
    "section": "Base functionals",
    "text": "Base functionals\nQ1: How does apply() arrange the output? Read the documentation and perform some experiments.\nA: Basically apply() applies a function over the margins of an array. In the two-dimensional case, the margins are just the rows and columns of a matrix. Let’s make this concrete.\n\narr2 &lt;- array(1:12, dim = c(3, 4))\nrownames(arr2) &lt;- paste0(\"row\", 1:3)\ncolnames(arr2) &lt;- paste0(\"col\", 1:4)\narr2\n#&gt;      col1 col2 col3 col4\n#&gt; row1    1    4    7   10\n#&gt; row2    2    5    8   11\n#&gt; row3    3    6    9   12\n\nWhen we apply the head() function over the first margin of arr2() (i.e. the rows), the results are contained in the columns of the output, transposing the array compared to the original input.\n\napply(arr2, 1, function(x) x[1:2])\n#&gt;      row1 row2 row3\n#&gt; col1    1    2    3\n#&gt; col2    4    5    6\n\nAnd vice versa if we apply over the second margin (the columns):\n\napply(arr2, 2, function(x) x[1:2])\n#&gt;      col1 col2 col3 col4\n#&gt; row1    1    4    7   10\n#&gt; row2    2    5    8   11\n\nThe output of apply() is organised first by the margins being operated over, then the results of the function. This can become quite confusing for higher dimensional arrays.\nQ2: What do eapply() and rapply() do? Does {purrr} have equivalents?\nA: eapply() is a variant of lapply(), which iterates over the (named) elements of an environment. In {purrr} there is no equivalent for eapply() as {purrr} mainly provides functions that operate on vectors and functions, but not on environments.\nrapply() applies a function to all elements of a list recursively. This function makes it possible to limit the application of the function to specified classes (default classes = ANY). One may also specify how elements of other classes should remain: as their identity (how = replace) or another value (default = NULL). The closest equivalent in {purrr} is modify_depth(), which allows you to modify elements at a specified depth in a nested list.\nQ3: Challenge: read about the fixed point algorithm. Complete the exercises using R.\nA: A number \\(x\\) is called a fixed point of a function \\(f\\) if it satisfies the equation \\(f(x) = x\\). For some functions we may find a fixed point by beginning with a starting value and applying \\(f\\) repeatedly. Here fixed_point() acts as a functional because it takes a function as an argument.\n\nfixed_point &lt;- function(f, x_init, n_max = 10000, tol = 0.0001) {\n  n &lt;- 0\n  x &lt;- x_init\n  y &lt;- f(x)\n\n  is_fixed_point &lt;- function(x, y) {\n    abs(x - y) &lt; tol\n  }\n\n  while (!is_fixed_point(x, y)) {\n    x &lt;- y\n    y &lt;- f(y)\n\n    # Make sure we eventually stop\n    n &lt;- n + 1\n    if (n &gt; n_max) {\n      stop(\"Failed to converge.\", call. = FALSE)\n    }\n  }\n\n  x\n}\n\n\n# Functions with fixed points\nfixed_point(sin, x_init = 1)\n#&gt; [1] 0.0843\nfixed_point(cos, x_init = 1)\n#&gt; [1] 0.739\n\n# Functions without fixed points\nadd_one &lt;- function(x) x + 1\nfixed_point(add_one, x_init = 1)\n#&gt; Error: Failed to converge."
  },
  {
    "objectID": "09_Functionals.html#references",
    "href": "09_Functionals.html#references",
    "title": "9 - Functionals",
    "section": "References",
    "text": "References\n\n\n\n\nHenry, Lionel, and Hadley Wickham. 2020. Purrr: Functional Programming Tools. https://github.com/tidyverse/purrr."
  },
  {
    "objectID": "10_Function_factories.html#prerequisites",
    "href": "10_Function_factories.html#prerequisites",
    "title": "10 - Function factories",
    "section": "Prerequisites",
    "text": "Prerequisites\nFor most of this chapter base R (R Core Team 2020) is sufficient. Just a few exercises require the {rlang} (Henry and Wickham 2020b), {dplyr} (Wickham et al. 2020), {purrr} (Henry and Wickham 2020a) and {ggplot2} (Wickham 2016) packages.\n\nlibrary(rlang)\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(ggplot2)"
  },
  {
    "objectID": "10_Function_factories.html#factory-fundamentals",
    "href": "10_Function_factories.html#factory-fundamentals",
    "title": "10 - Function factories",
    "section": "Factory fundamentals",
    "text": "Factory fundamentals\nQ1: The definition of force() is simple:\n\nforce\n#&gt; function (x) \n#&gt; x\n#&gt; &lt;bytecode: 0x5f56c3bd90f0&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nWhy is it better to force(x) instead of just x?\nA: As you can see force(x) is similar to x. As mentioned in Advanced R, we prefer this explicit form, because\n\nusing this function clearly indicates that you’re forcing evaluation, not that you’ve accidentally typed x.”\n\nQ2: Base R contains two function factories, approxfun() and ecdf(). Read their documentation and experiment to figure out what the functions do and what they return.\nA: Let’s begin with approxfun() as it is used within ecdf() as well:\napproxfun() takes a combination of data points (x and y values) as input and returns a stepwise linear (or constant) interpolation function. To find out what this means exactly, we first create a few random data points.\n\nx &lt;- runif(10)\ny &lt;- runif(10)\nplot(x, y, lwd = 10)\n\n\n\n\n\n\n\n\nNext, we use approxfun() to construct the linear and constant interpolation functions for our x and y values.\n\nf_lin &lt;- approxfun(x, y)\nf_con &lt;- approxfun(x, y, method = \"constant\")\n\n# Both functions exactly reproduce their input y values\nidentical(f_lin(x), y)\n#&gt; [1] TRUE\nidentical(f_con(x), y)\n#&gt; [1] TRUE\n\nWhen we apply these functions to new x values, these are mapped to the lines connecting the initial y values (linear case) or to the same y value as for the next smallest initial x value (constant case).\n\nx_new &lt;- runif(1000)\n\nplot(x, y, lwd = 10)\npoints(x_new, f_lin(x_new), col = \"cornflowerblue\", pch = 16)\npoints(x_new, f_con(x_new), col = \"firebrick\", pch = 16)\n\n\n\n\n\n\n\n\nHowever, both functions are only defined within range(x).\n\nf_lin(range(x))\n#&gt; [1] 0.402 0.175\nf_con(range(x))\n#&gt; [1] 0.402 0.175\n\n(eps &lt;- .Machine$double.neg.eps)\n#&gt; [1] 1.11e-16\n\nf_lin(c(min(x) - eps, max(x) + eps))\n#&gt; [1] NA NA\nf_con(c(min(x) - eps, max(x) + eps))\n#&gt; [1] NA NA\n\nTo change this behaviour, one can set rule = 2. This leads to the result that for values outside of range(x) the boundary values of the function are returned.\n\nf_lin &lt;- approxfun(x, y, rule = 2)\nf_con &lt;- approxfun(x, y, method = \"constant\", rule = 2)\n\nf_lin(c(-Inf, Inf))\n#&gt; [1] 0.402 0.175\nf_con(c(-Inf, Inf))\n#&gt; [1] 0.402 0.175\n\nAnother option is to customise the return values as individual constants for each side via yleft and/or yright.\n\nf_lin &lt;- approxfun(x, y, yleft = 5)\nf_con &lt;- approxfun(x, y, method = \"constant\", yleft = 5, yright = -5)\n\nf_lin(c(-Inf, Inf))\n#&gt; [1]  5 NA\nf_con(c(-Inf, Inf))\n#&gt; [1]  5 -5\n\nFurther, approxfun() provides the option to shift the y values for method = \"constant\" between their left and right values. According to the documentation this indicates a compromise between left- and right-continuous steps.\n\nf_con &lt;- approxfun(x, y, method = \"constant\", f = .5)\n\nplot(x, y, lwd = 10)\npoints(x_new, f_con(x_new), pch = 16)\n\n\n\n\n\n\n\n\nFinally, the ties argument allows to aggregate y values if multiple ones were provided for the same x value. For example, in the following line we use mean() to aggregate these y values before they are used for the interpolation approxfun(x = c(1,1,2), y = 1:3, ties = mean).\nNext, we focus on ecdf(). “ecdf” is an acronym for empirical cumulative distribution function. For a numeric vector of density values, ecdf() initially creates the (x, y) pairs for the nodes of the density function and then passes these pairs to approxfun(), which gets called with specifically adapted settings (approxfun(vals, cumsum(tabulate(match(x, vals)))/n, method = \"constant\", yleft = 0, yright = 1, f = 0, ties = \"ordered\")).\n\nx &lt;- runif(10)\nf_ecdf &lt;- ecdf(x)\nclass(f_ecdf)\n#&gt; [1] \"ecdf\"     \"stepfun\"  \"function\"\n\nplot(x, f_ecdf(x), lwd = 10, ylim = 0:1)\n\n\n\n\n\n\n\n\nNew values are then mapped on the y value of the next smallest x value from within the initial input.\n\nx_new &lt;- runif(1000)\n\nplot(x, f_ecdf(x), lwd = 10, ylim = 0:1)\npoints(x_new, f_ecdf(x_new), ylim = 0:1)\n\n\n\n\n\n\n\n\nQ3: Create a function pick() that takes an index, i, as an argument and returns a function with an argument x that subsets x with i.\n\npick(1)(x)\n# should be equivalent to\nx[[1]]\n\nlapply(mtcars, pick(5))\n# should be equivalent to\nlapply(mtcars, function(x) x[[5]])\n\nA: In this exercise pick(i) acts as a function factory, which returns the required subsetting function.\n\npick &lt;- function(i) {\n  force(i)\n\n  function(x) x[[i]]\n}\n\nx &lt;- 1:3\nidentical(x[[1]], pick(1)(x))\n#&gt; [1] TRUE\nidentical(\n  lapply(mtcars, function(x) x[[5]]),\n  lapply(mtcars, pick(5))\n)\n#&gt; [1] TRUE\n\nQ4: Create a function that creates functions that compute the ith central moment of a numeric vector. You can test it by running the following code:\n\nm1 &lt;- moment(1)\nm2 &lt;- moment(2)\n\nx &lt;- runif(100)\nstopifnot(all.equal(m1(x), 0))\nstopifnot(all.equal(m2(x), var(x) * 99 / 100))\n\nA: The first moment is closely related to the mean and describes the average deviation from the mean, which is 0 (within numerical margin of error). The second moment describes the variance of the input data. If we want to compare it to var(), we need to undo Bessel’s correction by multiplying with \\(\\frac{N-1}{N}\\).\n\nmoment &lt;- function(i) {\n  force(i)\n\n  function(x) sum((x - mean(x))^i) / length(x)\n}\n\nm1 &lt;- moment(1)\nm2 &lt;- moment(2)\n\nx &lt;- runif(100)\nall.equal(m1(x), 0) # removed stopifnot() for clarity\n#&gt; [1] TRUE\nall.equal(m2(x), var(x) * 99 / 100)\n#&gt; [1] TRUE\n\nQ5: What happens if you don’t use a closure? Make predictions, then verify with the code below.\n\ni &lt;- 0\nnew_counter2 &lt;- function() {\n  i &lt;&lt;- i + 1\n  i\n}\n\nA: Without the captured and encapsulated environment of a closure the counts will be stored in the global environment. Here they can be overwritten or deleted as well as interfere with other counters.\n\nnew_counter2()\n#&gt; [1] 1\ni\n#&gt; [1] 1\nnew_counter2()\n#&gt; [1] 2\ni\n#&gt; [1] 2\n\ni &lt;- 0\nnew_counter2()\n#&gt; [1] 1\ni\n#&gt; [1] 1\n\nQ6: What happens if you use &lt;- instead of &lt;&lt;-? Make predictions, then verify with the code below.\n\nnew_counter3 &lt;- function() {\n  i &lt;- 0\n  function() {\n    i &lt;- i + 1\n    i\n  }\n}\n\nA: Without the super assignment &lt;&lt;-, the counter will always return 1. The counter always starts in a new execution environment within the same enclosing environment, which contains an unchanged value for i (in this case it remains 0).\n\nnew_counter_3 &lt;- new_counter3()\n\nnew_counter_3()\n#&gt; [1] 1\nnew_counter_3()\n#&gt; [1] 1"
  },
  {
    "objectID": "10_Function_factories.html#graphical-factories",
    "href": "10_Function_factories.html#graphical-factories",
    "title": "10 - Function factories",
    "section": "Graphical factories",
    "text": "Graphical factories\nQ1: Compare and contrast ggplot2::label_bquote() with scales::number_format().\nA: Both functions will help you in styling your output, e.g. in your plots and they do this by returning the desired formatting function to you.\nggplot2::label_bquote() takes relatively straightforward plotmath expressions and uses them for faceting labels in {ggplot2}. Because this function is used in {ggplot2} it needs to return a function of class = \"labeller\".\nscales::number_format() initially force()s the computation of all parameters. It’s essentially a parametrised wrapper around scales::number() and will help you format numbers appropriately. It will return a simple function."
  },
  {
    "objectID": "10_Function_factories.html#statistical-factories",
    "href": "10_Function_factories.html#statistical-factories",
    "title": "10 - Function factories",
    "section": "Statistical factories",
    "text": "Statistical factories\nQ1: In boot_model(), why don’t I need to force the evaluation of df or model?\nA: boot_model() ultimately returns a function, and whenever you return a function you need to make sure all the inputs are explicitly evaluated. Here that happens automatically because we use df and formula in lm() before returning the function.\n\nboot_model &lt;- function(df, formula) {\n  mod &lt;- lm(formula, data = df)\n  fitted &lt;- unname(fitted(mod))\n  resid &lt;- unname(resid(mod))\n  rm(mod)\n\n  function() {\n    fitted + sample(resid)\n  }\n}\n\nQ2: Why might you formulate the Box-Cox transformation like this?\n\nboxcox3 &lt;- function(x) {\n  function(lambda) {\n    if (lambda == 0) {\n      log(x)\n    } else {\n      (x^lambda - 1) / lambda\n    }\n  }\n}\n\nA: boxcox3() returns a function where x is fixed (though it is not forced, so it may be manipulated later). This allows us to apply and test different transformations for different inputs and give them a descriptive name.\n\nboxcox_airpassengers &lt;- boxcox3(AirPassengers)\n\nplot(boxcox_airpassengers(0))\nplot(boxcox_airpassengers(1))\nplot(boxcox_airpassengers(2))\nplot(boxcox_airpassengers(3))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQ3: Why don’t you need to worry that boot_permute() stores a copy of the data inside the function that it generates?\nA: boot_permute() is defined in Advanced R as:\n\nboot_permute &lt;- function(df, var) {\n  n &lt;- nrow(df)\n  force(var)\n\n  function() {\n    col &lt;- df[[var]]\n    col[sample(n, replace = TRUE)]\n  }\n}\n\nWe don’t need to worry that it stores a copy of the data, because it actually doesn’t store one; it’s just a name that points to the same underlying object in memory.\n\nboot_mtcars1 &lt;- boot_permute(mtcars, \"mpg\")\n\nlobstr::obj_size(mtcars)\n#&gt; 7.21 kB\nlobstr::obj_size(boot_mtcars1)\n#&gt; 20.18 kB\nlobstr::obj_sizes(mtcars, boot_mtcars1)\n#&gt; *  7.21 kB\n#&gt; * 12.97 kB\n\nQ4: How much time does ll_poisson2() save compared to ll_poisson1()? Use bench::mark() to see how much faster the optimisation occurs. How does changing the length of x change the results?\nA: Let us recall the definitions of ll_poisson1(), ll_poisson2() and the test data x1:\n\nll_poisson1 &lt;- function(x) {\n  n &lt;- length(x)\n\n  function(lambda) {\n    log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))\n  }\n}\n\nll_poisson2 &lt;- function(x) {\n  n &lt;- length(x)\n  sum_x &lt;- sum(x)\n  c &lt;- sum(lfactorial(x))\n\n  function(lambda) {\n    log(lambda) * sum_x - n * lambda - c\n  }\n}\n\nx1 &lt;- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)\n\nA benchmark on x1 reveals a performance improvement of factor 2 for ll_poisson2() over ll_poisson1():\n\nbench::mark(\n  llp1 = optimise(ll_poisson1(x1), c(0, 100), maximum = TRUE),\n  llp2 = optimise(ll_poisson2(x1), c(0, 100), maximum = TRUE)\n)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 llp1         19.2µs   25.1µs    37614.    12.9KB     33.9\n#&gt; 2 llp2         10.7µs     13µs    71319.        0B     35.7\n\nAs the redundant calculations within ll_poisson1() become more expensive with growing length of x1, we expect even further relative performance improvements for ll_poisson2(). The following benchmark reveals a relative performance improvement of factor 20 for ll_poisson2() when x1 is of length 100,000:\n\nbench_poisson &lt;- function(x_length) {\n  x &lt;- rpois(x_length, 100L)\n\n  bench::mark(\n    llp1 = optimise(ll_poisson1(x), c(0, 100), maximum = TRUE),\n    llp2 = optimise(ll_poisson2(x), c(0, 100), maximum = TRUE),\n    time_unit = \"ms\"\n  )\n}\n\nperformances &lt;- map_dfr(10^(1:5), bench_poisson)\n\ndf_perf &lt;- tibble(\n  x_length = rep(10^(1:5), each = 2),\n  method   = attr(performances$expression, \"description\"),\n  median   = performances$median\n)\n\nggplot(df_perf, aes(x_length, median, col = method)) +\n  geom_point(size = 2) +\n  geom_line(linetype = 2) +\n  scale_x_log10() +\n  labs(\n    x = \"Length of x\",\n    y = \"Execution Time (ms)\",\n    color = \"Method\"\n  ) +\n  theme(legend.position = \"top\")"
  },
  {
    "objectID": "10_Function_factories.html#function-factories-functionals",
    "href": "10_Function_factories.html#function-factories-functionals",
    "title": "10 - Function factories",
    "section": "Function factories + functionals",
    "text": "Function factories + functionals\nQ1: Which of the following commands is equivalent to with(x, f(z))?\n\nx$f(x$z).\nf(x$z).\nx$f(z).\nf(z).\nIt depends.\n\nA: (e) “It depends” is the correct answer. Usually with() is used with a data frame, so you’d usually expect (b), but if x is a list, it could be any of the options.\n\nf &lt;- mean\nz &lt;- 1\nx &lt;- list(f = mean, z = 1)\n\nidentical(with(x, f(z)), x$f(x$z))\n#&gt; [1] TRUE\nidentical(with(x, f(z)), f(x$z))\n#&gt; [1] TRUE\nidentical(with(x, f(z)), x$f(z))\n#&gt; [1] TRUE\nidentical(with(x, f(z)), f(z))\n#&gt; [1] TRUE\n\nQ2: Compare and contrast the effects of env_bind() vs. attach() for the following code.\n\nfuns &lt;- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n#&gt; The following objects are masked from package:base:\n#&gt; \n#&gt;     mean, sum\nmean &lt;- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean &lt;- function(x) stop(\"Hi!\")\nenv_unbind(globalenv(), names(funs))\n\nA: attach() adds funs to the search path. Therefore, the provided functions are found before their respective versions from the {base} package. Further, they cannot get accidentally overwritten by similar named functions in the global environment. One annoying downside of using attach() is the possibility to attach the same object multiple times, making it necessary to call detach() equally often.\n\nattach(funs)\n#&gt; The following objects are masked from package:base:\n#&gt; \n#&gt;     mean, sum\nattach(funs)\n#&gt; The following objects are masked from funs (pos = 3):\n#&gt; \n#&gt;     mean, sum\n#&gt; \n#&gt; The following objects are masked from package:base:\n#&gt; \n#&gt;     mean, sum\n\nhead(search())\n#&gt; [1] \".GlobalEnv\"      \"funs\"            \"funs\"            \"package:ggplot2\"\n#&gt; [5] \"package:purrr\"   \"package:dplyr\"\ndetach(funs)\ndetach(funs)\n\nIn contrast rlang::env_bind() just adds the functions in fun to the global environment. No further side effects are introduced, and the functions are overwritten when similarly named functions are defined.\n\nenv_bind(globalenv(), !!!funs)\nhead(search())\n#&gt; [1] \".GlobalEnv\"      \"package:ggplot2\" \"package:purrr\"   \"package:dplyr\"  \n#&gt; [5] \"package:rlang\"   \"package:stats\""
  },
  {
    "objectID": "10_Function_factories.html#references",
    "href": "10_Function_factories.html#references",
    "title": "10 - Function factories",
    "section": "References",
    "text": "References\n\n\n\n\nHenry, Lionel, and Hadley Wickham. 2020a. Purrr: Functional Programming Tools. https://github.com/tidyverse/purrr.\n\n\n———. 2020b. Rlang: Functions for Base Types and Core r and ’Tidyverse’ Features. https://github.com/r-lib/rlang.\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/.\n\n\nWickham, Hadley. 2016. Ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, Romain François, Lionel Henry, and Kirill Müller. 2020. Dplyr: A Grammar of Data Manipulation. https://github.com/tidyverse/dplyr."
  },
  {
    "objectID": "11_Function_operators.html#prerequisites",
    "href": "11_Function_operators.html#prerequisites",
    "title": "11 - Function operators",
    "section": "Prerequisites",
    "text": "Prerequisites\nAlso in the third chapter on functional programming, we make relatively frequent use of the {purrr} package.\n\nlibrary(purrr)"
  },
  {
    "objectID": "11_Function_operators.html#existing-function-operators",
    "href": "11_Function_operators.html#existing-function-operators",
    "title": "11 - Function operators",
    "section": "Existing function operators",
    "text": "Existing function operators\nQ1: Base R provides a function operator in the form of Vectorize(). What does it do? When might you use it?\nA: In R a lot of functions are “vectorised”. Vectorised has two meanings. First, it means (broadly) that a function inputs a vector or vectors and does something to each element. Secondly, it usually implies that these operations are implemented in a compiled language such as C or Fortran, so that the implementation is very fast.\nHowever, despite what the function’s name implies, Vectorize() is not able to speed up the provided function. It rather changes the input format of the supplied arguments (vectorize.args), so that they can be iterated over.\nLet’s take a look at an example from the documentation:\n\nvrep &lt;- Vectorize(rep.int)\nvrep\n#&gt; function (x, times)\n#&gt; {\n#&gt;   args &lt;- lapply(as.list(match.call())[-1L], eval, parent.frame())\n#&gt;   names &lt;- if (is.null(names(args)))\n#&gt;     character(length(args))\n#&gt;   else names(args)\n#&gt;   dovec &lt;- names %in% vectorize.args\n#&gt;   do.call(\"mapply\", c(FUN = FUN, args[dovec],\n#&gt;                       MoreArgs = list(args[!dovec]),\n#&gt;                       SIMPLIFY = SIMPLIFY, USE.NAMES = USE.NAMES))\n#&gt; }\n#&gt; &lt;environment: 0x558902db65d0&gt;\n\n\n\n# Application\nvrep(1:2, 3:4)\n#&gt; [[1]]\n#&gt; [1] 1 1 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2 2 2 2\n\nVectorize() provides a convenient and concise notation to iterate over multiple arguments but has some major drawbacks that mean you generally shouldn’t use it. See https://www.jimhester.com/post/2018-04-12-vectorize/ for more details.\nQ2: Read the source code for possibly(). How does it work?\nA: possibly() modifies functions to return a specified default value (otherwise) in case of an error and to suppress any error messages (quiet = TRUE).\nWhile reading the source code, we notice that possibly() internally uses purrr::as_mapper(). This enables users to supply not only functions, but also formulas or atomics via the same syntax as known from other functions in the {purrr} package. Besides this, the new default value (otherwise) gets evaluated once to make it (almost) immutable.\n\npossibly\n#&gt; function (.f, otherwise = NULL, quiet = TRUE) \n#&gt; {\n#&gt;     .f &lt;- as_mapper(.f)\n#&gt;     force(otherwise)\n#&gt;     check_bool(quiet)\n#&gt;     function(...) {\n#&gt;         tryCatch(.f(...), error = function(e) {\n#&gt;             if (!quiet) \n#&gt;                 message(\"Error: \", conditionMessage(e))\n#&gt;             otherwise\n#&gt;         })\n#&gt;     }\n#&gt; }\n#&gt; &lt;bytecode: 0x612763fdb428&gt;\n#&gt; &lt;environment: namespace:purrr&gt;\n\nThe main functionality of possibly() is provided by base::tryCatch(). In this part the supplied function (.f) gets wrapped and the error and interrupt handling are specified.\nQ3: Read the source code for safely(). How does it work?\nA: safely() modifies functions to return a list, containing the elements result and error. It works in a similar fashion as possibly() and besides using as_mapper(), safely() also provides the otherwise and quiet arguments. However, in order to provide the result and the error in a consistent way, the tryCatch() part of the implementation returns a list with similar structure for both cases. In the case of successful evaluation error equals NULL and in case of an error result equals otherwise, which is NULL by default.\nAs the tryCatch() part is hidden in the internal purrr:::capture_output() function, we provide it here in addition to safely():\n\nsafely\n#&gt; function (.f, otherwise = NULL, quiet = TRUE) \n#&gt; {\n#&gt;     .f &lt;- as_mapper(.f)\n#&gt;     force(otherwise)\n#&gt;     check_bool(quiet)\n#&gt;     function(...) capture_error(.f(...), otherwise, quiet)\n#&gt; }\n#&gt; &lt;bytecode: 0x6127643254f0&gt;\n#&gt; &lt;environment: namespace:purrr&gt;\n\npurrr:::capture_error\n#&gt; function (code, otherwise = NULL, quiet = TRUE) \n#&gt; {\n#&gt;     tryCatch(list(result = code, error = NULL), error = function(e) {\n#&gt;         if (!quiet) \n#&gt;             message(\"Error: \", conditionMessage(e))\n#&gt;         list(result = otherwise, error = e)\n#&gt;     })\n#&gt; }\n#&gt; &lt;bytecode: 0x6127643aebe8&gt;\n#&gt; &lt;environment: namespace:purrr&gt;\n\nTake a look at Advanced R or the documentation of safely() to see how you can take advantage of this behaviour, e.g. when fitting many models."
  },
  {
    "objectID": "11_Function_operators.html#case-study-creating-your-own-function-operators",
    "href": "11_Function_operators.html#case-study-creating-your-own-function-operators",
    "title": "11 - Function operators",
    "section": "Case study: Creating your own function operators",
    "text": "Case study: Creating your own function operators\nQ1: Weigh the pros and cons of download.file %&gt;% dot_every(10) %&gt;% delay_by(0.1) versus download.file %&gt;% delay_by(0.1) %&gt;% dot_every(10).\nA: Both commands will print a dot every 10 downloads and will take the same amount of time to run, so the differences may seem quite subtle.\nIn the first case, first the dot functionality is added to download.file(). Then the delay is added to this already tweaked function. This implies, that the printing of the dot will also be delayed, and the first dot will be printed as soon as the download for the 10th URL starts.\nIn the latter case the delay is added first and the dot-functionality is wrapped around it. This order will print the first dot immediately after the 9th download is finished, then the short delay occurs before the 10th download actually starts.\nQ2: Should you memoise file.download()? Why or why not?\nA: Memoising file.download() will only work if the files are immutable, i.e. if the file at a given URL is always the same. There’s no point memoising unless this is true. Even if this is true, however, memoise has to store the results in memory, and large files will potentially take up a lot of memory.\nThis implies that it’s probably not beneficial to memoise file.download() in most cases. The only exception is if you are downloading small files many times, and the file at a given URL is guaranteed not to change.\nQ3: Create a function operator that reports whenever a file is created or deleted in the working directory, using dir() and setdiff(). What other global function effects might you want to track?\nA: We start with a function that reports the difference between two vectors containing file names:\n\ndir_compare &lt;- function(old, new) {\n  if (setequal(old, new)) {\n    return()\n  }\n\n  added &lt;- setdiff(new, old)\n  removed &lt;- setdiff(old, new)\n\n  changes &lt;- c(\n    if (length(added) &gt; 0) paste0(\" * '\", added, \"' was added\"),\n    if (length(removed) &gt; 0) {\n      paste0(\n        \" * '\", removed,\n        \"' was removed\"\n      )\n    }\n  )\n  message(paste(changes, collapse = \"\\n\"))\n}\n\ndir_compare(c(\"x\", \"y\"), c(\"x\", \"y\"))\n#&gt; NULL\ndir_compare(c(\"x\", \"y\"), c(\"x\", \"a\"))\n#&gt;  * 'a' was added\n#&gt;  * 'y' was removed\n\nThen we wrap it up in a function operator\n\ntrack_dir &lt;- function(f) {\n  force(f)\n  function(...) {\n    dir_old &lt;- dir()\n    on.exit(dir_compare(dir_old, dir()), add = TRUE)\n\n    f(...)\n  }\n}\n\nAnd try it out by creating wrappers around file.create() and file.remove():\n\nfile_create &lt;- track_dir(file.create)\nfile_remove &lt;- track_dir(file.remove)\n\nfile_create(\"delete_me\")\n#&gt;  * 'delete_me' was added\n#&gt; [1] TRUE\nfile_remove(\"delete_me\")\n#&gt;  * 'delete_me' was removed\n#&gt; [1] TRUE\n\nTo create a more serious version of track_dir() one might provide optionality to set the full.names and recursive arguments of dir() to TRUE. This would enable to also track the creation/deletion of hidden files and files in folders contained in the working directory.\nOther global effects that might be worth tracking include changes regarding:\n\nthe search path and possibly introduced conflicts()\noptions() and par() which modify global settings\nthe path of the working directory\nenvironment variables\n\nQ4: Write a function operator that logs a timestamp and message to a file every time a function is run.\nA: Our logger() function operator takes a function and a file path as input. One timestamp is written to the file under log_path when we call logger() and another timestamp is written to the same file each time the new function gets called.\n\nappend_line &lt;- function(path, ...) {\n  cat(..., \"\\n\", sep = \"\", file = path, append = TRUE)\n}\n\nlogger &lt;- function(f, log_path) {\n  force(f)\n  force(log_path)\n\n  append_line(log_path, \"created at: \", as.character(Sys.time()))\n  function(...) {\n    append_line(log_path, \"called at: \", as.character(Sys.time()))\n    f(...)\n  }\n}\n\nNow, let’s check if our logger() works as intended and apply it to the mean() function:\n\nlog_path &lt;- tempfile()\nmean2 &lt;- logger(mean, log_path)\nSys.sleep(5)\nmean2(1:4)\n#&gt; [1] 2.5\nSys.sleep(1)\nmean2(1:4)\n#&gt; [1] 2.5\n\nreadLines(log_path)\n#&gt; [1] \"created at: 2024-01-24 11:45:37.692096\"\n#&gt; [2] \"called at: 2024-01-24 11:45:42.699738\" \n#&gt; [3] \"called at: 2024-01-24 11:45:43.703109\"\n\nQ5: Modify delay_by() so that instead of delaying by a fixed amount of time, it ensures that a certain amount of time has elapsed since the function was last called. That is, if you called g &lt;- delay_by(1, f); g(); Sys.sleep(2); g() there shouldn’t be an extra delay.\nA: delay_by() was defined in Advanced R as:\n\ndelay_by &lt;- function(f, amount) {\n  force(f)\n  force(amount)\n\n  function(...) {\n    Sys.sleep(amount)\n    f(...)\n  }\n}\n\nTo ensure that the function created by delay_by() waits that a certain amount of time has passed since its last execution, we incorporate three little changes into our new delay_atleast() as indicated in the corresponding comments below.\n\ndelay_atleast &lt;- function(amount, f) {\n  force(f)\n  force(amount)\n\n  # Store the last time the function was run\n  last_time &lt;- NULL\n\n  # Return modified \"delay-aware\" function\n  function(...) {\n    if (!is.null(last_time)) {\n      wait &lt;- (last_time - Sys.time()) + amount\n      if (wait &gt; 0) {\n        Sys.sleep(wait)\n      }\n    }\n\n    # Update the time after the function has finished\n    on.exit(last_time &lt;&lt;- Sys.time())\n\n    f(...)\n  }\n}"
  },
  {
    "objectID": "13_S3.html#prerequisites",
    "href": "13_S3.html#prerequisites",
    "title": "13 - S3",
    "section": "Prerequisites",
    "text": "Prerequisites\nTo interact with S3 objects, we will mainly use the {sloop} package (Wickham 2019).\n\nlibrary(sloop)"
  },
  {
    "objectID": "13_S3.html#basics",
    "href": "13_S3.html#basics",
    "title": "13 - S3",
    "section": "Basics",
    "text": "Basics\nQ1: Describe the difference between t.test() and t.data.frame()? When is each function called?\nA: Because of S3’s generic.class() naming scheme, both functions may initially look similar, while they are in fact unrelated.\n\nt.test() is a generic function that performs a t-test.\nt.data.frame() is a method that gets called by the generic t() to transpose data frame input.\n\nDue to R’s S3 dispatch rules, t.test() would also get called when t() is applied to an object of class test.\nQ2: Make a list of commonly used base R functions that contain . in their name but are not S3 methods.\nA: In recent years “snake_case”-style has become increasingly common when naming functions and variables in R. But many functions in base R will continue to be “point.separated”, which is why some inconsistency in your R code most likely cannot be avoided.(Bååth 2012)\n\n# Some base R functions with point.separated names\ninstall.packages()\nread.csv()\n\nlist.files()\ndownload.file()\n\ndata.frame()\nas.character()\nSys.Date()\n\nall.equal()\n\ndo.call()\non.exit()\n\nQ3: What does the as.data.frame.data.frame() method do? Why is it confusing? How could you avoid this confusion in your own code?\nA: The function as.data.frame.data.frame() implements the data.frame() method for the as.data.frame() generic, which coerces objects to data frames.\nThe name is confusing, because it does not clearly communicate the type of the function, which could be a regular function, a generic or a method. Even if we assume a method, the amount of .’s makes it difficult to separate the generic- and the class-part of the name. Is it the data.frame.data.frame() method for the as() generic? Is it the frame.data.frame() method for the as.data() generic?\nWe could avoid this confusion by applying a different naming convention (e.g. “snake_case”) for our class and function names.\nQ4: Describe the difference in behaviour in these two calls.\n\nsome_days &lt;- as.Date(\"2017-01-31\") + sample(10, 5)\n\nmean(some_days)\n#&gt; [1] \"2017-02-06\"\nmean(unclass(some_days))\n#&gt; [1] 17203\n\nA: mean() is a generic function, which will select the appropriate method based on the class of the input. some_days has the class Date and mean.Date(some_days) will be used to calculate the mean date of some_days.\nAfter unclass() has removed the class attribute from some_date, the default method is chosen. mean.default(unclass(some_days)) then calculates the mean of the underlying double.\nQ5: What class of object does the following code return? What base type is it built on? What attributes does it use?\n\nx &lt;- ecdf(rpois(100, 10))\nx\n#&gt; Empirical CDF \n#&gt; Call: ecdf(rpois(100, 10))\n#&gt;  x[1:18] =  2,  3,  4,  ..., 2e+01, 2e+01\n\nA: It returns an object of the class ecdf (empirical cumulative distribution function) with the superclasses stepfun and function. The ecdf object is built on the base type closure (a function). The expression, which was used to create it (rpois(100, 10)), is stored in the call attribute.\n\ntypeof(x)\n#&gt; [1] \"closure\"\n\nattributes(x)\n#&gt; $class\n#&gt; [1] \"ecdf\"     \"stepfun\"  \"function\"\n#&gt; \n#&gt; $call\n#&gt; ecdf(rpois(100, 10))\n\nQ6: What class of object does the following code return? What base type is it built on? What attributes does it use?\n\nx &lt;- table(rpois(100, 5))\nx\n#&gt; \n#&gt;  1  2  3  4  5  6  7  8  9 10 \n#&gt;  7  5 18 14 15 15 14  4  5  3\n\nA: This code returns a table object, which is built upon the integer type. The attribute dimnames is used to name the elements of the integer vector.\n\ntypeof(x)\n#&gt; [1] \"integer\"\n\nattributes(x)\n#&gt; $dim\n#&gt; [1] 10\n#&gt; \n#&gt; $dimnames\n#&gt; $dimnames[[1]]\n#&gt;  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\n#&gt; \n#&gt; \n#&gt; $class\n#&gt; [1] \"table\""
  },
  {
    "objectID": "13_S3.html#classes",
    "href": "13_S3.html#classes",
    "title": "13 - S3",
    "section": "Classes",
    "text": "Classes\nQ1: Write a constructor for data.frame objects. What base type is a data frame built on? What attributes does it use? What are the restrictions placed on the individual elements? What about the names?\nA: Data frames are built on named lists of vectors, which all have the same length. Besides the class and the column names (names), the row.names are their only further attribute. This must be a character vector with the same length as the other vectors.\nWe need to provide the number of rows as an input to make it possible to create data frames with 0 columns but multiple rows.\nThis leads to the following constructor:\n\nnew_data.frame &lt;- function(x, n, row.names = NULL) {\n  # Check if the underlying object is a list\n  stopifnot(is.list(x))\n  \n  # Check all inputs are the same length\n  # (This check also allows that x has length 0)\n  stopifnot(all(lengths(x) == n))\n  \n  if (is.null(row.names)) {\n    # Use special row names helper from base R\n    row.names &lt;- .set_row_names(n)\n  } else {\n    # Otherwise check that they're a character vector with the \n    # correct length\n    stopifnot(is.character(row.names), length(row.names) == n)\n  }\n  \n  structure(\n    x,\n    class = \"data.frame\",\n    row.names = row.names\n  )\n}\n\n# Test\nx &lt;- list(a = 1, b = 2)\nnew_data.frame(x, n = 1)\n#&gt;   a b\n#&gt; 1 1 2\nnew_data.frame(x, n = 1, row.names = \"l1\")\n#&gt;    a b\n#&gt; l1 1 2\n\n# Create a data frame with 0 columns and 2 rows\nnew_data.frame(list(), n = 2)\n#&gt; data frame with 0 columns and 2 rows\n\nThere are two additional restrictions we could implement if we were being very strict: both the row names and column names should be unique.\nQ2: Enhance my factor() helper to have better behaviour when one or more values is not found in levels. What does base::factor() do in this situation?\nA: base::factor() converts these values (silently) into NAs:\n\nfactor(c(\"a\", \"b\", \"c\"), levels = c(\"a\", \"b\"))\n#&gt; [1] a    b    &lt;NA&gt;\n#&gt; Levels: a b\n\nThe factor() helper including the constructor (new_factor()) and its validator (validate_factor()) were given in Advanced R. However, as the goal of this question is to throw an early error within the helper, we only repeat the code for the helper:\n\n# Simplified version of the factor() helper, as defined in Advanced R\nfactor &lt;- function(x = character(), levels = unique(x)) {\n  ind &lt;- match(x, levels)\n  validate_factor(new_factor(ind, levels))\n}\n\nTo improve the factor() helper we choose to return an informative error message instead.\n\nfactor2 &lt;- function(x, levels = unique(x)) {\n  new_levels &lt;- match(x, levels)\n  \n  # Error if levels don't include all values\n  missing &lt;- unique(setdiff(x, levels))\n  if (length(missing) &gt; 0) {\n    stop(\n      \"The following values do not occur in the levels of x: \",\n      paste0(\"'\", missing, \"'\", collapse = \", \"), \".\", \n      call. = FALSE\n    )\n  }\n  \n  validate_factor(new_factor(new_levels, levels))\n}\n\n# Test\nfactor2(c(\"a\", \"b\", \"c\"), levels = c(\"a\", \"b\"))\n#&gt; Error: The following values do not occur in the levels of x: 'c'.\n\nQ3: Carefully read the source code of factor(). What does it do that our constructor does not?\nA: The original implementation (base::factor()) allows more flexible input for x. It coerces x to character or replaces it with character(0) (in case of NULL). It also ensures that the levels are unique. This is achieved by setting them via base::levels&lt;-, which fails when duplicate values are supplied.\nQ4: Factors have an optional “contrasts” attribute. Read the help for C(), and briefly describe the purpose of the attribute. What type should it have? Rewrite the new_factor() constructor to include this attribute.\nA: When factor variables (representing nominal or ordinal information) are used in statistical models, they are typically encoded as dummy variables and by default each level is compared with the first factor level. However, many different encodings (“contrasts”) are possible, see https://en.wikipedia.org/wiki/Contrast_(statistics).\nWithin R’s formula interface you can wrap a factor in stats::C() and specify the contrast of your choice. Alternatively, you can set the contrasts attribute of your factor variable, which accepts matrix input. (See ?contr.helmert or similar for details.)\nThe new_factor() constructor was given in Advanced R as:\n\n# new_factor() constructor from Advanced R\nnew_factor &lt;- function(x = integer(), levels = character()) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\n\nOur updated new_factor() constructor gets a contrasts argument, which accepts a numeric matrix or NULL (default).\n\n# Updated new_factor() constructor\nnew_factor &lt;- function(\n  x = integer(),\n  levels = character(),\n  contrasts = NULL\n) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n  \n  if (!is.null(constrasts)) {\n    stopifnot(is.matrix(contrasts) && is.numeric(contrasts))\n  }\n  \n  structure(\n    x,\n    levels = levels,\n    class = \"factor\",\n    contrasts = contrasts\n  )\n}\n\nQ5: Read the documentation for utils::as.roman(). How would you write a constructor for this class? Does it need a validator? What might a helper do?\nA: This function transforms numeric input into Roman numbers. It is built on the integer type, which results in the following constructor.\n\nnew_roman &lt;- function(x = integer()) {\n  stopifnot(is.integer(x))\n  structure(x, class = \"roman\")\n}\n\nThe documentation tells us, that only values between 1 and 3899 are uniquely represented, which we then include in our validation function.\n\nvalidate_roman &lt;- function(x) {\n  values &lt;- unclass(x)\n  \n  if (any(values &lt; 1 | values &gt; 3899)) {\n    stop(\n      \"Roman numbers must fall between 1 and 3899.\",\n      call. = FALSE\n    )\n  }\n  \n  x\n}\n\nFor convenience, we allow the user to also pass real values to a helper function.\n\nroman &lt;- function(x = integer()) {\n  x &lt;- as.integer(x)\n  \n  validate_roman(new_roman(x))\n}\n\n# Test\nroman(c(1, 753, 2019))\n#&gt; [1] I       DCCLIII MMXIX\nroman(0)\n#&gt; Error: Roman numbers must fall between 1 and 3899."
  },
  {
    "objectID": "13_S3.html#generics-and-methods",
    "href": "13_S3.html#generics-and-methods",
    "title": "13 - S3",
    "section": "Generics and methods",
    "text": "Generics and methods\nQ1: Read the source code for t() and t.test() and confirm that t.test() is an S3 generic and not an S3 method. What happens if you create an object with class test and call t() with it? Why?\n\nx &lt;- structure(1:10, class = \"test\")\nt(x)\n\nA: We can see that t.test() is a generic because it calls UseMethod():\n\nt.test\n#&gt; function (x, ...) \n#&gt; UseMethod(\"t.test\")\n#&gt; &lt;bytecode: 0x580b4c5c2f68&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\n# or simply call\nftype(t.test)\n#&gt; [1] \"S3\"      \"generic\"\n\n# The same holds for t()\nt\n#&gt; function (x) \n#&gt; UseMethod(\"t\")\n#&gt; &lt;bytecode: 0x580b4ce1f4f8&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nInterestingly, R also provides helpers, which list functions that look like methods, but in fact are not:\n\ntools::nonS3methods(\"stats\")\n#&gt; [1] \"anova.lmlist\"        \"expand.model.frame\"  \"fitted.values\"      \n#&gt; [4] \"influence.measures\"  \"lag.plot\"            \"t.test\"             \n#&gt; [7] \"plot.spec.phase\"     \"plot.spec.coherency\"\n\nWhen we create an object with class test, t() dispatches to the t.default() method. This happens, because UseMethod() simply searches for functions named paste0(\"generic\", \".\", c(class(x), \"default\")).\n\nx &lt;- structure(1:10, class = \"test\")\n\nt(x)\n#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#&gt; [1,]    1    2    3    4    5    6    7    8    9    10\n#&gt; attr(,\"class\")\n#&gt; [1] \"test\"\n\nHowever, in older versions of R (pre R 4.0.0; when Advanced R was written) this behaviour was slightly different. Instead of dispatching to the t.default() method, the t.test() generic was erroneously treated as a method of t() which then dispatched to t.test.default() or (when defined) to t.test.test().\n\n# Output in R version 3.6.2\nx &lt;- structure(1:10, class = \"test\")\nt(x)\n#&gt;\n#&gt;  One Sample t-test\n#&gt;\n#&gt; data:  x\n#&gt; t = 5.7446, df = 9, p-value = 0.0002782\n#&gt; alternative hypothesis: true mean is not equal to 0\n#&gt; 95 percent confidence interval:\n#&gt;  3.334149 7.665851\n#&gt; sample estimates:\n#&gt; mean of x \n#&gt;       5.5 \n\nt.test.test &lt;- function(x) \"Hi!\"\nt(x)\n#&gt;[1] \"Hi!\"\n\nQ2: What generics does the table class have methods for?\nA: This is a simple application of sloop::s3_methods_class():\n\ns3_methods_class(\"table\")\n#&gt; # A tibble: 10 × 4\n#&gt;    generic       class visible source             \n#&gt;    &lt;chr&gt;         &lt;chr&gt; &lt;lgl&gt;   &lt;chr&gt;              \n#&gt;  1 [             table TRUE    base               \n#&gt;  2 aperm         table TRUE    base               \n#&gt;  3 as.data.frame table TRUE    base               \n#&gt;  4 Axis          table FALSE   registered S3method\n#&gt;  5 lines         table FALSE   registered S3method\n#&gt;  6 plot          table FALSE   registered S3method\n#&gt;  7 points        table FALSE   registered S3method\n#&gt;  8 print         table TRUE    base               \n#&gt;  9 summary       table TRUE    base               \n#&gt; 10 tail          table FALSE   registered S3method\n\nInterestingly, the table class has a number of methods designed to help plotting with base graphics.\n\nx &lt;- rpois(100, 5)\nplot(table(x))\n\n\n\n\n\n\n\n\nQ3: What generics does the ecdf class have methods for?\nA: We use the same approach as above:\n\ns3_methods_class(\"ecdf\")\n#&gt; # A tibble: 4 × 4\n#&gt;   generic  class visible source             \n#&gt;   &lt;chr&gt;    &lt;chr&gt; &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 plot     ecdf  TRUE    stats              \n#&gt; 2 print    ecdf  FALSE   registered S3method\n#&gt; 3 quantile ecdf  FALSE   registered S3method\n#&gt; 4 summary  ecdf  FALSE   registered S3method\n\nThe methods are primarily designed for display (plot(), print(), summary()), but you can also extract quantiles with quantile().\nQ4: Which base generic has the greatest number of defined methods?\nA: A little experimentation (and thinking about the most popular functions) suggests that the print() generic has the most defined methods.\n\nnrow(s3_methods_generic(\"print\"))\n#&gt; [1] 310\nnrow(s3_methods_generic(\"summary\"))\n#&gt; [1] 41\nnrow(s3_methods_generic(\"plot\"))\n#&gt; [1] 34\n\nLet’s verify this programmatically with the tools we have learned in this and the previous chapters.\n\nlibrary(purrr)\n\nls(all.names = TRUE, env = baseenv()) %&gt;% \n  mget(envir = baseenv()) %&gt;% \n  keep(is_function) %&gt;% \n  names() %&gt;% \n  keep(is_s3_generic) %&gt;% \n  map(~ set_names(nrow(s3_methods_generic(.x)), .x)) %&gt;% \n  flatten_int() %&gt;% \n  sort(decreasing = TRUE) %&gt;% \n  head()\n#&gt;        print       format            [ as.character      summary         plot \n#&gt;          310          146           59           46           41           34\n\nQ5: Carefully read the documentation for UseMethod() and explain why the following code returns the results that it does. What two usual rules of function evaluation does UseMethod() violate?\n\ng &lt;- function(x) {\n  x &lt;- 10\n  y &lt;- 10\n  UseMethod(\"g\")\n}\ng.default &lt;- function(x) c(x = x, y = y)\n\nx &lt;- 1\ny &lt;- 1\ng(x)\n#&gt;  x  y \n#&gt;  1 10\n\nA: Let’s take this step by step. If you call g.default(x) directly you get c(1, 1) as you might expect.\nThe value bound to x comes from the argument, the value from y comes from the global environment.\n\ng.default(x)\n#&gt; x y \n#&gt; 1 1\n\nBut when we call g(x) we get c(1, 10):\n\ng(x)\n#&gt;  x  y \n#&gt;  1 10\n\nThis is seemingly inconsistent: why does x come from the value defined inside of g(), and y still come from the global environment? It’s because UseMethod() calls g.default() in a special way so that variables defined inside the generic are available to methods. The exception are arguments supplied to the function: they are passed on as is and cannot be affected by code inside the generic.\nQ6: What are the arguments to [? Why is this a hard question to answer?\nA: The subsetting operator [ is a primitive and a generic function, which can be confirmed via ftype().\n\nftype(`[`)\n#&gt; [1] \"primitive\" \"generic\"\n\nFor primitive functions formals([) returns NULL so we need to find another way to determine the functions arguments. One possible way to figure out [’s arguments would be to inspect the underlying C source code, which can be searched for via pryr::show_c_source(.Primitive(\"[\")).\nWhen we inspect the arguments of some of [’s methods, we see that the arguments vary with the class of x.\n\nnames(formals(`[.data.frame`))\n#&gt; [1] \"x\"    \"i\"    \"j\"    \"drop\"\nnames(formals(`[.table`))\n#&gt; [1] \"x\"    \"i\"    \"j\"    \"...\"  \"drop\"\nnames(formals(`[.Date`))\n#&gt; [1] \"x\"    \"...\"  \"drop\"\nnames(formals(`[.AsIs`))\n#&gt; [1] \"x\"   \"i\"   \"...\"\n\nTo finally get a better overview, we have to put in a little more effort and also use s3_methods_generic() again.\n\nlibrary(dplyr)\n\ns3_methods_generic(\"[\") %&gt;%\n  filter(visible) %&gt;%\n  mutate(\n    method = paste0(\"[.\", class),\n    argnames = purrr::map(method, ~ names(formals(.x))),\n    args = purrr::map(method, ~ formals(.x)),\n    args = purrr::map2(\n      argnames, args,\n      ~ paste(.x, .y, sep = \" = \")\n    ),\n    args = purrr::set_names(args, method)\n  ) %&gt;%\n  pull(args) %&gt;%\n  head()\n#&gt; $`[.AsIs`\n#&gt; [1] \"x = \"   \"i = \"   \"... = \"\n#&gt; \n#&gt; $`[.data.frame`\n#&gt; [1] \"x = \"                                              \n#&gt; [2] \"i = \"                                              \n#&gt; [3] \"j = \"                                              \n#&gt; [4] \"drop = if (missing(i)) TRUE else length(cols) == 1\"\n#&gt; \n#&gt; $`[.Date`\n#&gt; [1] \"x = \"        \"... = \"      \"drop = TRUE\"\n#&gt; \n#&gt; $`[.difftime`\n#&gt; [1] \"x = \"        \"... = \"      \"drop = TRUE\"\n#&gt; \n#&gt; $`[.Dlist`\n#&gt; [1] \"x = \"   \"i = \"   \"... = \"\n#&gt; \n#&gt; $`[.DLLInfoList`\n#&gt; [1] \"x = \"   \"... = \""
  },
  {
    "objectID": "13_S3.html#object-styles",
    "href": "13_S3.html#object-styles",
    "title": "13 - S3",
    "section": "Object styles",
    "text": "Object styles\nQ1: Categorise the objects returned by lm(), factor(), table(), as.Date(), as.POSIXct(), ecdf(), ordered(), I() into the styles described above.\nA: We can categorise the return values into the various object styles by observing how the number of observations is calculated: For vector style classes, length(x) represents the number of observations. Record style objects use a list of equal length elements to represent individual components. For data frames and matrices, the observations are represented by the rows. Scalar style objects use a list to represent a single thing.\nThis leads us to:\n\nVector object-style: factor(), table(), as.Date(), as.POSIXct(), ordered()\nRecord object-style: not observed\nData frame object-style: not observed\nScalar object-style: lm(), ecdf()\n\nThe object style of I() depends on the input since this function returns a “copy of the object with class AsIs prepended to the class(es)”.\nQ2: What would a constructor function for lm objects, new_lm(), look like? Use ?lm and experimentation to figure out the required fields and their types.\nA: The constructor needs to populate the attributes of an lm object and check their types for correctness. Let’s start by creating a simple lm object and explore its underlying base type and attributes:\n\nmod &lt;- lm(cyl ~ ., data = mtcars)\n\ntypeof(mod)\n#&gt; [1] \"list\"\n\nattributes(mod)\n#&gt; $names\n#&gt;  [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n#&gt;  [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n#&gt;  [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n#&gt; \n#&gt; $class\n#&gt; [1] \"lm\"\n\nAs mod is built upon a list, we can simply use map(mod, typeof) to find out the base types of its elements. (Additionally, we inspect ?lm, to learn more about the individual attributes.)\n\nmap_chr(mod, typeof)\n#&gt;  coefficients     residuals       effects          rank fitted.values \n#&gt;      \"double\"      \"double\"      \"double\"     \"integer\"      \"double\" \n#&gt;        assign            qr   df.residual       xlevels          call \n#&gt;     \"integer\"        \"list\"     \"integer\"        \"list\"    \"language\" \n#&gt;         terms         model \n#&gt;    \"language\"        \"list\"\n\nNow we should have enough information to write a constructor for new lm objects.\n\nnew_lm &lt;- function(\n  coefficients, residuals, effects, rank, fitted.values, assign,\n  qr, df.residual, xlevels, call, terms, model\n) {\n  \n  stopifnot(\n    is.double(coefficients), is.double(residuals), \n    is.double(effects), is.integer(rank), is.double(fitted.values),\n    is.integer(assign), is.list(qr), is.integer(df.residual),\n    is.list(xlevels), is.language(call), is.language(terms),\n    is.list(model)\n  )\n  \n  structure(\n    list(\n      coefficients = coefficients,\n      residuals = residuals,\n      effects = effects,\n      rank = rank, \n      fitted.values = fitted.values,\n      assign = assign,\n      qr = qr,\n      df.residual = df.residual,\n      xlevels = xlevels,\n      call = call,\n      terms = terms, \n      model = model\n    ),\n    class = \"lm\"\n  )\n}"
  },
  {
    "objectID": "13_S3.html#inheritance",
    "href": "13_S3.html#inheritance",
    "title": "13 - S3",
    "section": "Inheritance",
    "text": "Inheritance\nQ1: How does [.Date support subclasses? How does it fail to support subclasses?\nA: [.Date calls .Date with the result of calling [ on the parent class, along with oldClass():\n\n`[.Date`\n#&gt; function (x, ..., drop = TRUE) \n#&gt; {\n#&gt;     .Date(NextMethod(\"[\"), oldClass(x))\n#&gt; }\n#&gt; &lt;bytecode: 0x580b4c38d620&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n.Date is kind of like a constructor for date classes, although it doesn’t check the input is the correct type:\n\n.Date\n#&gt; function (xx, cl = \"Date\") \n#&gt; `class&lt;-`(xx, cl)\n#&gt; &lt;bytecode: 0x580b4fb47758&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\noldClass() is basically the same as class(), except that it doesn’t return implicit classes, i.e. it’s basically attr(x, \"class\") (looking at the C code that’s exactly what it does, except that it also handles S4 objects).\nAs oldClass() is “basically” class(), we can rewrite [.Date to make the implementation more clear:\n\n`[.Date` &lt;- function(x, ..., drop = TRUE) {\n  out &lt;- NextMethod(\"[\")\n  class(out) &lt;- class(x)\n  out\n}\n\nSo, [.Date ensures that the output has the same class as in the input. But what about other attributes that a subclass might possess? They get lost:\n\nx &lt;- structure(1:4, test = \"test\", class = c(\"myDate\", \"Date\"))\nattributes(x[1])\n#&gt; $class\n#&gt; [1] \"myDate\" \"Date\"\n\nQ2: R has two classes for representing date time data, POSIXct and POSIXlt, which both inherit from POSIXt. Which generics have different behaviours for the two classes? Which generics share the same behaviour?\nA: To answer this question, we have to get the respective generics\n\ngenerics_t  &lt;- s3_methods_class(\"POSIXt\")$generic\ngenerics_ct &lt;- s3_methods_class(\"POSIXct\")$generic\ngenerics_lt &lt;- s3_methods_class(\"POSIXlt\")$generic\n\nThe generics in generics_t with a method for the superclass POSIXt potentially share the same behaviour for both subclasses. However, if a generic has a specific method for one of the subclasses, it has to be subtracted:\n\n# These generics provide subclass-specific methods\nunion(generics_ct, generics_lt)\n#&gt;  [1] \"[\"             \"[[\"            \"[&lt;-\"           \"as.data.frame\"\n#&gt;  [5] \"as.Date\"       \"as.list\"       \"as.POSIXlt\"    \"c\"            \n#&gt;  [9] \"format\"        \"length&lt;-\"      \"mean\"          \"print\"        \n#&gt; [13] \"rep\"           \"split\"         \"summary\"       \"Summary\"      \n#&gt; [17] \"weighted.mean\" \"xtfrm\"         \"[[&lt;-\"          \"$&lt;-\"          \n#&gt; [21] \"anyNA\"         \"as.double\"     \"as.matrix\"     \"as.POSIXct\"   \n#&gt; [25] \"as.vector\"     \"duplicated\"    \"is.finite\"     \"is.infinite\"  \n#&gt; [29] \"is.na\"         \"is.nan\"        \"length\"        \"names\"        \n#&gt; [33] \"names&lt;-\"       \"sort\"          \"unique\"\n\n# These generics share (inherited) methods for both subclasses\nsetdiff(generics_t, union(generics_ct, generics_lt))\n#&gt;  [1] \"-\"            \"+\"            \"all.equal\"    \"as.character\" \"Axis\"        \n#&gt;  [6] \"cut\"          \"diff\"         \"hist\"         \"is.numeric\"   \"julian\"      \n#&gt; [11] \"Math\"         \"months\"       \"Ops\"          \"pretty\"       \"quantile\"    \n#&gt; [16] \"quarters\"     \"round\"        \"seq\"          \"str\"          \"trunc\"       \n#&gt; [21] \"weekdays\"\n\nQ3: What do you expect this code to return? What does it actually return? Why?\n\ngeneric2 &lt;- function(x) UseMethod(\"generic2\")\ngeneric2.a1 &lt;- function(x) \"a1\"\ngeneric2.a2 &lt;- function(x) \"a2\"\ngeneric2.b &lt;- function(x) {\n  class(x) &lt;- \"a1\"\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n\nA: When we execute the code above, this is what is happening:\n\nwe pass an object of classes b and a2 to generic2(), which prompts R to look for a methodgeneric2.b()\nthe method generic2.b() then changes the class to a1 and calls NextMethod()\nOne would think that this will lead R to call generic2.a1(), but in fact, as mentioned in Advanced R, NextMethod()\n\ndoesn’t actually work with the class attribute of the object, but instead uses a special global variable (.Class) to keep track of which method to call next.\n\nThis is why generic2.a2() is called instead.\n::: {.cell layout-align=“center” hash=‘13_S3_cache/html/ch13_44_8c6cf6f696f18f5dcc4121e7c3e7a7f2’}\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n#&gt; [1] \"a2\"\n:::\n\nLet’s just double check the statement above and evaluate .Class explicitly within the generic2.b() method.\n\ngeneric2.b &lt;- function(x) {\n  class(x) &lt;- \"a1\"\n  print(.Class)\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n#&gt; [1] \"b\"  \"a2\"\n#&gt; [1] \"a2\""
  },
  {
    "objectID": "13_S3.html#dispatch-details",
    "href": "13_S3.html#dispatch-details",
    "title": "13 - S3",
    "section": "Dispatch details",
    "text": "Dispatch details\nQ1: Explain the differences in dispatch below:\n\nlength.integer &lt;- function(x) 10\n\nx1 &lt;- 1:5\nclass(x1)\n#&gt; [1] \"integer\"\ns3_dispatch(length(x1))\n#&gt;  * length.integer\n#&gt;    length.numeric\n#&gt;    length.default\n#&gt; =&gt; length (internal)\n\nx2 &lt;- structure(x1, class = \"integer\")\nclass(x2)\n#&gt; [1] \"integer\"\ns3_dispatch(length(x2))\n#&gt; =&gt; length.integer\n#&gt;    length.default\n#&gt;  * length (internal)\n\nA: class() returns integer in both cases. However, while the class of x1 is created implicitly and inherits from the numeric class, the class of x2 is set explicitly. This is important because length() is an internal generic and internal generics only dispatch to methods when the class attribute has been set, i.e. internal generics do not use implicit classes.\nAn object has no explicit class if attr(x, \"class\") returns NULL:\n\nattr(x1, \"class\")\n#&gt; NULL\nattr(x2, \"class\")\n#&gt; [1] \"integer\"\n\nTo see the relevant classes for the S3 dispatch, one can use sloop::s3_class():\n\ns3_class(x1)  # implicit\n#&gt; [1] \"integer\" \"numeric\"\n\ns3_class(x2)  # explicit\n#&gt; [1] \"integer\"\n\nFor a better understanding of s3_dipatch()’s output we quote from ?s3_dispatch:\n\n=&gt; method exists and is found by UseMethod().\n-&gt; method exists and is used by NextMethod().\n* method exists but is not used.\nNothing (and greyed out in console): method does not exist.\n\nQ2: What classes have a method for the Math() group generic in base R? Read the source code. How do the methods work?\nA: The following functions belong to this group (see ?Math):\n\nabs, sign, sqrt, floor, ceiling, trunc, round, signif\nexp, log, expm1, log1p, cos, sin, tan, cospi, sinpi, tanpi, acos, asin, atan, cosh, sinh, tanh, acosh, asinh, atanh\nlgamma, gamma, digamma, trigamma\ncumsum, cumprod, cummax, cummin\n\nThe following classes have a method for this group generic:\n\ns3_methods_generic(\"Math\")\n#&gt; # A tibble: 8 × 4\n#&gt;   generic class      visible source             \n#&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 Math    data.frame TRUE    base               \n#&gt; 2 Math    Date       TRUE    base               \n#&gt; 3 Math    difftime   TRUE    base               \n#&gt; 4 Math    factor     TRUE    base               \n#&gt; 5 Math    POSIXt     TRUE    base               \n#&gt; 6 Math    quosure    FALSE   registered S3method\n#&gt; 7 Math    vctrs_sclr FALSE   registered S3method\n#&gt; 8 Math    vctrs_vctr FALSE   registered S3method\n\nTo explain the basic idea, we just overwrite the data frame method:\n\nMath.data.frame &lt;- function(x) \"hello\"\n\nNow all functions from the math generic group, will return \"hello\"\n\nabs(mtcars)\n#&gt; [1] \"hello\"\nexp(mtcars)\n#&gt; [1] \"hello\"\nlgamma(mtcars)\n#&gt; [1] \"hello\"\n\nOf course, different functions should perform different calculations. Here .Generic comes into play, which provides us with the calling generic as a string\n\nMath.data.frame &lt;- function(x, ...) {\n  .Generic\n}\n\nabs(mtcars)\n#&gt; [1] \"abs\"\nexp(mtcars)\n#&gt; [1] \"exp\"\nlgamma(mtcars)\n#&gt; [1] \"lgamma\"\n\nrm(Math.data.frame)\n\nThe original source code of Math.data.frame() is a good example on how to invoke the string returned by .Generic into a specific method. Math.factor() is a good example of a method, which is simply defined for better error messages.\nQ3: Math.difftime() is more complicated than I described. Why?\nA: Math.difftime() also excludes cases apart from abs, sign, floor, ceiling, trunc, round and signif and needs to return a fitting error message.\nFor comparison: Math.difftime() as defined in Advanced R:\n\nMath.difftime &lt;- function(x, ...) {\n  new_difftime(NextMethod(), units = attr(x, \"units\"))\n}\nrm(Math.difftime)\n\nMath.difftime() as defined in the {base} package:\n\nMath.difftime\n#&gt; function (x, ...) \n#&gt; {\n#&gt;     switch(.Generic, abs = , sign = , floor = , ceiling = , trunc = , \n#&gt;         round = , signif = {\n#&gt;             units &lt;- attr(x, \"units\")\n#&gt;             .difftime(NextMethod(), units)\n#&gt;         }, stop(gettextf(\"'%s' not defined for \\\"difftime\\\" objects\", \n#&gt;             .Generic), domain = NA))\n#&gt; }\n#&gt; &lt;bytecode: 0x580b4d8f7740&gt;\n#&gt; &lt;environment: namespace:base&gt;"
  },
  {
    "objectID": "13_S3.html#references",
    "href": "13_S3.html#references",
    "title": "13 - S3",
    "section": "References",
    "text": "References\n\n\n\n\nBååth, Rasmus. 2012. “The State of Naming Conventions in r.” The R Journal 4 (2): 74–75. https://doi.org/10.32614/RJ-2012-018.\n\n\nWickham, Hadley. 2019. Sloop: Helpers for ’OOP’ in r. https://github.com/r-lib/sloop."
  },
  {
    "objectID": "14_R6.html#prerequisites",
    "href": "14_R6.html#prerequisites",
    "title": "14 - R6",
    "section": "Prerequisites",
    "text": "Prerequisites\nTo solve the exercises in this chapter we will have to create R6 objects, which are implemented in the {R6} package (Chang 2020).\n\nlibrary(R6)"
  },
  {
    "objectID": "14_R6.html#classes-and-methods",
    "href": "14_R6.html#classes-and-methods",
    "title": "14 - R6",
    "section": "Classes and methods",
    "text": "Classes and methods\nQ1: Create a bank account R6 class that stores a balance and allows you to deposit and withdraw money. Create a subclass that throws an error if you attempt to go into overdraft. Create another subclass that allows you to go into overdraft, but charges you a fee.\nA: Let’s start with a basic bank account, similar to the Accumulator class in Advanced R.\n\nBankAccount &lt;- R6Class(\n  classname = \"BankAccount\",\n  public = list(\n    balance = 0,\n    deposit = function(dep = 0) {\n      self$balance &lt;- self$balance + dep\n      invisible(self)\n    },\n    withdraw = function(draw) {\n      self$balance &lt;- self$balance - draw\n      invisible(self)\n    }\n  )\n)\n\nTo test this class, we create one instance and leave it with a negative balance.\n\nmy_account &lt;- BankAccount$new()\nmy_account$balance\n#&gt; [1] 0\n\nmy_account$\n  deposit(5)$\n  withdraw(15)$\n  balance\n#&gt; [1] -10\n\nNow, we create the first subclass that prevents us from going into overdraft and throws an error in case we attempt to withdraw more than our current balance.\n\nBankAccountStrict &lt;- R6Class(\n  classname = \"BankAccountStrict\",\n  inherit = BankAccount,\n  public = list(\n    withdraw = function(draw = 0) {\n      if (self$balance - draw &lt; 0) {\n        stop(\"Your `withdraw` must be smaller \",\n          \"than your `balance`.\",\n          call. = FALSE\n        )\n      }\n      super$withdraw(draw = draw)\n    }\n  )\n)\n\nThis time our test should throw an error.\n\nmy_strict_account &lt;- BankAccountStrict$new()\nmy_strict_account$balance\n#&gt; [1] 0\n\nmy_strict_account$\n  deposit(5)$\n  withdraw(15)\n#&gt; Error: Your `withdraw` must be smaller than your `balance`.\n\nmy_strict_account$balance\n#&gt; [1] 5\n\nFinally, we create another subclass that charges a constant fee of 1 for each withdrawal which leaves the account with a negative balance.\n\nBankAccountCharging &lt;- R6Class(\n  classname = \"BankAccountCharging\",\n  inherit = BankAccount,\n  public = list(\n    withdraw = function(draw = 0) {\n      if (self$balance - draw &lt; 0) {\n        draw &lt;- draw + 1\n      }\n      super$withdraw(draw = draw)\n    }\n  )\n)\n\nLet’s take a look at the implemented functionality. We expect a final balance of -12, because we pay the fee twice.\n\nmy_charging_account &lt;- BankAccountCharging$new()\nmy_charging_account$balance\n#&gt; [1] 0\n\nmy_charging_account$\n  deposit(5)$\n  withdraw(15)$\n  withdraw(0)\n\nmy_charging_account$balance\n#&gt; [1] -12\n\nQ2: Create an R6 class that represents a shuffled deck of cards. You should be able to draw cards from the deck with $draw(n), and return all cards to the deck and reshuffle with $reshuffle(). Use the following code to make a vector of cards.\n\nsuit &lt;- c(\"SPADE\", \"HEARTS\", \"DIAMOND\", \"CLUB\")\nvalue &lt;- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards &lt;- paste(rep(value, 4), suit)\n\n(This question was altered slightly to avoid the unicode characters.)\nA: Our new ShuffledDeck class will use sample() and positive integer subsetting to implement the reshuffling and drawing functionality. We also add a check, so you cannot draw more cards than there are left in the deck.\n\nShuffledDeck &lt;- R6Class(\n  classname = \"ShuffledDeck\",\n  public = list(\n    deck = NULL,\n    initialize = function(deck = cards) {\n      self$deck &lt;- sample(deck)\n    },\n    reshuffle = function() {\n      self$deck &lt;- sample(cards)\n      invisible(self)\n    },\n    n = function() {\n      length(self$deck)\n    },\n    draw = function(n = 1) {\n      if (n &gt; self$n()) {\n        stop(\"Only \", self$n(), \" cards remaining.\", call. = FALSE)\n      }\n\n      output &lt;- self$deck[seq_len(n)]\n      self$deck &lt;- self$deck[-seq_len(n)]\n      output\n    }\n  )\n)\n\nTo test this class, we create a deck (initialise an instance), draw all the cards, then reshuffle, checking we get different cards each time.\n\nmy_deck &lt;- ShuffledDeck$new()\n\nmy_deck$draw(52)\n#&gt;  [1] \"6 SPADE\"    \"10 DIAMOND\" \"Q CLUB\"     \"J SPADE\"    \"Q HEARTS\"  \n#&gt;  [6] \"8 DIAMOND\"  \"5 DIAMOND\"  \"4 CLUB\"     \"9 CLUB\"     \"9 SPADE\"   \n#&gt; [11] \"5 SPADE\"    \"3 HEARTS\"   \"J CLUB\"     \"2 DIAMOND\"  \"K SPADE\"   \n#&gt; [16] \"2 HEARTS\"   \"2 SPADE\"    \"8 SPADE\"    \"8 HEARTS\"   \"6 HEARTS\"  \n#&gt; [21] \"7 HEARTS\"   \"6 CLUB\"     \"K CLUB\"     \"3 CLUB\"     \"10 SPADE\"  \n#&gt; [26] \"3 DIAMOND\"  \"Q SPADE\"    \"9 HEARTS\"   \"J DIAMOND\"  \"7 DIAMOND\" \n#&gt; [31] \"9 DIAMOND\"  \"7 SPADE\"    \"4 DIAMOND\"  \"10 HEARTS\"  \"2 CLUB\"    \n#&gt; [36] \"4 SPADE\"    \"4 HEARTS\"   \"8 CLUB\"     \"K HEARTS\"   \"A SPADE\"   \n#&gt; [41] \"A HEARTS\"   \"5 HEARTS\"   \"A DIAMOND\"  \"5 CLUB\"     \"7 CLUB\"    \n#&gt; [46] \"Q DIAMOND\"  \"A CLUB\"     \"10 CLUB\"    \"3 SPADE\"    \"K DIAMOND\" \n#&gt; [51] \"J HEARTS\"   \"6 DIAMOND\"\nmy_deck$draw(10)\n#&gt; Error: Only 0 cards remaining.\n\nmy_deck$reshuffle()$draw(5)\n#&gt; [1] \"6 DIAMOND\" \"2 CLUB\"    \"Q DIAMOND\" \"9 CLUB\"    \"J DIAMOND\"\nmy_deck$reshuffle()$draw(5)\n#&gt; [1] \"8 CLUB\"   \"9 SPADE\"  \"2 SPADE\"  \"Q HEARTS\" \"6 SPADE\"\n\nQ3: Why can’t you model a bank account or a deck of cards with an S3 class?\nA: Because S3 classes obey R’s usual semantics of copy-on-modify: every time you deposit money into your bank account or draw a card from the deck, you’d get a new copy of the object.\nIt is possible to combine S3 classes with an environment (which is how R6 works), but it is ill-advised to create an object that looks like a regular R object but has reference semantics.\nQ4: Create an R6 class that allows you to get and set the current time zone. You can access the current time zone with Sys.timezone() and set it with Sys.setenv(TZ = \"newtimezone\"). When setting the time zone, make sure the new time zone is in the list provided by OlsonNames().\nA: To create an R6 class that allows us to get and set the time zone, we provide the respective functions as public methods to the R6 class.\n\nTimezone &lt;- R6Class(\n  classname = \"Timezone\",\n  public = list(\n    get = function() {\n      Sys.timezone()\n    },\n    set = function(value) {\n      stopifnot(value %in% OlsonNames())\n\n      old &lt;- self$get()\n      Sys.setenv(TZ = value)\n      invisible(old)\n    }\n  )\n)\n\n(When setting, we return the old value invisibly because this makes it easy to restore the previous value.)\nNow, let us create one instance of this class and test, if we can set and get the time zone as intended.\n\ntz &lt;- Timezone$new()\n\nold &lt;- tz$set(\"Antarctica/South_Pole\")\ntz$get()\n#&gt; [1] \"America/Toronto\"\n\ntz$set(old)\ntz$get()\n#&gt; [1] \"America/Toronto\"\n\nQ5: Create an R6 class that manages the current working directory. It should have $get() and $set() methods.\nA: Take a look at the following implementation, which is quite minimalistic:\n\nWorkingDirectory &lt;- R6Class(\n  classname = \"WorkingDirectory\",\n  public = list(\n    get = function() {\n      getwd()\n    },\n    set = function(value) {\n      setwd(value)\n    }\n  )\n)\n\n\nQ6: Why can’t you model the time zone or current working directory with an S3 class?\nA: Because S3 classes are not suitable for modelling a state that changes over time. S3 methods should (almost) always return the same result when called with the same inputs.\nQ7: What base type are R6 objects built on top of? What attributes do they have?\nA: R6 objects are built on top of environments. They have a class attribute, which is a character vector containing the class name, the name of any super classes (if existent) and the string \"R6\" as the last element."
  },
  {
    "objectID": "14_R6.html#controlling-access",
    "href": "14_R6.html#controlling-access",
    "title": "14 - R6",
    "section": "Controlling access",
    "text": "Controlling access\nQ1: Create a bank account class that prevents you from directly setting the account balance, but that you can still withdraw from and deposit to. Throw an error if you attempt to go into overdraft.\nA: To fulfil this requirement, we make balance a private field. The user has to use the $deposit() and $withdraw() methods which have access to the balance field.\n\nBankAccountStrict2 &lt;- R6Class(\n  classname = \"BankAccountStrict2\",\n  public = list(\n    deposit = function(dep = 0) {\n      private$balance &lt;- private$balance + dep\n      invisible(self)\n    },\n    withdraw = function(draw = 0) {\n      if (private$balance - draw &lt; 0) {\n        stop(\n          \"Your `withdraw` must be smaller \",\n          \"than your `balance`.\",\n          call. = FALSE\n        )\n      }\n      private$balance &lt;- private$balance - draw\n      invisible(self)\n    }\n  ),\n  private = list(\n    balance = 0\n  )\n)\n\nTo test our new class, we create an instance and try to go into overdraft.\n\nmy_account_strict_2 &lt;- BankAccountStrict2$new()\n\nmy_account_strict_2$deposit(5)\nmy_account_strict_2$withdraw(10)\n#&gt; Error: Your `withdraw` must be smaller than your `balance`.\n\nQ2: Create a class with a write-only $password field. It should have $check_password(password) method that returns TRUE or FALSE, but there should be no way to view the complete password.\nA: To protect the password from changes and direct access, the password will be a private field. Further, our Password will get its own print method which hides the password.\n\nPassword &lt;- R6Class(\n  classname = \"Password\",\n  public = list(\n    print = function(...) {\n      cat(\"&lt;Password&gt;: ********\\n\")\n      invisible(self)\n    },\n    set = function(value) {\n      private$password &lt;- value\n    },\n    check = function(password) {\n      identical(password, private$password)\n    }\n  ),\n  private = list(\n    password = NULL\n  )\n)\n\nLet’s create one instance of our new class and confirm that the password is neither accessible nor visible, but still check-able.\n\nmy_pw &lt;- Password$new()\nmy_pw$set(\"snuffles\")\nmy_pw$password\n#&gt; NULL\nmy_pw\n#&gt; &lt;Password&gt;: ********\nmy_pw$check(\"snuggles\")\n#&gt; [1] FALSE\nmy_pw$check(\"snuffles\")\n#&gt; [1] TRUE\n\nQ3: Extend the Rando class with another active binding that allows you to access the previous random value. Ensure that active binding is the only way to access the value.\nA: To access the previous random value from an instance, we add a private $last_random field to our class, and we modify $random() to write to this field, whenever it is called. To access the $last_random field we provide $previous().\n\nRando &lt;- R6::R6Class(\n  classname = \"Rando\",\n  private = list(\n    last_random = NULL\n  ),\n  active = list(\n    random = function(value) {\n      if (missing(value)) {\n        private$last_random &lt;- runif(1)\n        private$last_random\n      } else {\n        stop(\"Can't set `$random`.\", call. = FALSE)\n      }\n    },\n    previous = function(value) {\n      if (missing(value)) {\n        private$last_random\n      }\n    }\n  )\n)\n\nNow, we initiate a new Rando object and see if it behaves as expected.\n\nx &lt;- Rando$new()\nx$random\n#&gt; [1] 0.349\nx$random\n#&gt; [1] 0.947\nx$previous\n#&gt; [1] 0.947\n\nQ4: Can subclasses access private fields/methods from their parent? Perform an experiment to find out.\nA: To find out if private fields/methods can be accessed from subclasses, we first create a class A with a private field foo and a private method bar(). Afterwards, an instance of a subclass B is created and calls the foobar() methods, which tries to access the foo field and the bar() method from its superclass A.\n\nA &lt;- R6Class(\n  classname = \"A\",\n  private = list(\n    field = \"foo\",\n    method = function() {\n      \"bar\"\n    }\n  )\n)\n\nB &lt;- R6Class(\n  classname = \"B\",\n  inherit = A,\n  public = list(\n    test = function() {\n      cat(\"Field:  \", super$field, \"\\n\", sep = \"\")\n      cat(\"Method: \", super$method(), \"\\n\", sep = \"\")\n    }\n  )\n)\n\nB$new()$test()\n#&gt; Field:  \n#&gt; Method: bar\n\nWe conclude that subclasses can access private methods from their superclasses, but not private fields."
  },
  {
    "objectID": "14_R6.html#reference-semantics",
    "href": "14_R6.html#reference-semantics",
    "title": "14 - R6",
    "section": "Reference semantics",
    "text": "Reference semantics\nQ1: Create a class that allows you to write a line to a specified file. You should open a connection to the file in $initialize(), append a line using cat() in $append_line(), and close the connection in $finalize().\nA: Our FileWriter class will create a connection to a file at initialization. Therefore, we open a connection to a user specified file during the initialisation. Note that we need to set open = \"a\" in file() to open connection for appending text. Otherwise, cat() would only work when applied to files, but not with connections as explicitly asked for in the exercise. Further, we add the append_line() method and a close() statement as finalizer.\n\nFileWriter &lt;- R6::R6Class(\n  classname = \"FileWriter\",\n  public = list(\n    con = NULL,\n    initialize = function(filename) {\n      self$con &lt;- file(filename, open = \"a\")\n    },\n    finalize = function() {\n      close(self$con)\n    },\n    append_line = function(x) {\n      cat(x, \"\\n\", sep = \"\", file = self$con)\n    }\n  )\n)\n\nLet’s see, if new instances of our class work as expected.\n\ntmp_file &lt;- tempfile()\nmy_fw &lt;- FileWriter$new(tmp_file)\n\nreadLines(tmp_file)\n#&gt; character(0)\nmy_fw$append_line(\"First\")\nmy_fw$append_line(\"Second\")\nreadLines(tmp_file)\n#&gt; [1] \"First\"  \"Second\""
  },
  {
    "objectID": "14_R6.html#references",
    "href": "14_R6.html#references",
    "title": "14 - R6",
    "section": "References",
    "text": "References\n\n\n\n\nChang, Winston. 2020. R6: Encapsulated Classes with Reference Semantics. https://github.com/r-lib/R6."
  },
  {
    "objectID": "15_S4.html#prerequisites",
    "href": "15_S4.html#prerequisites",
    "title": "15 - S4",
    "section": "Prerequisites",
    "text": "Prerequisites\nWe load the {methods} package (R Core Team 2020) as it contains the S4 object-oriented programming system.\n\nlibrary(methods)"
  },
  {
    "objectID": "15_S4.html#basics",
    "href": "15_S4.html#basics",
    "title": "15 - S4",
    "section": "Basics",
    "text": "Basics\nQ1: lubridate::period() returns an S4 class. What slots does it have? What class is each slot? What accessors does it provide?\nA: Objects of the S4 Period class have six slots named year, month, day, hour, minute, and .Data (which contains the number of seconds). All slots are of type double. Most fields can be retrieved by an identically named accessor (e.g. lubridate::year() will return the field), use second() to get the .Data slot.\nAs a short example, we create a period of 1 second, 2 minutes, 3 hours, 4 days and 5 weeks.\n\nexample_12345 &lt;- lubridate::period(\n  c(1, 2, 3, 4, 5),\n  c(\"second\", \"minute\", \"hour\", \"day\", \"week\")\n)\n\nThis should add up to a period of 39 days, 3 hours, 2 minutes and 1 second.\n\nexample_12345\n#&gt; [1] \"39d 3H 2M 1S\"\n\nWhen we inspect example_12345, we see the fields and infer that the seconds are stored in the .Data field.\n\nstr(example_12345)\n#&gt; Formal class 'Period' [package \"lubridate\"] with 6 slots\n#&gt;   ..@ .Data : num 1\n#&gt;   ..@ year  : num 0\n#&gt;   ..@ month : num 0\n#&gt;   ..@ day   : num 39\n#&gt;   ..@ hour  : num 3\n#&gt;   ..@ minute: num 2\n\nQ2: What other ways can you find help for a method? Read ?\"?\" and summarise the details.\nA: Besides adding ? in front of a function call (i.e. ?method()), we may find:\n\ngeneral documentation for a generic via ?genericName\ngeneral documentation for the methods of a generic via methods?genericName\ndocumentation for a specific method via ClassName?methodName."
  },
  {
    "objectID": "15_S4.html#classes",
    "href": "15_S4.html#classes",
    "title": "15 - S4",
    "section": "Classes",
    "text": "Classes\nQ1: Extend the Person class with fields to match utils::person(). Think about what slots you will need, what class each slot should have, and what you’ll need to check in your validity method.\nA: The Person class from Advanced R contains the slots name and age. The person class from the {utils} package contains the slots given (vector of given names), family, role, email and comment (see ?utils::person).\nAll slots from utils::person() besides role must be of type character and length 1. The entries in the role slot must match one of the following abbreviations “aut”, “com”, “cph”, “cre”, “ctb”, “ctr”, “dtc”, “fnd”, “rev”, “ths”, “trl”. Therefore, role might be of different length than the other slots and we’ll add a corresponding constraint within the validator.\n\n# Definition of the Person class\nsetClass(\"Person\",\n  slots = c(\n    age = \"numeric\",\n    given = \"character\",\n    family = \"character\",\n    role = \"character\",\n    email = \"character\",\n    comment = \"character\"\n  ),\n  prototype = list(\n    age = NA_real_,\n    given = NA_character_,\n    family = NA_character_,\n    role = NA_character_,\n    email = NA_character_,\n    comment = NA_character_\n  )\n)\n\n# Helper to create instances of the Person class\nPerson &lt;- function(given, family,\n                   age = NA_real_,\n                   role = NA_character_,\n                   email = NA_character_,\n                   comment = NA_character_) {\n  age &lt;- as.double(age)\n\n  new(\"Person\",\n    age = age,\n    given = given,\n    family = family,\n    role = role,\n    email = email,\n    comment = comment\n  )\n}\n\n# Validator to ensure that each slot is of length one\nsetValidity(\"Person\", function(object) {\n  invalids &lt;- c()\n  if (length(object@age) != 1 ||\n    length(object@given) != 1 ||\n    length(object@family) != 1 ||\n    length(object@email) != 1 ||\n    length(object@comment) != 1) {\n    invalids &lt;- paste0(\n      \"@name, @age, @given, @family, @email, \",\n      \"@comment must be of length 1\"\n    )\n  }\n\n  known_roles &lt;- c(\n    NA_character_, \"aut\", \"com\", \"cph\", \"cre\", \"ctb\",\n    \"ctr\", \"dtc\", \"fnd\", \"rev\", \"ths\", \"trl\"\n  )\n\n  if (!all(object@role %in% known_roles)) {\n    paste(\n      \"@role(s) must be one of\",\n      paste(known_roles, collapse = \", \")\n    )\n  }\n\n  if (length(invalids)) {\n    return(invalids)\n  }\n  TRUE\n})\n#&gt; Class \"Person\" [in \".GlobalEnv\"]\n#&gt; \n#&gt; Slots:\n#&gt;                                                                   \n#&gt; Name:        age     given    family      role     email   comment\n#&gt; Class:   numeric character character character character character\n\nQ2: What happens if you define a new S4 class that doesn’t have any slots? (Hint: read about virtual classes in ?setClass.)\nA: It depends on the other arguments. If we inherit from another class, we get the same slots. But something interesting happens if we don’t inherit from an existing class. We get a virtual class. A virtual class can’t be instantiated:\n\nsetClass(\"Human\")\nnew(\"Human\")\n#&gt; Error in new(\"Human\"): trying to generate an object from a virtual class (\"Human\")\n\nBut can be inherited from:\n\nsetClass(\"Programmer\", contains = \"Human\")\n\nQ3: Imagine you were going to reimplement factors, dates, and data frames in S4. Sketch out the setClass() calls that you would use to define the classes. Think about appropriate slots and prototype.\nA: For all these classes we need one slot for the data and one slot per attribute. Keep in mind, that inheritance matters for ordered factors and dates. For data frames, special checks like equal lengths of the underlying list’s elements should be done within a validator.\nFor simplicity we don’t introduce an explicit subclass for ordered factors. Instead, we introduce ordered as a slot.\n\nsetClass(\"Factor\",\n  slots = c(\n    data = \"integer\",\n    levels = \"character\",\n    ordered = \"logical\"\n  ),\n  prototype = list(\n    data = integer(),\n    levels = character(),\n    ordered = FALSE\n  )\n)\n\n\nnew(\"Factor\", data = c(1L, 2L), levels = letters[1:3])\n#&gt; An object of class \"Factor\"\n#&gt; Slot \"data\":\n#&gt; [1] 1 2\n#&gt; \n#&gt; Slot \"levels\":\n#&gt; [1] \"a\" \"b\" \"c\"\n#&gt; \n#&gt; Slot \"ordered\":\n#&gt; [1] FALSE\n\nThe Date2 class stores its dates as integers, similarly to base R which uses doubles. Dates don’t have any other attributes.\n\nsetClass(\"Date2\",\n  slots = list(\n    data = \"integer\"\n  ),\n  prototype = list(\n    data = integer()\n  )\n)\n\nnew(\"Date2\", data = 1L)\n#&gt; An object of class \"Date2\"\n#&gt; Slot \"data\":\n#&gt; [1] 1\n\nOur DataFrame class consists of a list and a slot for row.names. Most of the logic (e.g. checking that all elements of the list are a vector, and that they all have the same length) would need to be part of a validator.\n\nsetClass(\"DataFrame\",\n  slots = c(\n    data = \"list\",\n    row.names = \"character\"\n  ),\n  prototype = list(\n    data = list(),\n    row.names = character(0)\n  )\n)\n\nnew(\"DataFrame\", data = list(a = 1, b = 2))\n#&gt; An object of class \"DataFrame\"\n#&gt; Slot \"data\":\n#&gt; $a\n#&gt; [1] 1\n#&gt; \n#&gt; $b\n#&gt; [1] 2\n#&gt; \n#&gt; \n#&gt; Slot \"row.names\":\n#&gt; character(0)"
  },
  {
    "objectID": "15_S4.html#generics-and-methods",
    "href": "15_S4.html#generics-and-methods",
    "title": "15 - S4",
    "section": "Generics and methods",
    "text": "Generics and methods\nQ1: Add age() accessors for the Person class.\nA: We implement the accessors via an age() generic, with a method for the Person class and a corresponding replacement function age&lt;-:\n\nsetGeneric(\"age\", function(x) standardGeneric(\"age\"))\n#&gt; [1] \"age\"\nsetMethod(\"age\", \"Person\", function(x) x@age)\n\nsetGeneric(\"age&lt;-\", function(x, value) standardGeneric(\"age&lt;-\"))\n#&gt; [1] \"age&lt;-\"\nsetMethod(\"age&lt;-\", \"Person\", function(x, value) {\n  x@age &lt;- value\n  validObject(x)\n  x\n})\n\nQ2: In the definition of the generic, why is it necessary to repeat the name of the generic twice?\nA: Within setGeneric() the name (1st argument) is needed as the name of the generic. Then, the name also explicitly incorporates method dispatch via standardGeneric() within the generic’s body (def parameter of setGeneric()). This behaviour is similar to UseMethod() in S3.\nQ3: Why does the show() method defined in section 15.4.3 use is(object)[[1]]? (Hint: try printing the employee subclass.)\nA: is(object) returns the class of the object. is(object) also contains the superclass, for subclasses like Employee. In order to always return the most specific class (the subclass), show() returns the first element of is(object).\nQ4: What happens if you define a method with different argument names to the generic?\nA: It depends. We first create the object hadley of class Person:\n\n.Person &lt;- setClass(\n  \"Person\",\n  slots = c(name = \"character\", age = \"numeric\")\n)\n\nhadley &lt;- .Person(name = \"Hadley\")\nhadley\n#&gt; An object of class \"Person\"\n#&gt; Slot \"name\":\n#&gt; [1] \"Hadley\"\n#&gt; \n#&gt; Slot \"age\":\n#&gt; numeric(0)\n\nNow let’s see which arguments can be supplied to the show() generic.\n\nformals(\"show\")\n#&gt; $object\n\nUsually, we would use this argument when defining a new method.\n\nsetMethod(\"show\", \"Person\", function(object) {\n  cat(object@name, \"creates hard exercises\")\n})\n\nhadley\n#&gt; Hadley creates hard exercises\n\nWhen we supply another name as a first element of our method (e.g. x instead of object), this element will be matched to the correct object argument and we receive a warning. Our method will work, though:\n\nsetMethod(\"show\", \"Person\", function(x) {\n  cat(x@name, \"creates hard exercises\")\n})\n#&gt; Warning: For function 'show', signature 'Person': argument in method definition\n#&gt; changed from (x) to (object)\n\nhadley\n#&gt; Hadley creates hard exercises\n\nIf we add more arguments to our method than our generic can handle, we will get an error.\n\nsetMethod(\"show\", \"Person\", function(x, y) {\n  cat(x@name, \"is\", x@age, \"years old\")\n})\n#&gt; Error in conformMethod(signature, mnames, fnames, f, fdef, definition): in method for 'show' with signature 'object=\"Person\"': formal arguments (object = \"Person\") omitted in the method definition cannot be in the signature\n\nIf we do this with arguments added to the correctly written object argument, we will receive an informative error message. It states that we could add other argument names for generics, which can take the ... argument.\n\nsetMethod(\"show\", \"Person\", function(object, y) {\n  cat(object@name, \"is\", object@age, \"years old\")\n})\n#&gt; Error in rematchDefinition(definition, fdef, mnames, fnames, signature): methods can add arguments to the generic 'show' only if '...' is an argument to the generic"
  },
  {
    "objectID": "15_S4.html#method-dispatch",
    "href": "15_S4.html#method-dispatch",
    "title": "15 - S4",
    "section": "Method dispatch",
    "text": "Method dispatch\nQ1: Draw the method graph for f(😅, 😽).\nA: Look at the graph and repeat after me: “I will keep my class structure simple and use multiple inheritance sparingly”.\n\n\n\n\n\n\n\n\n\nQ2: Draw the method graph for f(😃, 😉, 😙).\nA: We see that the method graph below looks simpler than the one above. Relatively speaking, multiple dispatch seems to introduce less complexity than multiple inheritance. Use it with care, though!\n\n\n\n\n\n\n\n\n\nQ3: Take the last example which shows multiple dispatch over two classes that use multiple inheritance. What happens if you define a method for all terminal classes? Why does method dispatch not save us much work here?\nA: We will introduce ambiguity, since one class has distance 2 to all terminal nodes and the other four have distance 1 to two terminal nodes each. To resolve this ambiguity we have to define five more methods, one per class combination."
  },
  {
    "objectID": "15_S4.html#s4-and-s3",
    "href": "15_S4.html#s4-and-s3",
    "title": "15 - S4",
    "section": "S4 and S3",
    "text": "S4 and S3\nQ1: What would a full setOldClass() definition look like for an ordered factor (i.e. add slots and prototype to the definition above)?\nA: The purpose of setOldClass() lies in registering an S3 class as a “formally defined class”, so that it can be used within the S4 object-oriented programming system. When using it, we may provide the argument S4Class, which will inherit the slots and their default values (prototype) to the registered class.\nLet’s build an S4 OrderedFactor on top of the S3 factor in such a way.\n\nsetOldClass(\"factor\") # use build-in definition for brevity\n\nOrderedFactor &lt;- setClass(\n  \"OrderedFactor\",\n  contains = \"factor\", # inherit from registered S3 class\n  slots = c(\n    levels = \"character\",\n    ordered = \"logical\" # add logical order slot\n  ),\n  prototype = structure(\n    integer(),\n    levels = character(),\n    ordered = logical() # add default value\n  )\n)\n\nWe can now register the (S3) ordered-class, while providing an “S4 template”. We can also use the S4-class to create new object directly.\n\nsetOldClass(\"ordered\", S4Class = \"OrderedFactor\")\n\nx &lt;- OrderedFactor(\n  c(1L, 2L, 2L),\n  levels = c(\"a\", \"b\", \"c\"),\n  ordered = TRUE\n)\nstr(x)\n#&gt; Formal class 'OrderedFactor' [package \".GlobalEnv\"] with 4 slots\n#&gt;   ..@ .Data   : int [1:3] 1 2 2\n#&gt;   ..@ levels  : chr [1:3] \"a\" \"b\" \"c\"\n#&gt;   ..@ ordered : logi TRUE\n#&gt;   ..@ .S3Class: chr \"factor\"\n\nQ2: Define a length method for the Person class.\nA: We keep things simple and will just return \"180cm\" when the length() method is called on a Person object. The method can be defined either as an S3 or S4 method.\n\nlength.Person &lt;- function(x) \"180cm\" # S3\nsetMethod(\"length\", \"Person\", function(x) \"180cm\") # S4"
  },
  {
    "objectID": "15_S4.html#references",
    "href": "15_S4.html#references",
    "title": "15 - S4",
    "section": "References",
    "text": "References\n\n\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/."
  },
  {
    "objectID": "18_Expressions.html#prerequisites",
    "href": "18_Expressions.html#prerequisites",
    "title": "18 - Expressions",
    "section": "Prerequisites",
    "text": "Prerequisites\nTo capture and compute on expressions, and to visualise them, we will load the {rlang} (Henry and Wickham 2020) and the {lobstr} (Wickham 2019) packages.\n\nlibrary(rlang)\nlibrary(lobstr)"
  },
  {
    "objectID": "18_Expressions.html#abstract-syntax-trees",
    "href": "18_Expressions.html#abstract-syntax-trees",
    "title": "18 - Expressions",
    "section": "Abstract syntax trees",
    "text": "Abstract syntax trees\nQ1: Reconstruct the code represented by the trees below:\n\n#&gt; █─f \n#&gt; └─█─g \n#&gt;   └─█─h\n#&gt; █─`+` \n#&gt; ├─█─`+` \n#&gt; │ ├─1 \n#&gt; │ └─2 \n#&gt; └─3\n#&gt; █─`*` \n#&gt; ├─█─`(` \n#&gt; │ └─█─`+` \n#&gt; │   ├─x \n#&gt; │   └─y \n#&gt; └─z\n\nA: Let the source (of the code chunks above) be with you and show you how the ASTs (abstract syntax trees) were produced.\n\nast(f(g(h())))\n#&gt; █─f \n#&gt; └─█─g \n#&gt;   └─█─h\n\nast(1 + 2 + 3)\n#&gt; █─`+` \n#&gt; ├─█─`+` \n#&gt; │ ├─1 \n#&gt; │ └─2 \n#&gt; └─3\n\nast((x + y) * z)\n#&gt; █─`*` \n#&gt; ├─█─`(` \n#&gt; │ └─█─`+` \n#&gt; │   ├─x \n#&gt; │   └─y \n#&gt; └─z\n\nQ2: Draw the following trees by hand then check your answers with ast().\n\nf(g(h(i(1, 2, 3))))\nf(1, g(2, h(3, i())))\nf(g(1, 2), h(3, i(4, 5)))\n\nA: Let us delegate the drawing to the {lobstr} package.\n\nast(f(g(h(i(1, 2, 3)))))\n#&gt; █─f \n#&gt; └─█─g \n#&gt;   └─█─h \n#&gt;     └─█─i \n#&gt;       ├─1 \n#&gt;       ├─2 \n#&gt;       └─3\n\nast(f(1, g(2, h(3, i()))))\n#&gt; █─f \n#&gt; ├─1 \n#&gt; └─█─g \n#&gt;   ├─2 \n#&gt;   └─█─h \n#&gt;     ├─3 \n#&gt;     └─█─i\n\nast(f(g(1, 2), h(3, i(4, 5))))\n#&gt; █─f \n#&gt; ├─█─g \n#&gt; │ ├─1 \n#&gt; │ └─2 \n#&gt; └─█─h \n#&gt;   ├─3 \n#&gt;   └─█─i \n#&gt;     ├─4 \n#&gt;     └─5\n\nQ3: What’s happening with the ASTs below? (Hint: carefully read ?\"^\")\n\nast(`x` + `y`)\n#&gt; █─`+` \n#&gt; ├─x \n#&gt; └─y\nast(x**y)\n#&gt; █─`^` \n#&gt; ├─x \n#&gt; └─y\nast(1 -&gt; x)\n#&gt; █─`&lt;-` \n#&gt; ├─x \n#&gt; └─1\n\nA: ASTs start function calls with the name of the function. This is why the call in the first expression is translated into its prefix form. In the second case, ** is translated by R’s parser into ^. In the last AST, the expression is flipped when R parses it:\n\nstr(expr(x**y))\n#&gt;  language x^y\nstr(expr(a -&gt; b))\n#&gt;  language b &lt;- a\n\nQ4: What is special about the AST below? (Hint: re-read section 6.2.1)\n\nast(function(x = 1, y = 2) {})\n#&gt; █─`function` \n#&gt; ├─█─x = 1 \n#&gt; │ └─y = 2 \n#&gt; ├─█─`{` \n#&gt; └─&lt;inline srcref&gt;\n\nA: The last leaf of the AST is not explicitly specified in the expression. Instead, the srcref attribute, which points to the functions source code, is automatically created by base R.\nQ5: What does the call tree of an if statement with multiple else if conditions look like? Why?\nA: The AST of nested else if statements might look a bit confusing because it contains multiple curly braces. However, we can see that in the else part of the AST just another expression is being evaluated, which happens to be an if statement and so forth.\n\nast(\n  if (FALSE) {\n    1\n  } else if (FALSE) {\n    2\n  } else if (TRUE) {\n    3\n  }\n)\n#&gt; █─`if` \n#&gt; ├─FALSE \n#&gt; ├─█─`{` \n#&gt; │ └─1 \n#&gt; └─█─`if` \n#&gt;   ├─FALSE \n#&gt;   ├─█─`{` \n#&gt;   │ └─2 \n#&gt;   └─█─`if` \n#&gt;     ├─TRUE \n#&gt;     └─█─`{` \n#&gt;       └─3\n\nWe can see the structure more clearly if we avoid the curly braces:\n\nast(\n  if (FALSE) {\n    1\n  } else if (FALSE) {\n    2\n  } else if (TRUE) 3\n)\n#&gt; █─`if` \n#&gt; ├─FALSE \n#&gt; ├─█─`{` \n#&gt; │ └─1 \n#&gt; └─█─`if` \n#&gt;   ├─FALSE \n#&gt;   ├─█─`{` \n#&gt;   │ └─2 \n#&gt;   └─█─`if` \n#&gt;     ├─TRUE \n#&gt;     └─3"
  },
  {
    "objectID": "18_Expressions.html#expressions",
    "href": "18_Expressions.html#expressions",
    "title": "18 - Expressions",
    "section": "Expressions",
    "text": "Expressions\nQ1: Which two of the six types of atomic vector can’t appear in an expression? Why? Similarly, why can’t you create an expression that contains an atomic vector of length greater than one?\nA: There is no way to create raws and complex atomics without using a function call (this is only possible for imaginary scalars like i, 5i etc.). But expressions that include a function are calls. Therefore, both of these vector types cannot appear in an expression.\nSimilarly, it is not possible to create an expression that evaluates to an atomic of length greater than one without using a function (e.g. c()).\nLet’s make this observation concrete via an example:\n\n# Atomic\nis_atomic(expr(1))\n#&gt; [1] TRUE\n\n# Not an atomic (although it would evaluate to an atomic)\nis_atomic(expr(c(1, 1)))\n#&gt; [1] FALSE\nis_call(expr(c(1, 1)))\n#&gt; [1] TRUE\n\nQ2: What happens when you subset a call object to remove the first element, e.g. expr(read.csv(\"foo.csv\", header = TRUE))[-1]. Why?\nA: When the first element of a call object is removed, the second element moves to the first position, which is the function to call. Therefore, we get \"foo.csv\"(header = TRUE).\nQ3: Describe the differences between the following call objects.\n\nx &lt;- 1:10\n\ncall2(median, x, na.rm = TRUE)\ncall2(expr(median), x, na.rm = TRUE)\ncall2(median, expr(x), na.rm = TRUE)\ncall2(expr(median), expr(x), na.rm = TRUE)\n\nA: The call objects differ in their first two elements, which are in some cases evaluated before the call is constructed. In the first one, both median() and x are evaluated and inlined into the call. Therefore, we can see in the constructed call that median is a generic and the x argument is 1:10.\n\ncall2(median, x, na.rm = TRUE)\n#&gt; (function (x, na.rm = FALSE, ...) \n#&gt; UseMethod(\"median\"))(1:10, na.rm = TRUE)\n\nIn the following calls we remain with differing combinations. Once, only x and once only median() gets evaluated.\n\ncall2(expr(median), x, na.rm = TRUE)\n#&gt; median(1:10, na.rm = TRUE)\ncall2(median, expr(x), na.rm = TRUE)\n#&gt; (function (x, na.rm = FALSE, ...) \n#&gt; UseMethod(\"median\"))(x, na.rm = TRUE)\n\nIn the final call neither x nor median() is evaluated.\n\ncall2(expr(median), expr(x), na.rm = TRUE)\n#&gt; median(x, na.rm = TRUE)\n\nNote that all these calls will generate the same result when evaluated. The key difference is when the values bound to the x and median symbols are found.\nQ4: rlang::call_standardise() doesn’t work so well for the following calls. Why? What makes mean() special?\n\ncall_standardise(quote(mean(1:10, na.rm = TRUE)))\n#&gt; Warning: `call_standardise()` is deprecated as of rlang 0.4.11\n#&gt; This warning is displayed once every 8 hours.\n#&gt; mean(x = 1:10, na.rm = TRUE)\ncall_standardise(quote(mean(n = T, 1:10)))\n#&gt; mean(x = 1:10, n = T)\ncall_standardise(quote(mean(x = 1:10, , TRUE)))\n#&gt; mean(x = 1:10, , TRUE)\n\nA: The reason for this unexpected behaviour is that mean() uses the ... argument and therefore cannot standardise the regarding arguments. Since mean() uses S3 dispatch (i.e. UseMethod()) and the underlying mean.default() method specifies some more arguments, call_standardise() can do much better with a specific S3 method.\n\ncall_standardise(quote(mean.default(1:10, na.rm = TRUE)))\n#&gt; mean.default(x = 1:10, na.rm = TRUE)\ncall_standardise(quote(mean.default(n = T, 1:10)))\n#&gt; mean.default(x = 1:10, na.rm = T)\ncall_standardise(quote(mean.default(x = 1:10, , TRUE)))\n#&gt; mean.default(x = 1:10, na.rm = TRUE)\n\nQ5: Why does this code not make sense?\n\nx &lt;- expr(foo(x = 1))\nnames(x) &lt;- c(\"x\", \"\")\n\nA: As stated in Advanced R\n\nThe first element of a call is always the function that gets called.\n\nLet’s see what happens when we run the code\n\nx &lt;- expr(foo(x = 1))\nx\n#&gt; foo(x = 1)\n\nnames(x) &lt;- c(\"x\", \"\")\nx\n#&gt; foo(1)\n\nnames(x) &lt;- c(\"\", \"x\")\nx\n#&gt; foo(x = 1)\n\nSo, giving the first element a name just adds metadata that R ignores.\nQ6: Construct the expression if(x &gt; 1) \"a\" else \"b\" using multiple calls to call2(). How does the code structure reflect the structure of the AST?\nA: Similar to the prefix version we get\n\ncall2(\"if\", call2(\"&gt;\", sym(\"x\"), 1), \"a\", \"b\")\n#&gt; if (x &gt; 1) \"a\" else \"b\"\n\nWhen we read the AST from left to right, we get the same structure: Function to evaluate, expression, which is another function and is evaluated first, and two constants which will be evaluated next.\n\nast(`if`(x &gt; 1, \"a\", \"b\"))\n#&gt; █─`if` \n#&gt; ├─█─`&gt;` \n#&gt; │ ├─x \n#&gt; │ └─1 \n#&gt; ├─\"a\" \n#&gt; └─\"b\""
  },
  {
    "objectID": "18_Expressions.html#parsing-and-grammar",
    "href": "18_Expressions.html#parsing-and-grammar",
    "title": "18 - Expressions",
    "section": "Parsing and grammar",
    "text": "Parsing and grammar\nQ1: R uses parentheses in two slightly different ways as illustrated by these two calls:\n\nf((1))\n`(`(1 + 1)\n\nCompare and contrast the two uses by referencing the AST.\nA: The trick with these examples lies in the fact that ( can be a part of R’s general prefix function syntax but can also represent a call to the ( function.\nSo, in the AST of the first example, we will not see the outer ( since it is prefix function syntax and belongs to f(). In contrast, the inner ( is a function (represented as a symbol in the AST):\n\nast(f((1)))\n#&gt; █─f \n#&gt; └─█─`(` \n#&gt;   └─1\n\nIn the second example, we can see that the outer ( is a function and the inner ( belongs to its syntax:\n\nast(`(`(1 + 1))\n#&gt; █─`(` \n#&gt; └─█─`+` \n#&gt;   ├─1 \n#&gt;   └─1\n\nFor the sake of clarity, let’s also create a third example, where none of the ( is part of another function’s syntax:\n\nast(((1 + 1)))\n#&gt; █─`(` \n#&gt; └─█─`(` \n#&gt;   └─█─`+` \n#&gt;     ├─1 \n#&gt;     └─1\n\nQ2: = can also be used in two ways. Construct a simple example that shows both uses.\nA: = is used both for assignment, and for naming arguments in function calls:\n\nb &lt;- c(c = 1)\n\nSo, when we play with ast(), we can directly see that the following is not possible:\n\nast(b = c(c = 1))\n#&gt; Error in ast(b = c(c = 1)): unused argument (b = c(c = 1))\n\nWe get an error because b = makes R looking for an argument called b. Since x is the only argument of ast(), we get an error.\nThe easiest way around this problem is to wrap this line in {}.\n\nast({\n  b &lt;- c(c = 1)\n})\n#&gt; █─`{` \n#&gt; └─█─`&lt;-` \n#&gt;   ├─b \n#&gt;   └─█─c \n#&gt;     └─c = 1\n\nWhen we ignore the braces and compare the trees, we can see that the first = is used for assignment and the second = is part of the syntax of function calls.\nQ3: Does -2^2 yield 4 or -4? Why?\nA: It yields -4, because ^ has a higher operator precedence than -, which we can verify by looking at the AST (or looking it up under ?\"Syntax\"):\n\n-2^2\n#&gt; [1] -4\n\nast(-2^2)\n#&gt; █─`-` \n#&gt; └─█─`^` \n#&gt;   ├─2 \n#&gt;   └─2\n\nQ4: What does !1 + !1 return? Why?\nA: The answer is a little surprising:\n\n!1 + !1\n#&gt; [1] FALSE\n\nTo answer the “why?”, we take a look at the AST:\n\nast(!1 + !1)\n#&gt; █─`!` \n#&gt; └─█─`+` \n#&gt;   ├─1 \n#&gt;   └─█─`!` \n#&gt;     └─1\n\nThe right !1 is evaluated first. It evaluates to FALSE, because R coerces every non 0 numeric to TRUE, when a logical operator is applied. The negation of TRUE then equals FALSE.\nNext 1 + FALSE is evaluated to 1, since FALSE is coerced to 0.\nFinally !1 is evaluated to FALSE.\nNote that if ! had a higher precedence, the intermediate result would be FALSE + FALSE, which would evaluate to 0.\nQ5: Why does x1 &lt;- x2 &lt;- x3 &lt;- 0 work? Describe the two reasons.\nA: One reason is that &lt;- is right-associative, i.e. evaluation takes place from right to left:\n\nx1 &lt;- (x2 &lt;- (x3 &lt;- 0))\n\nThe other reason is that &lt;- invisibly returns the value on the right-hand side.\n\n(x3 &lt;- 0)\n#&gt; [1] 0\n\nQ6: Compare the ASTs of x + y %+% z and x ^ y %+% z. What have you learned about the precedence of custom infix functions?\nA: Let’s take a look at the syntax trees:\n\nast(x + y %+% z)\n#&gt; █─`+` \n#&gt; ├─x \n#&gt; └─█─`%+%` \n#&gt;   ├─y \n#&gt;   └─z\n\nHere y %+% z will be calculated first and the result will be added to x.\n\nast(x^y %+% z)\n#&gt; █─`%+%` \n#&gt; ├─█─`^` \n#&gt; │ ├─x \n#&gt; │ └─y \n#&gt; └─z\n\nHere x ^ y will be calculated first, and the result will be used as first argument to %+%().\nWe can conclude that custom infix functions have precedence between addition and exponentiation.\nThe exact precedence of infix functions can be looked up under ?\"Syntax\" where we see that it lies directly behind the sequence operator (:) and in front of the multiplication and division operators (* and /).\nQ7: What happens if you call parse_expr() with a string that generates multiple expressions, e.g. parse_expr(\"x + 1; y + 1\")?\nA: In this case parse_expr() notices that more than one expression would have to be generated and throws an error.\n\nparse_expr(\"x + 1; y + 1\")\n#&gt; Error in `parse_expr()`:\n#&gt; ! `x` must contain exactly 1 expression, not 2.\n\nQ8: What happens if you attempt to parse an invalid expression, e.g. \"a +\" or \"f())\"?\nA: Invalid expressions will lead to an error in the underlying parse() function.\n\nparse_expr(\"a +\")\n#&gt; Error in parse(text = x, keep.source = FALSE): &lt;text&gt;:2:0: unexpected end of input\n#&gt; 1: a +\n#&gt;    ^\nparse_expr(\"f())\")\n#&gt; Error in parse(text = x, keep.source = FALSE): &lt;text&gt;:1:4: unexpected ')'\n#&gt; 1: f())\n#&gt;        ^\n\nparse(text = \"a +\")\n#&gt; Error in parse(text = \"a +\"): &lt;text&gt;:2:0: unexpected end of input\n#&gt; 1: a +\n#&gt;    ^\nparse(text = \"f())\")\n#&gt; Error in parse(text = \"f())\"): &lt;text&gt;:1:4: unexpected ')'\n#&gt; 1: f())\n#&gt;        ^\n\nQ9: deparse() produces vectors when the input is long. For example, the following call produces a vector of length two:\n\nexpr &lt;- expr(g(a + b + c + d + e + f + g + h + i + j + k + l + m +\n  n + o + p + q + r + s + t + u + v + w + x + y + z))\n\ndeparse(expr)\n\nWhat does expr_text() do instead?\nA: expr_text() will paste the results from deparse(expr) together and use a linebreak (\\n) as separator.\n\nexpr &lt;- expr(g(a + b + c + d + e + f + g + h + i + j + k + l + m +\n  n + o + p + q + r + s + t + u + v + w + x + y + z))\ndeparse(expr)\n#&gt; [1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + \"\n#&gt; [2] \"o + p + q + r + s + t + u + v + w + x + y + z)\"\nexpr_text(expr)\n#&gt; [1] \"g(a + b + c + d + e + f + g + h + i + j + k + l + m + n\n#&gt; + \\n    o + p + q + r + s + t + u + v + w + x + y + z)\"\n\nQ10: pairwise.t.test() assumes that deparse() always returns a length one character vector. Can you construct an input that violates this expectation? What happens?\nA: The function pairwise.t.test() captures its data arguments (x and g) so it can print the input expressions along the computed p-values. Prior to R 4.0.0 this used to be implemented via deparse(substitute(x)) in combination with paste(). This could lead to unexpected output, if one of the inputs exceeded the default width.cutoff value of 60 characters within deparse(). In this case, the expression would be split into a character vector of length greater 1.\n\n# Output in R version 3.6.2\nd &lt;- 1\npairwise.t.test(2, d + d + d + d + d + d + d + d +\n  d + d + d + d + d + d + d + d + d)\n#&gt;  Pairwise comparisons using t tests with pooled SD\n#&gt;\n#&gt; data:  2 and d + d + d + d + d + d + d + d + d + d + d + d + d + d\n#&gt; + d + d +  2 and     d\n#&gt;\n#&gt; &lt;0 x 0 matrix&gt;\n#&gt;\n#&gt; P value adjustment method: holm\n\nIn R 4.0.0 pairwise.t.test() was updated to use the newly introduced deparse1(), which serves as a wrapper around deparse().\n\ndeparse1() is a simple utility added in R 4.0.0 to ensure a string result (character vector of length one), typically used in name construction, as deparse1(substitute(.)).\n\n\n# Output since R 4.0.0\nd &lt;- 1\npairwise.t.test(2, d + d + d + d + d + d + d + d +\n  d + d + d + d + d + d + d + d + d)\n#&gt;  Pairwise comparisons using t tests with pooled SD\n#&gt;\n#&gt; data:  2 and d + d + d + d + d + d + d + d + d + d + d + d + d + d\n#&gt; + d + d + d\n#&gt;\n#&gt; &lt;0 x 0 matrix&gt;\n#&gt;\n#&gt; P value adjustment method: holm"
  },
  {
    "objectID": "18_Expressions.html#ast-funs",
    "href": "18_Expressions.html#ast-funs",
    "title": "18 - Expressions",
    "section": "Walking AST with recursive functions",
    "text": "Walking AST with recursive functions\nQ1: logical_abbr() returns TRUE for T(1, 2, 3). How could you modify logical_abbr_rec() so that it ignores function calls that use T or F?\nA: We can apply a similar logic as in the assignment example from Advanced R. We just treat it as a special case handled within a sub function called find_T_call(), which finds T() calls and “bounces them out”. Therefore, we also repeat the expr_type() helper which tells us if we are in the base or in the recursive case.\n\nexpr_type &lt;- function(x) {\n  if (rlang::is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\n\nswitch_expr &lt;- function(x, ...) {\n  switch(expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \",\n      typeof(x),\n      call. = FALSE\n    )\n  )\n}\n\n\nfind_T_call &lt;- function(x) {\n  if (is_call(x, \"T\")) {\n    x &lt;- as.list(x)[-1]\n    purrr::some(x, logical_abbr_rec)\n  } else {\n    purrr::some(x, logical_abbr_rec)\n  }\n}\n\nlogical_abbr_rec &lt;- function(x) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = FALSE,\n    symbol = as_string(x) %in% c(\"F\", \"T\"),\n\n    # Recursive cases\n    pairlist = purrr::some(x, logical_abbr_rec),\n    call = find_T_call(x)\n  )\n}\n\nlogical_abbr &lt;- function(x) {\n  logical_abbr_rec(enexpr(x))\n}\n\nNow let’s test our new logical_abbr() function:\n\nlogical_abbr(T(1, 2, 3))\n#&gt; [1] FALSE\nlogical_abbr(T(T, T(3, 4)))\n#&gt; [1] TRUE\nlogical_abbr(T(T))\n#&gt; [1] TRUE\nlogical_abbr(T())\n#&gt; [1] FALSE\nlogical_abbr()\n#&gt; [1] FALSE\nlogical_abbr(c(T, T, T))\n#&gt; [1] TRUE\n\nQ2: logical_abbr() works with expressions. It currently fails when you give it a function. Why? How could you modify logical_abbr() to make it work? What components of a function will you need to recurse over?\n\nf &lt;- function(x = TRUE) {\n  g(x + T)\n}\n\nA: The function currently fails, because \"closure\" is not handled in switch_expr() within logical_abbr_rec().\n\nlogical_abbr(!!f)\n#&gt; Error: Don't know how to handle type closure\n\nIf we want to make it work, we have to write a function to also iterate over the formals and the body of the input function.\nQ3: Modify find_assign to also detect assignment using replacement functions, i.e. names(x) &lt;- y.\nA: Let’s see what the AST of such an assignment looks like:\n\nast(names(x) &lt;- x)\n#&gt; █─`&lt;-` \n#&gt; ├─█─names \n#&gt; │ └─x \n#&gt; └─x\n\nSo, we need to catch the case where the first two elements are both calls. Further the first call is identical to &lt;- and we must return only the second call to see which objects got new values assigned.\nThis is why we add the following block within another else statement in find_assign_call():\n\nif (is_call(x, \"&lt;-\") && is_call(x[[2]])) {\n  lhs &lt;- expr_text(x[[2]])\n  children &lt;- as.list(x)[-1]\n}\n\nLet us finish with the whole code, followed by some tests for our new function:\n\nflat_map_chr &lt;- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\n\nfind_assign &lt;- function(x) unique(find_assign_rec(enexpr(x)))\n\nfind_assign_call &lt;- function(x) {\n  if (is_call(x, \"&lt;-\") && is_symbol(x[[2]])) {\n    lhs &lt;- as_string(x[[2]])\n    children &lt;- as.list(x)[-1]\n  } else {\n    if (is_call(x, \"&lt;-\") && is_call(x[[2]])) {\n      lhs &lt;- expr_text(x[[2]])\n      children &lt;- as.list(x)[-1]\n    } else {\n      lhs &lt;- character()\n      children &lt;- as.list(x)\n    }\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = , symbol = character(),\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_assign_rec),\n    call = find_assign_call(x)\n  )\n}\n\n# Tests functionality\nfind_assign(x &lt;- y)\n#&gt; [1] \"x\"\nfind_assign(names(x))\n#&gt; character(0)\nfind_assign(names(x) &lt;- y)\n#&gt; [1] \"names(x)\"\nfind_assign(names(x(y)) &lt;- y)\n#&gt; [1] \"names(x(y))\"\nfind_assign(names(x(y)) &lt;- y &lt;- z)\n#&gt; [1] \"names(x(y))\" \"y\"\n\nQ4: Write a function that extracts all calls to a specified function.\nA: Here we need to delete the previously added else statement and check for a call (not necessarily &lt;-) within the first if() in find_assign_call(). We save a call when we found one and return it later as part of our character output. Everything else stays the same:\n\nfind_assign_call &lt;- function(x) {\n  if (is_call(x)) {\n    lhs &lt;- expr_text(x)\n    children &lt;- as.list(x)[-1]\n  } else {\n    lhs &lt;- character()\n    children &lt;- as.list(x)\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(\n    x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_assign_rec),\n    call = find_assign_call(x)\n  )\n}\n\nfind_assign(x &lt;- y)\n#&gt; [1] \"x &lt;- y\"\nfind_assign(names(x(y)) &lt;- y &lt;- z)\n#&gt; [1] \"names(x(y)) &lt;- y &lt;- z\" \"names(x(y))\"           \"x(y)\"                 \n#&gt; [4] \"y &lt;- z\"\nfind_assign(mean(sum(1:3)))\n#&gt; [1] \"mean(sum(1:3))\" \"sum(1:3)\"       \"1:3\""
  },
  {
    "objectID": "18_Expressions.html#references",
    "href": "18_Expressions.html#references",
    "title": "18 - Expressions",
    "section": "References",
    "text": "References\n\n\n\n\nHenry, Lionel, and Hadley Wickham. 2020. Rlang: Functions for Base Types and Core r and ’Tidyverse’ Features. https://github.com/r-lib/rlang.\n\n\nWickham, Hadley. 2019. Lobstr: Visualize r Data Structures with Trees. https://github.com/r-lib/lobstr."
  },
  {
    "objectID": "19_Quasiquotation.html#prerequisites",
    "href": "19_Quasiquotation.html#prerequisites",
    "title": "19 - Quasiquotation",
    "section": "Prerequisites",
    "text": "Prerequisites\nTo continue computing on the language, we keep using the {rlang} package in this chapter.\n\nlibrary(rlang)"
  },
  {
    "objectID": "19_Quasiquotation.html#motivation",
    "href": "19_Quasiquotation.html#motivation",
    "title": "19 - Quasiquotation",
    "section": "Motivation",
    "text": "Motivation\nQ1: For each function in the following base R code, identify which arguments are quoted and which are evaluated.\n\nlibrary(MASS)\n\nmtcars2 &lt;- subset(mtcars, cyl == 4)\n\nwith(mtcars2, sum(vs))\nsum(mtcars2$am)\n\nrm(mtcars2)\n\nA: For each argument we first follow the advice from Advanced R and execute the argument outside of the respective function. Since MASS, cyl, vs and am are not objects contained in the global environment, their execution raises an “Object not found” error. This way we confirm that the respective function arguments are quoted. For the other arguments, we may inspect the source code (and the documentation) to check if any quoting mechanisms are applied or the arguments are evaluated.\n\nlibrary(MASS) # MASS -&gt; quoted\n\nlibrary() also accepts character vectors and doesn’t quote when character.only is set to TRUE, so library(MASS, character.only = TRUE) would raise an error.\n\nmtcars2 &lt;- subset(mtcars, cyl == 4) # mtcars -&gt; evaluated\n# cyl -&gt; quoted\n\nwith(mtcars2, sum(vs)) # mtcars2 -&gt; evaluated\n# sum(vs) -&gt; quoted\n\nsum(mtcars2$am) # matcars$am -&gt; evaluated\n# am -&gt; quoted by $()\n\nWhen we inspect the source code of rm(), we notice that rm() catches its ... argument as an unevaluated call (in this case a pairlist) via match.call(). This call is then converted into a string for further evaluation.\n\nrm(mtcars2) # mtcars2 -&gt; quoted\n\nQ2: For each function in the following tidyverse code, identify which arguments are quoted and which are evaluated.\n\nlibrary(dplyr)\nlibrary(ggplot2)\n\nby_cyl &lt;- mtcars %&gt;%\n  group_by(cyl) %&gt;%\n  summarise(mean = mean(mpg))\n\nggplot(by_cyl, aes(cyl, mean)) +\n  geom_point()\n\nA: From the previous exercise we’ve already learned that library() quotes its first argument.\n\nlibrary(dplyr) # dplyr   -&gt; quoted\nlibrary(ggplot2) # ggplot2 -&gt; quoted\n\nIn similar fashion, it becomes clear that cyl is quoted by group_by().\n\nby_cyl &lt;- mtcars %&gt;% # mtcars -&gt; evaluated\n  group_by(cyl) %&gt;% # cyl -&gt; quoted\n  summarise(mean = mean(mpg)) # mean = mean(mpg) -&gt; quoted\n\nTo find out what happens in summarise(), we inspect the source code. Tracing down the S3-dispatch of summarise(), we see that the ... argument is quoted in dplyr:::summarise_cols() which is called in the underlying summarise.data.frame() method.\n\ndplyr::summarise\n#&gt; function (.data, ..., .by = NULL, .groups = NULL) \n#&gt; {\n#&gt;     by &lt;- enquo(.by)\n#&gt;     if (!quo_is_null(by) && !is.null(.groups)) {\n#&gt;         abort(\"Can't supply both `.by` and `.groups`.\")\n#&gt;     }\n#&gt;     UseMethod(\"summarise\")\n#&gt; }\n#&gt; &lt;bytecode: 0x632cfde74b50&gt;\n#&gt; &lt;environment: namespace:dplyr&gt;\n\n\ndplyr:::summarise.data.frame\n#&gt; function (.data, ..., .by = NULL, .groups = NULL) \n#&gt; {\n#&gt;     by &lt;- compute_by({\n#&gt;         {\n#&gt;             .by\n#&gt;         }\n#&gt;     }, .data, by_arg = \".by\", data_arg = \".data\")\n#&gt;     cols &lt;- summarise_cols(.data, dplyr_quosures(...), by, \"summarise\")\n#&gt;     out &lt;- summarise_build(by, cols)\n#&gt;     if (!cols$all_one) {\n#&gt;         summarise_deprecate_variable_size()\n#&gt;     }\n#&gt;     if (!is_tibble(.data)) {\n#&gt;         out &lt;- as.data.frame(out)\n#&gt;     }\n#&gt;     if (identical(.groups, \"rowwise\")) {\n#&gt;         out &lt;- rowwise_df(out, character())\n#&gt;     }\n#&gt;     out\n#&gt; }\n#&gt; &lt;bytecode: 0x632cf8b3b358&gt;\n#&gt; &lt;environment: namespace:dplyr&gt;\n\n\ndplyr:::summarise_cols\n#&gt; function (.data, ...)\n#&gt; {\n#&gt;     mask &lt;- DataMask$new(.data, caller_env())\n#&gt;     dots &lt;- enquos(...)\n#&gt;     dots_names &lt;- names(dots)\n#&gt;     auto_named_dots &lt;- names(enquos(..., .named = TRUE))\n#&gt;     cols &lt;- list()\n#&gt;     sizes &lt;- 1L\n#&gt;     chunks &lt;- vector(\"list\", length(dots))\n#&gt;     types &lt;- vector(\"list\", length(dots))\n#&gt;\n#&gt;     ## function definition abbreviated for clarity ##\n#&gt; }\n#&gt; &lt;bytecode: 0x55b540c07ca0&gt;\n#&gt; &lt;environment: namespace:dplyr&gt;\n\nIn the following {ggplot2} expression the cyl- and mean-objects are quoted.\n\nggplot(\n  by_cyl, # by_cyl -&gt; evaluated\n  aes(cyl, mean)\n) + # aes() -&gt; evaluated\n  # cyl, mean -&gt; quoted (via aes)\n  geom_point()\n\nWe can confirm this also by inspecting aes()’s source code.\n\nggplot2::aes\n#&gt; function (x, y, ...) \n#&gt; {\n#&gt;     xs &lt;- arg_enquos(\"x\")\n#&gt;     ys &lt;- arg_enquos(\"y\")\n#&gt;     dots &lt;- enquos(...)\n#&gt;     args &lt;- c(xs, ys, dots)\n#&gt;     args &lt;- Filter(Negate(quo_is_missing), args)\n#&gt;     local({\n#&gt;         aes &lt;- function(x, y, ...) NULL\n#&gt;         inject(aes(!!!args))\n#&gt;     })\n#&gt;     aes &lt;- new_aes(args, env = parent.frame())\n#&gt;     rename_aes(aes)\n#&gt; }\n#&gt; &lt;bytecode: 0x632cfc5e3ce0&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;"
  },
  {
    "objectID": "19_Quasiquotation.html#quoting",
    "href": "19_Quasiquotation.html#quoting",
    "title": "19 - Quasiquotation",
    "section": "Quoting",
    "text": "Quoting\nQ1: How is expr() implemented? Look at its source code.\nA: expr() acts as a simple wrapper, which passes its argument to enexpr().\n\nexpr\n#&gt; function (expr) \n#&gt; {\n#&gt;     enexpr(expr)\n#&gt; }\n#&gt; &lt;bytecode: 0x632cfc901de8&gt;\n#&gt; &lt;environment: namespace:rlang&gt;\n\nQ2: Compare and contrast the following two functions. Can you predict the output before running them?\n\nf1 &lt;- function(x, y) {\n  exprs(x = x, y = y)\n}\nf2 &lt;- function(x, y) {\n  enexprs(x = x, y = y)\n}\nf1(a + b, c + d)\nf2(a + b, c + d)\n\nA: Both functions are able to capture multiple arguments and will return a named list of expressions. f1() will return the arguments defined within the body of f1(). This happens because exprs() captures the expressions as specified by the developer during the definition of f1().\n\nf1(a + b, c + d)\n#&gt; $x\n#&gt; x\n#&gt; \n#&gt; $y\n#&gt; y\n\nf2() will return the arguments supplied to f2() as specified by the user when the function is called.\n\nf2(a + b, c + d)\n#&gt; $x\n#&gt; a + b\n#&gt; \n#&gt; $y\n#&gt; c + d\n\nQ3: What happens if you try to use enexpr() with an expression (i.e. enexpr(x + y))? What happens if enexpr() is passed a missing argument?\nA: In the first case an error is thrown:\n\non_expr &lt;- function(x) {\n  enexpr(expr(x))\n}\non_expr(x + y)\n#&gt; Error in `enexpr()`:\n#&gt; ! `arg` must be a symbol\n\nIn the second case a missing argument is returned:\n\non_missing &lt;- function(x) {\n  enexpr(x)\n}\non_missing()\nis_missing(on_missing())\n#&gt; [1] TRUE\n\nQ4: How are exprs(a) and exprs(a = ) different? Think about both the input and the output.\nA: In exprs(a) the input a is interpreted as a symbol for an unnamed argument. Consequently, the output shows an unnamed list with the first element containing the symbol a.\n\nout1 &lt;- exprs(a)\nstr(out1)\n#&gt; List of 1\n#&gt;  $ : symbol a\n\nIn exprs(a = ) the first argument is named a, but then no value is provided. This leads to the output of a named list with the first element named a, which contains the missing argument.\n\nout2 &lt;- exprs(a = )\nstr(out2)\n#&gt; List of 1\n#&gt;  $ a: symbol\nis_missing(out2$a)\n#&gt; [1] TRUE\n\nQ5: What are other differences between exprs() and alist()? Read the documentation for the named arguments of exprs() to find out.\nA: exprs() provides the additional arguments .named (= FALSE), .ignore_empty (c(\"trailing\", \"none\", \"all\")) and .unquote_names (TRUE). .named allows to ensure that all dots are named. ignore_empty allows to specify how empty arguments should be handled for dots (\"trailing\") or all arguments (\"none\" and \"all\"). Further via .unquote_names one can specify if := should be treated like =. := can be useful as it supports unquoting (!!) on the left-hand side.\nQ6: The documentation for substitute() says:\n\nSubstitution takes place by examining each component of the parse tree as follows:\n\nIf it is not a bound symbol in env, it is unchanged.\nIf it is a promise object (i.e. a formal argument to a function) the expression slot of the promise replaces the symbol.\nIf it is an ordinary variable, its value is substituted, unless env is .GlobalEnv in which case the symbol is left unchanged.\n\n\nCreate examples that illustrate each of the above cases.\nA: Let’s create a new environment my_env, which contains no objects. In this case substitute() will just return its first argument (expr):\n\nmy_env &lt;- env()\nsubstitute(x, my_env)\n#&gt; x\n\nWhen we create a function containing an argument, which is directly returned after substitution, this function just returns the provided expression:\n\nfoo &lt;- function(x) substitute(x)\n\nfoo(x + y * sin(0))\n#&gt; x + y * sin(0)\n\nIn case substitute() can find (parts of) the expression in env, it will literally substitute. However, unless env is .GlobalEnv.\n\nmy_env$x &lt;- 7\nsubstitute(x, my_env)\n#&gt; [1] 7\n\nx &lt;- 7\nsubstitute(x, .GlobalEnv)\n#&gt; x"
  },
  {
    "objectID": "19_Quasiquotation.html#unquoting",
    "href": "19_Quasiquotation.html#unquoting",
    "title": "19 - Quasiquotation",
    "section": "Unquoting",
    "text": "Unquoting\nQ1: Given the following components:\n\nxy &lt;- expr(x + y)\nxz &lt;- expr(x + z)\nyz &lt;- expr(y + z)\nabc &lt;- exprs(a, b, c)\n\nUse quasiquotation to construct the following calls:\n\n(x + y) / (y + z) # (1)\n-(x + z)^(y + z) # (2)\n(x + y) + (y + z) - (x + y) # (3)\natan2(x + y, y + z) # (4)\nsum(x + y, x + y, y + z) # (5)\nsum(a, b, c) # (6)\nmean(c(a, b, c), na.rm = TRUE) # (7)\nfoo(a = x + y, b = y + z) # (8)\n\nA: We combine and unquote the given quoted expressions to construct the desired calls like this:\n\nexpr(!!xy / !!yz) # (1)\n#&gt; (x + y)/(y + z)\n\nexpr(-(!!xz)^(!!yz)) # (2)\n#&gt; -(x + z)^(y + z)\n\nexpr(((!!xy)) + !!yz - !!xy) # (3)\n#&gt; (x + y) + (y + z) - (x + y)\n\nexpr(atan2(!!xy, !!yz)) # (4)\n#&gt; atan2(x + y, y + z)\n\nexpr(sum(!!xy, !!xy, !!yz)) # (5)\n#&gt; sum(x + y, x + y, y + z)\n\nexpr(sum(!!!abc)) # (6)\n#&gt; sum(a, b, c)\n\nexpr(mean(c(!!!abc), na.rm = TRUE)) # (7)\n#&gt; mean(c(a, b, c), na.rm = TRUE)\n\nexpr(foo(a = !!xy, b = !!yz)) # (8)\n#&gt; foo(a = x + y, b = y + z)\n\nQ2: The following two calls print the same, but are actually different:\n\n(a &lt;- expr(mean(1:10)))\n#&gt; mean(1:10)\n(b &lt;- expr(mean(!!(1:10))))\n#&gt; mean(1:10)\nidentical(a, b)\n#&gt; [1] FALSE\n\nWhat’s the difference? Which one is more natural?\nA: It’s easiest to see the difference with lobstr::ast():\n\nlobstr::ast(mean(1:10))\n#&gt; █─mean \n#&gt; └─█─`:` \n#&gt;   ├─1 \n#&gt;   └─10\nlobstr::ast(mean(!!(1:10)))\n#&gt; █─mean \n#&gt; └─&lt;inline integer&gt;\n\nIn the expression mean(!!(1:10)) the call 1:10 is evaluated to an integer vector, while still being a call object in mean(1:10).\nThe first version (mean(1:10)) seems more natural. It captures lazy evaluation, with a promise that is evaluated when the function is called. The second version (mean(!!(1:10))) inlines a vector directly into a call."
  },
  {
    "objectID": "19_Quasiquotation.html#dot-dot-dot",
    "href": "19_Quasiquotation.html#dot-dot-dot",
    "title": "19 - Quasiquotation",
    "section": "... (dot-dot-dot)",
    "text": "... (dot-dot-dot)\nQ1: One way to implement exec() is shown below. Describe how it works. What are the key ideas?\n\nexec &lt;- function(f, ..., .env = caller_env()) {\n  args &lt;- list2(...)\n  do.call(f, args, envir = .env)\n}\n\nA: exec() takes a function (f), its arguments (...) and an environment (.env) as input. This allows to construct a call from f and ... and evaluate this call in the supplied environment. As the ... argument is handled via list2(), exec() supports tidy dots (quasiquotation), which means that arguments and names (on the left-hand side of :=) can be unquoted via !! and !!!.\nQ2: Carefully read the source code for interaction(), expand.grid(), and par(). Compare and contrast the techniques they use for switching between dots and list behaviour.\nA: All three functions capture the dots via args &lt;- list(...).\ninteraction() computes factor interactions between the captured input factors by iterating over the args. When a list is provided this is detected via length(args) == 1 && is.list(args[[1]]) and one level of the list is stripped through args &lt;- args[[1]]. The rest of the function’s code doesn’t differentiate further between list and dots behaviour.\n\n# Both calls create the same output\ninteraction(a = c(\"a\", \"b\", \"c\", \"d\"), b = c(\"e\", \"f\")) # dots\n#&gt; [1] a.e b.f c.e d.f\n#&gt; Levels: a.e b.e c.e d.e a.f b.f c.f d.f\ninteraction(list(a = c(\"a\", \"b\", \"c\", \"d\"), b = c(\"e\", \"f\"))) # list\n#&gt; [1] a.e b.f c.e d.f\n#&gt; Levels: a.e b.e c.e d.e a.f b.f c.f d.f\n\nexpand.grid() uses the same strategy and also assigns args &lt;- args[[1]] in case of length(args) == 1 && is.list(args[[1]]).\npar() does the most pre-processing to ensure a valid structure of the args argument. When no dots are provided (!length(args)) it creates a list of arguments from an internal character vector (partly depending on its no.readonly argument). Further, given that all elements of args are character vectors (all(unlist(lapply(args, is.character)))), args is turned into a list via as.list(unlist(args)) (this flattens nested lists). Similar to the other functions, one level of args gets stripped via args &lt;- args[[1L]], when args is of length one and its first element is a list.\nQ3: Explain the problem with this definition of set_attr()\n\nset_attr &lt;- function(x, ...) {\n  attr &lt;- rlang::list2(...)\n  attributes(x) &lt;- attr\n  x\n}\nset_attr(1:10, x = 10)\n#&gt; Error in attributes(x) &lt;- attr: attributes must be named\n\nA: set_attr() expects an object named x and its attributes, supplied via the dots. Unfortunately, this prohibits us to provide attributes named x as these would collide with the argument name of our object. Even omitting the object’s argument name doesn’t help in this case — as can be seen in the example where the object is consequently treated as an unnamed attribute.\nHowever, we may name the first argument .x, which seems clearer and less likely to invoke errors. In this case 1:10 will get the (named) attribute x = 10 assigned:\n\nset_attr &lt;- function(.x, ...) {\n  attr &lt;- rlang::list2(...)\n\n  attributes(.x) &lt;- attr\n  .x\n}\n\nset_attr(1:10, x = 10)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n#&gt; attr(,\"x\")\n#&gt; [1] 10"
  },
  {
    "objectID": "19_Quasiquotation.html#expr-case-studies",
    "href": "19_Quasiquotation.html#expr-case-studies",
    "title": "19 - Quasiquotation",
    "section": "Case studies",
    "text": "Case studies\nQ1: In the linear-model example, we could replace the expr() in reduce(summands, ~ expr(!!.x + !!.y)) with call2(): reduce(summands, call2, \"+\"). Compare and contrast the two approaches. Which do you think is easier to read?\nA: We would consider the first version to be more readable. There seems to be a little more boilerplate code at first, but the unquoting syntax is very readable. Overall, the whole expression seems more explicit and less complex.\nQ2: Re-implement the Box-Cox transform defined below using unquoting and new_function():\n\nbc &lt;- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x^lambda - 1) / lambda\n  }\n}\n\nA: Here new_function() allows us to create a function factory using tidy evaluation.\n\nbc2 &lt;- function(lambda) {\n  lambda &lt;- enexpr(lambda)\n\n  if (!!lambda == 0) {\n    new_function(exprs(x = ), expr(log(x)))\n  } else {\n    new_function(exprs(x = ), expr((x^(!!lambda) - 1) / !!lambda))\n  }\n}\n\nbc2(0)\n#&gt; function (x) \n#&gt; log(x)\n#&gt; &lt;environment: 0x632cfd501268&gt;\nbc2(2)\n#&gt; function (x) \n#&gt; (x^2 - 1)/2\n#&gt; &lt;environment: 0x632cfd573528&gt;\nbc2(2)(2)\n#&gt; [1] 1.5\n\nQ3: Re-implement the simple compose() defined below using quasiquotation and new_function():\n\ncompose &lt;- function(f, g) {\n  function(...) f(g(...))\n}\n\nA: The implementation is fairly straightforward, even though a lot of parentheses are required:\n\ncompose2 &lt;- function(f, g) {\n  f &lt;- enexpr(f)\n  g &lt;- enexpr(g)\n\n  new_function(exprs(... = ), expr((!!f)((!!g)(...))))\n}\n\ncompose(sin, cos)\n#&gt; function(...) f(g(...))\n#&gt; &lt;environment: 0x632cfbc88290&gt;\ncompose(sin, cos)(pi)\n#&gt; [1] -0.841\n\ncompose2(sin, cos)\n#&gt; function (...) \n#&gt; sin(cos(...))\n#&gt; &lt;environment: 0x632cfc1fbf80&gt;\ncompose2(sin, cos)(pi)\n#&gt; [1] -0.841"
  },
  {
    "objectID": "20_Evaluation.html#prerequisites",
    "href": "20_Evaluation.html#prerequisites",
    "title": "20 - Evaluation",
    "section": "Prerequisites",
    "text": "Prerequisites\nOn our journey through R’s metaprogramming, we continue to use the functions from the {rlang} package.\n\nlibrary(rlang)"
  },
  {
    "objectID": "20_Evaluation.html#evaluation-basics",
    "href": "20_Evaluation.html#evaluation-basics",
    "title": "20 - Evaluation",
    "section": "Evaluation basics",
    "text": "Evaluation basics\nQ1: Carefully read the documentation for source(). What environment does it use by default? What if you supply local = TRUE? How do you provide a custom environment?\nA: By default, source() uses the global environment (local = FALSE). A specific evaluation environment may be chosen, by passing it explicitly to the local argument. To use current environment (i.e. the calling environment of source()) set local = TRUE.\n\n# Create a temporary, sourceable R script that prints x\ntmp_file &lt;- tempfile()\nwriteLines(\"print(x)\", tmp_file)\n\n# Set `x` globally\nx &lt;- \"global environment\"\nenv2 &lt;- env(x = \"specified environment\")\n\nlocate_evaluation &lt;- function(file, local) {\n  x &lt;- \"local environment\"\n  source(file, local = local)\n}\n\n# Where will source() evaluate the code?\nlocate_evaluation(tmp_file, local = FALSE) # default\n#&gt; [1] \"global environment\"\nlocate_evaluation(tmp_file, local = env2)\n#&gt; [1] \"specified environment\"\nlocate_evaluation(tmp_file, local = TRUE)\n#&gt; [1] \"local environment\"\n\nQ2: Predict the results of the following lines of code:\n\neval(expr(eval(expr(eval(expr(2 + 2)))))) # (1)\neval(eval(expr(eval(expr(eval(expr(2 + 2))))))) # (2)\nexpr(eval(expr(eval(expr(eval(expr(2 + 2))))))) # (3)\n\nA: Let’s look at a quote from the first edition of Advanced R:\n\n“expr() and eval() are opposites. […] each eval() peels off one layer of expr()’s”.\n\nIn general, eval(expr(x)) evaluates to x. Therefore, (1) evaluates to \\(2 + 2 = 4\\). Adding another eval() doesn’t have impact here. So, also (2) evaluates to 4. However, when wrapping (1) into expr() the whole expression will be quoted.\n\neval(expr(eval(expr(eval(expr(2 + 2)))))) # (1)\n#&gt; [1] 4\neval(eval(expr(eval(expr(eval(expr(2 + 2))))))) # (2)\n#&gt; [1] 4\nexpr(eval(expr(eval(expr(eval(expr(2 + 2))))))) # (3)\n#&gt; eval(expr(eval(expr(eval(expr(2 + 2))))))\n\nQ3: Fill in the function bodies below to re-implement get() using sym() and eval(), and assign() using sym(), expr(), and eval(). Don’t worry about the multiple ways of choosing an environment that get() and assign() support; assume that the user supplies it explicitly.\n\n# name is a string\nget2 &lt;- function(name, env) {}\nassign2 &lt;- function(name, value, env) {}\n\nA: We reimplement these two functions using tidy evaluation. We turn the string name into a symbol, then evaluate it:\n\nget2 &lt;- function(name, env = caller_env()) {\n  name_sym &lt;- sym(name)\n  eval(name_sym, env)\n}\n\nx &lt;- 1\nget2(\"x\")\n#&gt; [1] 1\n\nTo build the correct expression for the value assignment, we unquote using !!.\n\nassign2 &lt;- function(name, value, env = caller_env()) {\n  name_sym &lt;- sym(name)\n  assign_expr &lt;- expr(!!name_sym &lt;- !!value)\n  eval(assign_expr, env)\n}\n\nassign2(\"x\", 4)\nx\n#&gt; [1] 4\n\nQ4: Modify source2() so it returns the result of every expression, not just the last one. Can you eliminate the for loop?\nA: The code for source2() was given in Advanced R as:\n\nsource2 &lt;- function(path, env = caller_env()) {\n  file &lt;- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs &lt;- parse_exprs(file)\n\n  res &lt;- NULL\n  for (i in seq_along(exprs)) {\n    res &lt;- eval(exprs[[i]], env)\n  }\n\n  invisible(res)\n}\n\nIn order to highlight the modifications in our new source2() function, we’ve preserved the differing code from the former source2() in a comment.\n\nsource2 &lt;- function(path, env = caller_env()) {\n  file &lt;- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs &lt;- parse_exprs(file)\n\n  # res &lt;- NULL\n  # for (i in seq_along(exprs)) {\n  #   res[[i]] &lt;- eval(exprs[[i]], env)\n  # }\n\n  res &lt;- purrr::map(exprs, eval, env)\n\n  invisible(res)\n}\n\nLet’s create a file and test source2(). Keep in mind that &lt;- returns invisibly.\n\ntmp_file &lt;- tempfile()\nwriteLines(\n  \"x &lt;- 1\n       x\n       y &lt;- 2\n       y  # some comment\",\n  tmp_file\n)\n\n(source2(tmp_file))\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 2\n\nQ5: We can make base::local() slightly easier to understand by spreading it over multiple lines:\n\nlocal3 &lt;- function(expr, envir = new.env()) {\n  call &lt;- substitute(eval(quote(expr), envir))\n  eval(call, envir = parent.frame())\n}\n\nExplain how local() works in words. (Hint: you might want to print(call) to help understand what substitute() is doing, and read the documentation to remind yourself what environment new.env() will inherit from.)\nA: Let’s follow the advice and add print(call) inside of local3():\n\nlocal3 &lt;- function(expr, envir = new.env()) {\n  call &lt;- substitute(eval(quote(expr), envir))\n  print(call)\n  eval(call, envir = parent.frame())\n}\n\nThe first line generates a call to eval(), because substitute() operates in the current evaluation argument. However, this doesn’t matter here, as both, expr and envir are promises and therefore “the expression slots of the promises replace the symbols”, from ?substitute.\n\nlocal3({\n  x &lt;- 10\n  x * 2\n})\n#&gt; eval(quote({\n#&gt;     x &lt;- 10\n#&gt;     x * 2\n#&gt; }), new.env())\n#&gt; [1] 20\n\nNext, call will be evaluated in the caller environment (aka the parent frame). Given that call contains another call eval() why does this matter? The answer is subtle: this outer environment determines where the bindings for eval, quote, and new.env are found. \n\neval(quote({\n  x &lt;- 10\n  x * 2\n}), new.env())\n#&gt; [1] 20\nexists(\"x\")\n#&gt; [1] TRUE"
  },
  {
    "objectID": "20_Evaluation.html#quosures",
    "href": "20_Evaluation.html#quosures",
    "title": "20 - Evaluation",
    "section": "Quosures",
    "text": "Quosures\nQ1: Predict what evaluating each of the following quosures will return if evaluated.\n\nq1 &lt;- new_quosure(expr(x), env(x = 1))\nq1\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x\n#&gt; env:  0x5c4a1926acd8\n\nq2 &lt;- new_quosure(expr(x + !!q1), env(x = 10))\nq2\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x + (^x)\n#&gt; env:  0x5c4a1a129268\n\nq3 &lt;- new_quosure(expr(x + !!q2), env(x = 100))\nq3\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x + (^x + (^x))\n#&gt; env:  0x5c4a1a590570\n\nA: Each quosure is evaluated in its own environment, so x is bound to a different value for each time. This leads us to:\n\neval_tidy(q1)\n#&gt; [1] 1\neval_tidy(q2)\n#&gt; [1] 11\neval_tidy(q3)\n#&gt; [1] 111\n\nQ2: Write an enenv() function that captures the environment associated with an argument. (Hint: this should only require two function calls.)\nA: A quosure captures both the expression and the environment. From a quosure, we can access the environment with the help of get_env().\n\nenenv &lt;- function(x) {\n  get_env(enquo(x))\n}\n\n# Test\nenenv(x)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n# Test if it also works within functions\ncapture_env &lt;- function(x) {\n  enenv(x)\n}\ncapture_env(x)\n#&gt; &lt;environment: 0x5c4a18b688b0&gt;"
  },
  {
    "objectID": "20_Evaluation.html#data-masks",
    "href": "20_Evaluation.html#data-masks",
    "title": "20 - Evaluation",
    "section": "Data masks",
    "text": "Data masks\nQ1: Why did I use a for loop in transform2() instead of map()? Consider transform2(df, x = x * 2, x = x * 2).\nA: transform2() was defined in Advanced R as:\n\ntransform2 &lt;- function(.data, ...) {\n  dots &lt;- enquos(...)\n\n  for (i in seq_along(dots)) {\n    name &lt;- names(dots)[[i]]\n    dot &lt;- dots[[i]]\n\n    .data[[name]] &lt;- eval_tidy(dot, .data)\n  }\n\n  .data\n}\n\nA for loop applies the processing steps regarding .data iteratively. This includes updating .data and reusing the same variable names. This makes it possible to apply transformations sequentially, so that subsequent transformations can refer to columns that were just created.\nQ2: Here’s an alternative implementation of subset2():\n\nsubset3 &lt;- function(data, rows) {\n  rows &lt;- enquo(rows)\n  eval_tidy(expr(data[!!rows, , drop = FALSE]), data = data)\n}\n\ndf &lt;- data.frame(x = 1:3)\nsubset3(df, x == 1)\n\nCompare and contrast subset3() to subset2(). What are its advantages and disadvantages?\nA: Let’s take a closer look at subset2() first:\n\nsubset2 &lt;- function(data, rows) {\n  rows &lt;- enquo(rows)\n  rows_val &lt;- eval_tidy(rows, data)\n  stopifnot(is.logical(rows_val))\n\n  data[rows_val, , drop = FALSE]\n}\n\nsubset2() provides an additional logical check, which is missing from subset3(). Here, rows is evaluated in the context of data, which results in a logical vector. Afterwards only [ needs to be used for subsetting.\n\n# subset2() evaluation\n(rows_val &lt;- eval_tidy(quo(x == 1), df))\n#&gt; [1]  TRUE FALSE FALSE\ndf[rows_val, , drop = FALSE]\n#&gt;   x\n#&gt; 1 1\n\nWith subset3() both of these steps occur in a single line (which is probably closer to what one would produce by hand). This means that the subsetting is also evaluated in the context of the data mask.\n\n# subset3() evaluation\neval_tidy(expr(df[x == 1, , drop = FALSE]), df)\n#&gt;   x\n#&gt; 1 1\n\nThis is shorter (but probably also less readable) because the evaluation and the subsetting take place in the same expression. However, it may introduce unwanted errors, if the data mask contains an element named “data”, as the objects from the data mask take precedence over arguments of the function.\n\ndf &lt;- data.frame(x = 1:3, data = 1)\nsubset2(df, x == 1)\n#&gt;   x data\n#&gt; 1 1    1\nsubset3(df, x == 1)\n#&gt; Error in data[~x == 1, , drop = FALSE]: incorrect number of dimensions\n\nQ3: The following function implements the basics of dplyr::arrange(). Annotate each line with a comment explaining what it does. Can you explain why !!.na.last is strictly correct, but omitting the !! is unlikely to cause problems?\n\narrange2 &lt;- function(.df, ..., .na.last = TRUE) {\n  args &lt;- enquos(...)\n\n  order_call &lt;- expr(order(!!!args, na.last = !!.na.last))\n\n  ord &lt;- eval_tidy(order_call, .df)\n  stopifnot(length(ord) == nrow(.df))\n\n  .df[ord, , drop = FALSE]\n}\n\nA: arrange2() basically reorders a data frame by one or more of its variables. As arrange2() allows to provide the variables as expressions (via ...), these need to be quoted first. Afterwards they are used to build up an order() call, which is then evaluated in the context of the data frame. Finally, the data frame is reordered via integer subsetting. Let’s take a closer look at the source code:\n\narrange2 &lt;- function(.df, ..., .na.last = TRUE) {\n  # Capture and quote arguments, which determine the order\n  args &lt;- enquos(...)\n\n  # `!!!`: unquote-splice arguments into order()\n  # `!!.na.last`: pass option for treatment of NAs to order()\n  # return expression-object\n  order_call &lt;- expr(order(!!!args, na.last = !!.na.last))\n\n  # Evaluate order_call within .df\n  ord &lt;- eval_tidy(order_call, .df)\n  # Ensure that no rows are dropped\n  stopifnot(length(ord) == nrow(.df))\n\n  # Reorder rows via integer subsetting\n  .df[ord, , drop = FALSE]\n}\n\nBy using !!.na.last the .na.last argument is unquoted when the order() call is built. This way, the na.last argument is already correctly specified (typically TRUE, FALSE or NA).\nWithout the unquoting, the expression would read na.last = .na.last and the value for .na.last would still need to be looked up and found. Because these computations take place inside of the function’s execution environment (which contains .na.last), this is unlikely to cause problems.\n\n# The effect of unquoting .na.last\n.na.last &lt;- FALSE\nexpr(order(..., na.last = !!.na.last))\n#&gt; order(..., na.last = FALSE)\nexpr(order(..., na.last = .na.last))\n#&gt; order(..., na.last = .na.last)"
  },
  {
    "objectID": "20_Evaluation.html#using-tidy-evaluation",
    "href": "20_Evaluation.html#using-tidy-evaluation",
    "title": "20 - Evaluation",
    "section": "Using tidy evaluation",
    "text": "Using tidy evaluation\nQ1: I’ve included an alternative implementation of threshold_var() below. What makes it different to the approach I used above? What makes it harder?\n\nthreshold_var2 &lt;- function(df, var, val) {\n  var &lt;- ensym(var)\n\n  subset2(df, `$`(.data, !!var) &gt;= !!val)\n}\n\nA: Let’s compare this approach to the original implementation:\n\nthreshold_var &lt;- function(df, var, val) {\n  var &lt;- as_string(ensym(var))\n  subset2(df, .data[[var]] &gt;= !!val)\n}\n\nWe can see that threshold_var2() no longer coerces the symbol to a string. Therefore $ instead of [[ can be used for subsetting. Initially we suspected partial matching would be introduced by $, but .data deliberately avoids this problem.\nThe prefix call to $() is less common than infix-subsetting using [[, but ultimately both functions behave the same.\n\ndf &lt;- data.frame(x = 1:10)\nthreshold_var(df, x, 8)\n#&gt;     x\n#&gt; 8   8\n#&gt; 9   9\n#&gt; 10 10\nthreshold_var2(df, x, 8)\n#&gt;     x\n#&gt; 8   8\n#&gt; 9   9\n#&gt; 10 10"
  },
  {
    "objectID": "20_Evaluation.html#base-evaluation",
    "href": "20_Evaluation.html#base-evaluation",
    "title": "20 - Evaluation",
    "section": "Base evaluation",
    "text": "Base evaluation\nQ1: Why does this function fail?\n\nlm3a &lt;- function(formula, data) {\n  formula &lt;- enexpr(formula)\n\n  lm_call &lt;- expr(lm(!!formula, data = data))\n  eval(lm_call, caller_env())\n}\nlm3a(mpg ~ disp, mtcars)$call\n#&gt; Error in model.frame.default(formula = mpg ~ disp, data = data, drop.unused.levels = TRUE): 'data' must be a data.frame, environment, or list\n\nA: In this function, lm_call is evaluated in the caller environment, which happens to be the global environment. In this environment, the name data is bound to utils::data. To fix the error, we can either set the evaluation environment to the function’s execution environment or unquote the data argument when building the call to lm().\n\n# Change evaluation environment\nlm3b &lt;- function(formula, data) {\n  formula &lt;- enexpr(formula)\n\n  lm_call &lt;- expr(lm(!!formula, data = data))\n  eval(lm_call, current_env())\n}\n\nlm3b(mpg ~ disp, mtcars)$call\n#&gt; lm(formula = mpg ~ disp, data = data)\nlm3b(mpg ~ disp, data)$call # reproduces original error\n#&gt; Error in model.frame.default(formula = mpg ~ disp, data = data, drop.unused.levels = TRUE): 'data' must be a data.frame, environment, or list\n\nWhen we want to unquote an argument within a function, we first need to capture the user-input (by enexpr()).\n\n# Unquoting data-argument\nlm3c &lt;- function(formula, data) {\n  formula &lt;- enexpr(formula)\n  data_quo &lt;- enexpr(data)\n\n  lm_call &lt;- expr(lm(!!formula, data = !!data_quo))\n  eval(lm_call, caller_env())\n}\nlm3c(mpg ~ disp, mtcars)$call\n#&gt; lm(formula = mpg ~ disp, data = mtcars)\n\nQ2: When model building, typically the response and data are relatively constant while you rapidly experiment with different predictors. Write a small wrapper that allows you to reduce duplication in the code below.\n\nlm(mpg ~ disp, data = mtcars)\nlm(mpg ~ I(1 / disp), data = mtcars)\nlm(mpg ~ disp * cyl, data = mtcars)\n\nA: In our wrapper lm_wrap(), we provide mpg and mtcars as default response and data. This seems to give us a good mix of usability and flexibility.\n\nlm_wrap &lt;- function(pred, resp = mpg, data = mtcars,\n                    env = caller_env()) {\n  pred &lt;- enexpr(pred)\n  resp &lt;- enexpr(resp)\n  data &lt;- enexpr(data)\n\n  formula &lt;- expr(!!resp ~ !!pred)\n  lm_call &lt;- expr(lm(!!formula, data = !!data))\n  eval(lm_call, envir = env)\n}\n\n# Test if the output looks ok\nlm_wrap(I(1 / disp) + disp * cyl)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = mpg ~ I(1/disp) + disp * cyl, data = mtcars)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)    I(1/disp)         disp          cyl     disp:cyl  \n#&gt;   -1.22e+00     1.85e+03     7.68e-02     1.18e+00    -9.14e-03\n\n# Test if the result is identical to calling lm() directly\nidentical(\n  lm_wrap(I(1 / disp) + disp * cyl),\n  lm(mpg ~ I(1 / disp) + disp * cyl, data = mtcars)\n)\n#&gt; [1] TRUE\n\nQ3: Another way to write resample_lm() would be to include the resample expression (data[sample(nrow(data), replace = TRUE), , drop = FALSE]) in the data argument. Implement that approach. What are the advantages? What are the disadvantages?\nA: Different versions of resample_lm() were given in Advanced R. However, none of them implemented the resampling within the function argument.\nDifferent versions of resample_lm() (resample_lm0(), resample_lm1(), resample_lm2()) were specified in Advanced R. However, in none of these versions was the resampling step implemented in any of the arguments.\nThis approach takes advantage of R’s lazy evaluation of function arguments, by moving the resampling step into the argument definition. The user passes the data to the function, but only a permutation of this data (resample_data) will be used.\n\nresample_lm &lt;- function(\n    formula, data,\n    resample_data = data[sample(nrow(data), replace = TRUE), ,\n      drop = FALSE\n    ],\n    env = current_env()) {\n  formula &lt;- enexpr(formula)\n\n  lm_call &lt;- expr(lm(!!formula, data = resample_data))\n  expr_print(lm_call)\n  eval(lm_call, env)\n}\n\ndf &lt;- data.frame(x = 1:10, y = 5 + 3 * (1:10) + round(rnorm(10), 2))\n(lm_1 &lt;- resample_lm(y ~ x, data = df))\n#&gt; lm(y ~ x, data = resample_data)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = y ~ x, data = resample_data)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)            x  \n#&gt;        4.85         3.02\nlm_1$call\n#&gt; lm(formula = y ~ x, data = resample_data)\n\nWith this approach the evaluation needs to take place within the function’s environment, because the resampled dataset (defined as a default argument) will only be available in the function environment.\nOverall, putting an essential part of the pre-processing outside of the functions body is not common practice in R. Compared to the unquoting-implementation (resample_lm1() in Advanced R), this approach captures the model-call in a more meaningful way. This approach will also lead to a new resample every time you update() the model."
  },
  {
    "objectID": "20_Evaluation.html#references",
    "href": "20_Evaluation.html#references",
    "title": "20 - Evaluation",
    "section": "References",
    "text": "References"
  },
  {
    "objectID": "21_Translating_R_code.html#prerequisites",
    "href": "21_Translating_R_code.html#prerequisites",
    "title": "21 - Translating R code",
    "section": "Prerequisites",
    "text": "Prerequisites\nIn this chapter we combine R’s metaprogramming and functional programming capabilities and therefore load both the {rlang} and the {purrr} package.\n\nlibrary(rlang)\nlibrary(purrr)"
  },
  {
    "objectID": "21_Translating_R_code.html#html",
    "href": "21_Translating_R_code.html#html",
    "title": "21 - Translating R code",
    "section": "HTML",
    "text": "HTML\nQ1: The escaping rules for &lt;script&gt; tags are different because they contain JavaScript, not HTML. Instead of escaping angle brackets or ampersands, you need to escape &lt;/script&gt; so that the tag isn’t closed too early. For example, script(\"'&lt;/script&gt;'\"), shouldn’t generate this:\n\n&lt;script&gt;'&lt;/script&gt;'&lt;/script&gt;\n\nBut\n\n&lt;script&gt;'&lt;\\/script&gt;'&lt;/script&gt;\n\nAdapt the escape() to follow these rules when a new argument script is set to TRUE.\nA: We are asked to implement a special case of escaping for the &lt;script&gt; tag. At first we will revisit the relevant functions provided in Advanced R and confirm that our code reliably escapes for tags like &lt;p&gt; and &lt;b&gt; but doesn’t escape correctly for the &lt;script&gt; tag. Then we modify the escape() and tag() functions to redefine the &lt;script&gt; tag and confirm that all defined tags now escape correctly.\nNote that the &lt;style&gt; tag, which contains styling information in CSS, follows the same escaping rules as the &lt;script&gt; tag. We therefore implement the desired escaping for the &lt;style&gt; tag function also.\nLet’s start by loading the relevant code from Advanced R first.\n\n# Escaping\nhtml &lt;- function(x) structure(x, class = \"advr_html\")\n\nprint.advr_html &lt;- function(x, ...) {\n  out &lt;- paste0(\"&lt;HTML&gt; \", x)\n  cat(paste(strwrap(out), collapse = \"\\n\"), \"\\n\", sep = \"\")\n}\n\nescape &lt;- function(x) UseMethod(\"escape\")\n\nescape.character &lt;- function(x) {\n  x &lt;- gsub(\"&\", \"&amp;\", x)\n  x &lt;- gsub(\"&lt;\", \"&lt;\", x)\n  x &lt;- gsub(\"&gt;\", \"&gt;\", x)\n\n  html(x)\n}\n\nescape.advr_html &lt;- function(x) x\n\n# Basic tag functions\ndots_partition &lt;- function(...) {\n  dots &lt;- list2(...)\n\n  if (is.null(names(dots))) {\n    is_named &lt;- rep(FALSE, length(dots))\n  } else {\n    is_named &lt;- names(dots) != \"\"\n  }\n\n  list(\n    named = dots[is_named],\n    unnamed = dots[!is_named]\n  )\n}\n\n# html_attributes() function from the GitHub repository of Advanced R\n# https://github.com/hadley/adv-r/blob/master/dsl-html-attributes.r\n\nhtml_attributes &lt;- function(list) {\n  if (length(list) == 0) {\n    return(\"\")\n  }\n\n  attr &lt;- map2_chr(names(list), list, html_attribute)\n  paste0(\" \", unlist(attr), collapse = \"\")\n}\n\nhtml_attribute &lt;- function(name, value = NULL) {\n  if (length(value) == 0) {\n    return(name)\n  } # for attributes with no value\n  if (length(value) != 1) stop(\"`value` must be NULL or length 1\")\n  if (is.logical(value)) {\n    # Convert T and F to true and false\n    value &lt;- tolower(value)\n  } else {\n    value &lt;- escape_attr(value)\n  }\n  paste0(name, \"='\", value, \"'\")\n}\n\nescape_attr &lt;- function(x) {\n  x &lt;- escape.character(x)\n  x &lt;- gsub(\"\\'\", \"&#39;\", x)\n  x &lt;- gsub(\"\\\"\", \"&quot;\", x)\n  x &lt;- gsub(\"\\r\", \"&#13;\", x)\n  x &lt;- gsub(\"\\n\", \"&#10;\", x)\n  x\n}\n\n# Tag functions\ntag &lt;- function(tag) {\n  new_function(\n    exprs(... = ),\n    expr({\n      dots &lt;- dots_partition(...)\n      attribs &lt;- html_attributes(dots$named)\n      children &lt;- map_chr(dots$unnamed, escape)\n\n      html(paste0(\n        !!paste0(\"&lt;\", tag), attribs, \"&gt;\",\n        paste(children, collapse = \"\"),\n        !!paste0(\"&lt;/\", tag, \"&gt;\")\n      ))\n    }),\n    caller_env()\n  )\n}\n\nThis code escapes the &lt;p&gt; and &lt;b&gt; tags correctly, but doesn’t achieve the desired behaviour for the &lt;script&gt; tag yet:\n\np &lt;- tag(\"p\")\nb &lt;- tag(\"b\")\n\nidentical(\n  p(\"&\", \"and &lt;\", b(\"& &gt; will be escaped\")) %&gt;%\n    as.character(),\n  \"&lt;p&gt;&amp;and &lt;&lt;b&gt;&amp; &gt; will be escaped&lt;/b&gt;&lt;/p&gt;\"\n)\n#&gt; [1] TRUE\n\nscript &lt;- tag(\"script\")\n\nidentical(\n  script(\"Don't escape &, &lt;, &gt; - escape &lt;/script&gt; and &lt;/style&gt;\") %&gt;%\n    as.character(),\n  paste(\n    \"&lt;script&gt;Don't escape &, &lt;, &gt;\",\n    \"- escape &lt;\\\\/script&gt; and &lt;\\\\/style&gt;&lt;/script&gt;\"\n  )\n)\n#&gt; [1] FALSE\n\nWe implement the desired change and add the optional argument script to the escape() and the tag() functions (default: script = FALSE). The argument has to be added for all methods of the escape() generic.\n\nescape &lt;- function(x, script = FALSE) UseMethod(\"escape\")\n\nescape.character &lt;- function(x, script = FALSE) {\n  if (script) {\n    x &lt;- gsub(\"&lt;/script&gt;\", \"&lt;\\\\/script&gt;\", x, fixed = TRUE)\n    x &lt;- gsub(\"&lt;/style&gt;\", \"&lt;\\\\/style&gt;\", x, fixed = TRUE)\n  } else {\n    x &lt;- gsub(\"&\", \"&amp;\", x)\n    x &lt;- gsub(\"&lt;\", \"&lt;\", x)\n    x &lt;- gsub(\"&gt;\", \"&gt;\", x)\n  }\n\n  html(x)\n}\n\nescape.advr_html &lt;- function(x, script = FALSE) x\n\n\ntag &lt;- function(tag, script = FALSE) {\n  new_function(\n    exprs(... = ),\n    expr({\n      dots &lt;- dots_partition(...)\n      attribs &lt;- html_attributes(dots$named)\n      children &lt;- map_chr(dots$unnamed, escape, script = !!script)\n      html(paste0(\n        !!paste0(\"&lt;\", tag), attribs, \"&gt;\",\n        paste(children, collapse = \"\"),\n        !!paste0(\"&lt;/\", tag, \"&gt;\")\n      ))\n    }),\n    caller_env()\n  )\n}\n\nFinally, we create new &lt;p&gt;, &lt;b&gt; and &lt;script&gt; tag functions, which now pass their escaping tests.\n\np &lt;- tag(\"p\")\nb &lt;- tag(\"b\")\n\nidentical(\n  p(\"&\", \"and &lt;\", b(\"& &gt; will be escaped\")) %&gt;%\n    as.character(),\n  \"&lt;p&gt;&amp;and &lt;&lt;b&gt;&amp; &gt; will be escaped&lt;/b&gt;&lt;/p&gt;\"\n)\n#&gt; [1] TRUE\n\nscript &lt;- tag(\"script\", script = TRUE)\nstyle &lt;- tag(\"style\", script = TRUE)\n\nidentical(\n  script(\"Don't escape &, &lt;, &gt; - escape &lt;/script&gt; and &lt;/style&gt;\") %&gt;%\n    as.character(),\n  paste(\n    \"&lt;script&gt;Don't escape &, &lt;, &gt;\",\n    \"- escape &lt;\\\\/script&gt; and &lt;\\\\/style&gt;&lt;/script&gt;\"\n  )\n)\n#&gt; [1] TRUE\n\nscript(\"Don't escape &, &lt;, &gt; - escape &lt;/script&gt; and &lt;/style&gt;\")\n#&gt; &lt;HTML&gt; &lt;script&gt;Don't escape &, &lt;, &gt; - escape &lt;\\/script&gt; and\n#&gt; &lt;\\/style&gt;&lt;/script&gt;\n\nQ2: The use of ... for all functions has some big downsides. There’s no input validation and there will be little information in the documentation or autocomplete about how they are used in the function. Create a new function that, when given a named list of tags and their attribute names (like below), creates tag functions with named arguments.\n\nlist(\n  a = c(\"href\"),\n  img = c(\"src\", \"width\", \"height\")\n)\n\nAll tags should get class and id attributes.\nA: This exercise requires a function factory: The named list of attribute names will be extended (by class and id) and mapped to function arguments. These will default to NULL, so that the user isn’t forced to provide them.\nWhen creating the tag functions itself we use check_dots_unnamed() from the {ellipsis} package to ensure named arguments correspond to the expected values (and are not created by some spelling mistake). After that we follow the logic from the tag() function factory above.\nTo keep the focus on the key ideas, we ignore special cases like &lt;script&gt;, &lt;style&gt; and void tags in this solution (even if this leads to an incorrect tag function for the &lt;img&gt; tag).\n\ntag_factory &lt;- function(tag, tag_attrs) {\n  attrs &lt;- c(\"class\", \"id\", tag_attrs)\n\n  attr_args &lt;- set_names(rep(list(NULL), length(attrs)), attrs)\n  attr_list &lt;- call2(\"list\", !!!syms(set_names(attrs)))\n\n  new_function(\n    exprs(... = , !!!attr_args),\n    expr({\n      ellipsis::check_dots_unnamed()\n\n      attribs &lt;- html_attributes(compact(!!attr_list))\n      dots &lt;- compact(list(...))\n      children &lt;- map_chr(dots, escape)\n\n      html(paste0(\n        !!paste0(\"&lt;\", tag), attribs, \"&gt;\",\n        paste(children, collapse = \"\"),\n        !!paste0(\"&lt;/\", tag, \"&gt;\")\n      ))\n    })\n  )\n}\n\nTo validate our new function factory, we modify the with_html() example from Advanced R to work with our newly created a() and img() tag functions.\n\ntag_list &lt;- list(\n  a = c(\"href\"),\n  img = c(\"src\", \"width\", \"height\")\n)\n\ntags &lt;- map2(names(tag_list), unname(tag_list), tag_factory) %&gt;%\n  set_names(names(tag_list))\n\nwith_tags &lt;- function(code) {\n  code &lt;- enquo(code)\n  eval_tidy(code, tags)\n}\n\nwith_tags(\n  a(\n    img(\"Correct me if I am wrong\", id = \"second\"),\n    href = \"https://github.com/Tazinho/Advanced-R-Solutions/issues\",\n    id = \"first\"\n  )\n)\n#&gt; &lt;HTML&gt; &lt;a id='first'\n#&gt; href='https://github.com/Tazinho/Advanced-R-Solutions/issues'&gt;&lt;img\n#&gt; id='second'&gt;Correct me if I am wrong&lt;/img&gt;&lt;/a&gt;\n\nQ3: Reason about the following code that calls with_html() referencing objects from the environment. Will it work or fail? Why? Run the code to verify your predictions.\n\ngreeting &lt;- \"Hello!\"\nwith_html(p(greeting))\n\np &lt;- function() \"p\"\naddress &lt;- \"123 anywhere street\"\nwith_html(p(address))\n\nA: First, we rerun the relevant code from Advanced R to define with_html(). Note that we skip the code for void tags, as none of them appear in the code chunk from this exercise.\n\ntags &lt;- c(\n  \"a\", \"abbr\", \"address\", \"article\", \"aside\", \"audio\",\n  \"b\", \"bdi\", \"bdo\", \"blockquote\", \"body\", \"button\", \"canvas\",\n  \"caption\", \"cite\", \"code\", \"colgroup\", \"data\", \"datalist\",\n  \"dd\", \"del\", \"details\", \"dfn\", \"div\", \"dl\", \"dt\", \"em\",\n  \"eventsource\", \"fieldset\", \"figcaption\", \"figure\", \"footer\",\n  \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\",\n  \"hgroup\", \"html\", \"i\", \"iframe\", \"ins\", \"kbd\", \"label\",\n  \"legend\", \"li\", \"mark\", \"map\", \"menu\", \"meter\", \"nav\",\n  \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\",\n  \"p\", \"pre\", \"progress\", \"q\", \"ruby\", \"rp\", \"rt\", \"s\", \"samp\",\n  \"script\", \"section\", \"select\", \"small\", \"span\", \"strong\",\n  \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\",\n  \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\",\n  \"u\", \"ul\", \"var\", \"video\"\n)\n\nhtml_tags &lt;- tags %&gt;%\n  set_names() %&gt;%\n  map(tag)\n\nwith_html &lt;- function(code) {\n  code &lt;- enquo(code)\n  eval_tidy(code, html_tags)\n}\n\nNow, let us briefly repeat, that with_html() was introduced to evaluate tag functions from within a list. Otherwise, defining some tag functions like body(), source(), summary() etc. within the global environment would collide with base R functions with the same name. To prevent this the DSL code wrapped in with_html() is evaluated within the “context” of html_tags, which was provided as a data mask to eval_tidy(). As ?rlang::as_data_mask mentions: “Objects in the mask have precedence over objects in the environment”.\nTherefore, p() refers to the tag function from html_tags within both examples from the exercise. However, as address is not only a string within the global environment, but also a tag function within html_tags (the &lt;address&gt; HTML tag may be used to provide contact information on an HTML page), p() operates on address() in the second example. This correctly leads to an error as we haven’t implemented an escape.function() method.\n\ngreeting &lt;- \"Hello!\"\nwith_html(p(greeting))\n#&gt; &lt;HTML&gt; &lt;p&gt;Hello!&lt;/p&gt;\n\np &lt;- function() \"p\"\naddress &lt;- \"123 anywhere street\"\nwith_html(p(address))\n#&gt; Error in `map_chr()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error in `UseMethod()`:\n#&gt; ! no applicable method for 'escape' applied to an object of class \"function\"\n\nQ4: Currently the HTML doesn’t look terribly pretty, and it’s hard to see the structure. How could you adapt tag() to do indenting and formatting? (You may need to do some research into block and inline tags.)\nA: First, let us load all relevant functions from Advanced R:\n\ntag &lt;- function(tag) {\n  new_function(\n    exprs(... = ),\n    expr({\n      dots &lt;- dots_partition(...)\n      attribs &lt;- html_attributes(dots$named)\n      children &lt;- map_chr(dots$unnamed, escape)\n      html(paste0(\n        !!paste0(\"&lt;\", tag), attribs, \"&gt;\",\n        paste(children, collapse = \"\"),\n        !!paste0(\"&lt;/\", tag, \"&gt;\")\n      ))\n    }),\n    caller_env()\n  )\n}\n\nvoid_tag &lt;- function(tag) {\n  new_function(\n    exprs(... = ),\n    expr({\n      dots &lt;- dots_partition(...)\n      if (length(dots$unnamed) &gt; 0) {\n        stop(\n          !!paste0(\"&lt;\", tag, \"&gt; must not have unnamed arguments\"),\n          call. = FALSE\n        )\n      }\n\n      attribs &lt;- html_attributes(dots$named)\n\n      html(paste0(!!paste0(\"&lt;\", tag), attribs, \" /&gt;\"))\n    }),\n    caller_env()\n  )\n}\n\ntags &lt;- c(\n  \"a\", \"abbr\", \"address\", \"article\", \"aside\", \"audio\", \"b\",\n  \"bdi\", \"bdo\", \"blockquote\", \"body\", \"button\", \"canvas\",\n  \"caption\", \"cite\", \"code\", \"colgroup\", \"data\", \"datalist\",\n  \"dd\", \"del\", \"details\", \"dfn\", \"div\", \"dl\", \"dt\", \"em\",\n  \"eventsource\", \"fieldset\", \"figcaption\", \"figure\", \"footer\",\n  \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\",\n  \"hgroup\", \"html\", \"i\", \"iframe\", \"ins\", \"kbd\", \"label\", \"legend\",\n  \"li\", \"mark\", \"map\", \"menu\", \"meter\", \"nav\", \"noscript\", \"object\",\n  \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"pre\", \"progress\", \"q\",\n  \"ruby\", \"rp\", \"rt\", \"s\", \"samp\", \"script\", \"section\", \"select\",\n  \"small\", \"span\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\",\n  \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n  \"time\", \"title\", \"tr\", \"u\", \"ul\", \"var\", \"video\"\n)\n\nvoid_tags &lt;- c(\n  \"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\",\n  \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\",\n  \"track\", \"wbr\"\n)\n\nhtml_tags &lt;- c(\n  tags %&gt;% set_names() %&gt;% map(tag),\n  void_tags %&gt;% set_names() %&gt;% map(void_tag)\n)\n\nwith_html &lt;- function(code) {\n  code &lt;- enquo(code)\n  eval_tidy(code, html_tags)\n}\n\nNow, let’s look at the example from above:\n\nwith_html(\n  body(\n    h1(\"A heading\", id = \"first\"),\n    p(\"Some text &\", b(\"some bold text.\")),\n    img(src = \"myimg.png\", width = 100, height = 100)\n  )\n)\n#&gt; &lt;HTML&gt; &lt;body&gt;&lt;h1 id='first'&gt;A heading&lt;/h1&gt;&lt;p&gt;Some text &amp;&lt;b&gt;some\n#&gt; bold text.&lt;/b&gt;&lt;/p&gt;&lt;img src='myimg.png' width='100' height='100'\n#&gt; /&gt;&lt;/body&gt;\n\nThe formatting consists of only one long line of code. This output makes it difficult to check the content of the HTML code and its correctness.\nWhat kind of formatting would we prefer instead? Google’s HTML style guide suggests indentation by 2 spaces and new lines for every block, list, or table element. There are other recommendations, but we will keep things simple and will be satisfied with the following output.\n\n&lt;body&gt;\n  &lt;h1 id='first'&gt;A heading&lt;/h1&gt;\n  &lt;p&gt;Some text &amp;&lt;b&gt;some bold text.&lt;/b&gt;&lt;/p&gt;\n  &lt;img src='myimg.png'width='100' height='100' /&gt;\n&lt;/body&gt;\n\nFirst we adjust the print.advr_html() method, removing strwrap() function, because this will re-wrap the HTML, making it harder to understand what’s happening.\n\nhtml &lt;- function(x) structure(x, class = \"advr_html\")\n\nprint.advr_html &lt;- function(x, ...) {\n  cat(paste(\"&lt;HTML&gt;\", x, sep = \"\\n\"))\n}\n\nIn our desired output we can see that the content of the body-function requires different formatting than the other tag-functions. We will therefore create a new format_code() function, that allows for optional indentation and line breaks.\n\nindent &lt;- function(x) {\n  paste0(\"  \", gsub(\"\\n\", \"\\n  \", x))\n}\n\nformat_code &lt;- function(children, indent = FALSE) {\n  if (indent) {\n    paste0(\"\\n\", paste0(indent(children), collapse = \"\\n\"), \"\\n\")\n  } else {\n    paste(children, collapse = \"\")\n  }\n}\n\nWe adjust the body function to include the format_code() helper. (This could also be approached programmatically in the tag function factory.)\n\nhtml_tags$body &lt;- function(...) {\n  dots &lt;- dots_partition(...)\n  attribs &lt;- html_attributes(dots$named)\n  children &lt;- map_chr(dots$unnamed, escape)\n\n  html(paste0(\n    \"&lt;body\", attribs, \"&gt;\",\n    format_code(children, indent = TRUE),\n    \"&lt;/body&gt;\"\n  ))\n}\n\nThe resulting output is much more satisfying.\n\nwith_html(\n  body(\n    h1(\"A heading\", id = \"first\"),\n    p(\"Some text &\", b(\"some bold text.\")),\n    img(src = \"myimg.png\", width = 100, height = 100)\n  )\n)\n#&gt; &lt;HTML&gt;\n#&gt; &lt;body&gt;\n#&gt;   &lt;h1 id='first'&gt;A heading&lt;/h1&gt;\n#&gt;   &lt;p&gt;Some text &amp;&lt;b&gt;some bold text.&lt;/b&gt;&lt;/p&gt;\n#&gt;   &lt;img src='myimg.png' width='100' height='100' /&gt;\n#&gt; &lt;/body&gt;"
  },
  {
    "objectID": "21_Translating_R_code.html#latex",
    "href": "21_Translating_R_code.html#latex",
    "title": "21 - Translating R code",
    "section": "LaTeX",
    "text": "LaTeX\nQ1: Add escaping. The special symbols that should be escaped by adding a backslash in front of them are \\, $, and %. Just as with HTML, you’ll need to make sure you don’t end up double-escaping. So, you’ll need to create a small S3 class and then use that in function operators. That will also allow you to embed arbitrary LaTeX if needed.\nA: Currently our to_math() function generates the following output:\n\nto_math(`$`)\n#&gt; &lt;LATEX&gt; \\mathrm{f}($)    # instead of &lt;LATEX&gt; \\$\nto_math(a$b)\n#&gt; &lt;LATEX&gt; \\mathrm{$}(a b)  # instead of &lt;LATEX&gt; \\mathrm{\\$}(a b)\nto_math(`\\\\`)\n#&gt; &lt;LATEX&gt; \\mathrm{f}(\\)    # instead of &lt;LATEX&gt; \\\\\nto_math(`%`)\n#&gt; &lt;LATEX&gt; \\mathrm{f}(%)    # instead of &lt;LATEX&gt; \\%\n\nTo adjust this behaviour, we need an escape function with methods for the character and advr_latex classes.\n(Note that we must first repeat the underlying code from Advanced R. However, since this would be a bit verbose, and not very meaningful, we will not show this step here.)\n\nescape_latex &lt;- function(x) UseMethod(\"escape_latex\")\n\nescape_latex.character &lt;- function(x) {\n  x &lt;- gsub(\"^\\\\\\\\$\", \"\\\\\\\\\\\\\\\\\", x)\n  x &lt;- gsub(\"^\\\\$$\", \"\\\\\\\\$\", x)\n  x &lt;- gsub(\"^\\\\%$\", \"\\\\\\\\%\", x)\n\n  latex(x)\n}\n\nescape_latex.advr_latex &lt;- function(x) x\n\nWe apply escape_latex() within latex_env() when creating environments for unknown symbols and unknown functions. For the unknown function, we need to modify unknown_op() first.\n\nunknown_op &lt;- function(op) {\n  new_function(\n    exprs(... = ),\n    expr({\n      contents &lt;- paste(..., collapse = \", \")\n      paste0(\n        !!paste0(\"\\\\mathrm{\", escape_latex(op), \"}(\"), contents, \")\"\n      )\n    })\n  )\n}\n\nlatex_env &lt;- function(expr) {\n  calls &lt;- all_calls(expr)\n  call_list &lt;- map(set_names(calls), unknown_op)\n  call_env &lt;- as_environment(call_list)\n\n  # Known functions\n  f_env &lt;- env_clone(f_env, call_env)\n\n  # Default symbols\n  names &lt;- all_names(expr)\n  symbol_env &lt;- as_environment(set_names(escape_latex(names), names),\n    parent = f_env\n  )\n\n  # Known symbols\n  greek_env &lt;- env_clone(greek_env, parent = symbol_env)\n  greek_env\n}\n\nNow, we can validate to_math() on the test cases from above.\n\nto_math(`$`)\n#&gt; &lt;LATEX&gt; \\$\nto_math(a$b)\n#&gt; &lt;LATEX&gt; \\mathrm{\\$}(a b)\nto_math(`\\\\`)\n#&gt; &lt;LATEX&gt; \\\\\nto_math(`%`)\n#&gt; &lt;LATEX&gt; \\%\n\nQ2: Complete the DSL to support all the functions that plotmath supports.\nA: You can see all supported functions in ?plotmath. There are a lot (!) so here we choose to implement a representative sample:\n\nto_math(x %+-% y)\nto_math(x %*% y)\nto_math(x %-&gt;% y)\nto_math(bold(x))\nto_math(x != y)\n\nImplementing the rest is just a mechanical application of the same principles with more LaTex expressions, which can be found on Wikipedia.\nTo provide these translations, we’ll follow the LaTeX section from Advanced R from the beginning. This makes it easier to keep an overview, as we just need to insert the specific changes at the relevant parts.\nLet’s start and repeat the converter function to_math() from the textbook.\n\nto_math &lt;- function(x) {\n  expr &lt;- enexpr(x)\n  out &lt;- eval_bare(expr, latex_env(expr))\n\n  latex(out)\n}\n\nlatex &lt;- function(x) structure(x, class = \"advr_latex\")\nprint.advr_latex &lt;- function(x) {\n  cat(\"&lt;LATEX&gt; \", x, \"\\n\", sep = \"\")\n}\n\nOne specific property in this setting is that the environment where to_math() evaluates the expression is not constant, but depends on what we already know about the expression.\nNext, we start building up latex_env(), which contains a chain of all the necessary environments which to_math() checks to evaluate the expression in.\nThe first environment is the one for Greek letters.\n\ngreek &lt;- c(\n  \"alpha\", \"theta\", \"tau\", \"beta\", \"vartheta\", \"pi\", \"upsilon\",\n  \"gamma\", \"varpi\", \"phi\", \"delta\", \"kappa\", \"rho\",\n  \"varphi\", \"epsilon\", \"lambda\", \"varrho\", \"chi\", \"varepsilon\",\n  \"mu\", \"sigma\", \"psi\", \"zeta\", \"nu\", \"varsigma\", \"omega\", \"eta\",\n  \"xi\", \"Gamma\", \"Lambda\", \"Sigma\", \"Psi\", \"Delta\", \"Xi\",\n  \"Upsilon\", \"Omega\", \"Theta\", \"Pi\", \"Phi\"\n)\ngreek_list &lt;- set_names(paste0(\"\\\\\", greek), greek)\ngreek_env &lt;- as_environment(greek_list)\n\nlatex_env &lt;- function(expr) {\n  greek_env\n}\n\nWe already know from Advanced R that e.g. to_math(pi) now correctly converts to \\\\pi. So, let’s move on to the next one.\nHere, it’ll become a bit more technical. Not every symbol is Greek (and not every part of an expression is a symbol). To find out which symbols are present within the expression, first, we use an approach from section 5 of the expressions chapter (walking the AST to find all symbols) where Hadley recursively walks the AST to distinguish between different expression element types.\nLet’s briefly repeat the helpers defined in that section:\n\nexpr_type &lt;- function(x) {\n  if (rlang::is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\n\nswitch_expr &lt;- function(x, ...) {\n  switch(expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \",\n      typeof(x),\n      call. = FALSE\n    )\n  )\n}\n\nflat_map_chr &lt;- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\n\nThis lets us define all_names(), which returns the desired symbols, already converted to characters.\n\nall_names_rec &lt;- function(x) {\n  switch_expr(x,\n    constant = character(),\n    symbol = as.character(x),\n    call = flat_map_chr(as.list(x[-1]), all_names)\n  )\n}\n\nall_names &lt;- function(x) {\n  unique(all_names_rec(x))\n}\n\nall_names(expr(x + y + f(a, b, c, 10)))\n#&gt; [1] \"x\" \"y\" \"a\" \"b\" \"c\"\n\nWe use all_names() now within latex_env() to create an environment of the symbols which were found within the expression. This environment will be set as the parent environment of greek_env.\n\nlatex_env &lt;- function(expr) {\n  # Unknown symbols\n  names &lt;- all_names(expr)\n  symbol_env &lt;- as_environment(set_names(names))\n\n  # Known symbols\n  env_clone(greek_env, parent = symbol_env)\n}\n\nIn this way, to_math() will first convert all known Greek letters (found in greek_env) and then any other symbols, which are left as is (in this implementation).\nWe also have to add support for functions. This will give us the opportunity to insert some specific support for plotmath functions.\nTo support a whole bunch of unary and binary functions within the function environment (f_env), which will be added next to latex_env, Hadley defines the following two helpers in Advanced R.\n\nunary_op &lt;- function(left, right) {\n  new_function(\n    exprs(e1 = ),\n    expr(\n      paste0(!!left, e1, !!right)\n    ),\n    caller_env()\n  )\n}\n\nbinary_op &lt;- function(sep) {\n  new_function(\n    exprs(e1 = , e2 = ),\n    expr(\n      paste0(e1, !!sep, e2)\n    ),\n    caller_env()\n  )\n}\n\nWhile defining the function environment, f_env, we mostly continue to copy the exact code from Advanced R. However, at the bottom we add a short section where we define some extra conversions which are part of plotmath (and selected above in our intro to this solution).\n\nf_env &lt;- child_env(\n  # Binary operators\n  .parent = empty_env(),\n  `+` = binary_op(\" + \"),\n  `-` = binary_op(\" - \"),\n  `*` = binary_op(\" * \"),\n  `/` = binary_op(\" / \"),\n  `^` = binary_op(\"^\"),\n  `[` = binary_op(\"_\"),\n\n  # Grouping\n  `{` = unary_op(\"\\\\left{ \", \" \\\\right}\"),\n  `(` = unary_op(\"\\\\left( \", \" \\\\right)\"),\n  paste = paste,\n\n  # Other math functions\n  sqrt = unary_op(\"\\\\sqrt{\", \"}\"),\n  sin = unary_op(\"\\\\sin(\", \")\"),\n  log = unary_op(\"\\\\log(\", \")\"),\n  abs = unary_op(\"\\\\left| \", \"\\\\right| \"),\n  frac = function(a, b) {\n    paste0(\"\\\\frac{\", a, \"}{\", b, \"}\")\n  },\n\n  # Labelling\n  hat = unary_op(\"\\\\hat{\", \"}\"),\n  tilde = unary_op(\"\\\\tilde{\", \"}\"),\n\n  # Plotmath\n  `%+-%` = binary_op(\" \\\\pm \"),\n  `%*%` = binary_op(\" \\\\times \"),\n  `%-&gt;%` = binary_op(\" \\\\rightarrow \"),\n  bold = unary_op(\"\\\\textbf{\", \"}\"),\n  `!=` = binary_op(\" \\\\neq \")\n)\n\nAgain we extend latex_env() to include the additional environment, f_env, which must be the parent of the symbol environment (which is the parent of the Greek symbol environment).\n\nlatex_env &lt;- function(expr) {\n  # Known functions\n  f_env\n\n  # Default symbols\n  names &lt;- all_names(expr)\n  symbol_env &lt;- as_environment(set_names(names), parent = f_env)\n\n  # Known symbols\n  greek_env &lt;- env_clone(greek_env, parent = symbol_env)\n\n  greek_env\n}\n\nNow, we can finally check if our new functionality works:\n\n# New plotmath functionality\nto_math(x %+-% y)\n#&gt; &lt;LATEX&gt; x \\pm y\nto_math(x %*% y)\n#&gt; &lt;LATEX&gt; x \\times y\nto_math(x %-&gt;% y)\n#&gt; &lt;LATEX&gt; x \\rightarrow y\nto_math(bold(x))\n#&gt; &lt;LATEX&gt; \\textbf{x}\nto_math(x != y)\n#&gt; &lt;LATEX&gt; x \\neq y\n\n# Other examples from Advanced R\nto_math(sin(x + pi))\n#&gt; &lt;LATEX&gt; \\sin(x + \\pi)\nto_math(log(x[i]^2))\n#&gt; &lt;LATEX&gt; \\log(x_i^2)\nto_math(sin(sin))\n#&gt; &lt;LATEX&gt; \\sin(sin)\n\nIf we wanted, we could include further plotmath functions in this step. If this collides with other functions at some point, we could just create our own f_plotmath_env to support more plotmath functions. In that case we would need to add this environment also to latex_env() (as child environment of the function environment f_env).\nTo complete this answer, we will also add the support for unknown functions. Similarly as for the unknown symbols, we use the trick to recursively run the AST and just reuse the code from Advanced R.\n\nall_calls_rec &lt;- function(x) {\n  switch_expr(x,\n    constant = ,\n    symbol = character(),\n    call = {\n      fname &lt;- as.character(x[[1]])\n      children &lt;- flat_map_chr(as.list(x[-1]), all_calls)\n      c(fname, children)\n    }\n  )\n}\n\nall_calls &lt;- function(x) {\n  unique(all_calls_rec(x))\n}\n\nall_calls(expr(f(g + b, c, d(a))))\n#&gt; [1] \"f\" \"+\" \"d\"\n\nunknown_op &lt;- function(op) {\n  new_function(\n    exprs(... = ),\n    expr({\n      contents &lt;- paste(..., collapse = \", \")\n      paste0(!!paste0(\"\\\\mathrm{\", op, \"}(\"), contents, \")\")\n    })\n  )\n}\n\nOf course, we need to add the new call_env also to latex_env().\n\nlatex_env &lt;- function(expr) {\n  calls &lt;- all_calls(expr)\n  call_list &lt;- map(set_names(calls), unknown_op)\n  call_env &lt;- as_environment(call_list)\n\n  # Known functions\n  f_env &lt;- env_clone(f_env, call_env)\n\n  # Default symbols\n  names &lt;- all_names(expr)\n  symbol_env &lt;- as_environment(set_names(names), parent = f_env)\n\n  # Known symbols\n  greek_env &lt;- env_clone(greek_env, parent = symbol_env)\n  greek_env\n}\n\nFinally, we rerun our tests and double check the newly supported plotmath operators.\n\n# New plotmath functionality\nto_math(x %+-% y)\n#&gt; &lt;LATEX&gt; x \\pm y\nto_math(x %*% y)\n#&gt; &lt;LATEX&gt; x \\times y\nto_math(x %-&gt;% y)\n#&gt; &lt;LATEX&gt; x \\rightarrow y\nto_math(bold(x))\n#&gt; &lt;LATEX&gt; \\textbf{x}\nto_math(x != y)\n#&gt; &lt;LATEX&gt; x \\neq y\n\n# Other examples from Advanced R\nto_math(sin(x + pi))\n#&gt; &lt;LATEX&gt; \\sin(x + \\pi)\nto_math(log(x[i]^2))\n#&gt; &lt;LATEX&gt; \\log(x_i^2)\nto_math(sin(sin))\n#&gt; &lt;LATEX&gt; \\sin(sin)\n\n# Unknown functions\nto_math(f(g(x)))\n#&gt; &lt;LATEX&gt; \\mathrm{f}(\\mathrm{g}(x))"
  },
  {
    "objectID": "23_Measuring_performance.html#profiling",
    "href": "23_Measuring_performance.html#profiling",
    "title": "23 - Measuring performance",
    "section": "Profiling",
    "text": "Profiling\nQ1: Profile the following function with torture = TRUE. What is surprising? Read the source code of rm() to figure out what’s going on.\n\nf &lt;- function(n = 1e5) {\n  x &lt;- rep(1, n)\n  rm(x)\n}\n\nA: We expect f() to create a vector (x) of length n, which is then removed so that f() just returns NULL. When we profile this function, it executes too fast for meaningful results.\n\nprofvis::profvis(f())\n#&gt; Error in parse_rprof_lines(lines, expr_source): No parsing data available. Maybe your function was too fast?\n\nSetting torture = TRUE triggers garbage collection after every memory allocation call, which may be useful for more exact memory profiling.\n\nprofvis::profvis(f(), torture = TRUE)\n\nSurprisingly, profiling f() like this takes a very long time. What could be the reason?\nWe follow the hint in the question and inspect the source code of rm():\n\nfunction(..., list = character(), pos = -1,\n         envir = as.environment(pos),\n         inherits = FALSE) {\n  dots &lt;- match.call(expand.dots = FALSE)$...\n  if (\n    length(dots) && !all(\n      vapply(dots, function(x) {\n        is.symbol(x) ||\n          is.character(x)\n      }, NA, USE.NAMES = FALSE)\n    )\n  ) {\n    stop(\"... must contain names or character strings\")\n  }\n  names &lt;- vapply(dots, as.character, \"\")\n  if (length(names) == 0L) {\n    names &lt;- character()\n  }\n  list &lt;- .Primitive(\"c\")(list, names)\n  .Internal(remove(list, envir, inherits))\n}\n\nrm() does a surprising amount of work to get the name of the object to delete because it relies on non-standard evaluation.\nWe can make the job of rm() considerably simpler by using the list argument:\n\nf2 &lt;- function(n = 1e5) {\n  x &lt;- rep(1, n)\n  rm(list = \"x\")\n}\nprofvis::profvis(f2(), torture = TRUE)\n\nUnfortunately, this still takes too long, and we are literally stuck in profiling.\nAnecdotally, one of the authors once finished the profiling under an older R version. But the output seemed to be not very meaningful.\nIn conclusion, this question appears to be unanswerable for us, even for Hadley."
  },
  {
    "objectID": "23_Measuring_performance.html#microbenchmarking",
    "href": "23_Measuring_performance.html#microbenchmarking",
    "title": "23 - Measuring performance",
    "section": "Microbenchmarking",
    "text": "Microbenchmarking\nQ1: Instead of using bench::mark(), you could use the built-in function system.time(). But system.time() is much less precise, so you’ll need to repeat each operation many times with a loop, and then divide to find the average time of each operation, as in the code below.\n\nn &lt;- 1e6\nsystem.time(for (i in 1:n) sqrt(x)) / n\nsystem.time(for (i in 1:n) x^0.5) / n\n\nHow do the estimates from system.time() compare to those from bench::mark()? Why are they different?\nA: We first microbenchmark these two expressions using bench::mark() (Hester 2020) and observe that the mean is not reported (as it is generally more affected by outliers).\n\nn &lt;- 1e6\nx &lt;- runif(100)\n\nbench_df &lt;- bench::mark(\n  sqrt(x),\n  x^0.5,\n  iterations = n\n)\n\nbench_df\n#&gt; # A tibble: 2 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 sqrt(x)    191.15ns    237ns  2277084.      848B     38.7\n#&gt; 2 x^0.5        1.38µs    1.5µs   644621.      848B     23.2\n\nWe need to access the raw data, so we can compare the results of both benchmarking approaches.\n\nt1_bench &lt;- mean(unlist(bench_df[1, \"time\"]))\nt2_bench &lt;- mean(unlist(bench_df[2, \"time\"]))\n\nt1_systime &lt;- system.time(for (i in 1:n) sqrt(x)) / n\nt2_systime &lt;- system.time(for (i in 1:n) x^0.5) / n\n\nWe see, that both approaches get the order of magnitude right. We assume, that the bench::mark()-results may be a little more accurate, because of its high precision timer. There may also be overhead introduced by the for loop in the system.time()-approach.\n\n# Compare the results\nt1_systime[\"elapsed\"]\nt1_bench\n\nt2_systime[\"elapsed\"]\nt2_bench\n\nSide Note: take a look at ?proc.time if you want to learn about the differences between “user”, “system” and “elapsed” time.\nQ2: Here are two other ways to compute the square root of a vector. Which do you think will be fastest? Which will be slowest? Use microbenchmarking to test your answers.\n\nx^(1 / 2)\nexp(log(x) / 2)\n\nA: To compare these approaches, we’ll bench::mark() them and sort the result by the median execution time.\n\nx &lt;- runif(100)\n\nbm &lt;- bench::mark(\n  sqrt(x),\n  x^0.5,\n  x^(1 / 2),\n  exp(log(x) / 2)\n)\n\nbm[order(bm$median), ]\n#&gt; # A tibble: 4 × 6\n#&gt;   expression         min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;    &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 sqrt(x)       205.01ns 223.05ns  4053946.      848B        0\n#&gt; 2 exp(log(x)/2)   1.08µs   1.14µs   842693.      848B        0\n#&gt; 3 x^0.5           1.45µs    1.5µs   639435.      848B        0\n#&gt; 4 x^(1/2)         1.52µs   1.58µs   607937.      848B        0\n\nAs one might expect the idiomatic primitive function sqrt() is the fastest. The approach exp(log(x) / 2) which builds on two other primitive functions is second, even though already considerably slower. The other calculations are even slower: x^0.5 is faster than x^ (1/2), because 0.5 requires less computation than 1/2."
  },
  {
    "objectID": "23_Measuring_performance.html#references",
    "href": "23_Measuring_performance.html#references",
    "title": "23 - Measuring performance",
    "section": "References",
    "text": "References\n\n\n\n\nHester, Jim. 2020. Bench: High Precision Timing of r Expressions. https://github.com/r-lib/bench."
  },
  {
    "objectID": "24_Improving_performance.html#checking-for-existing-solutions",
    "href": "24_Improving_performance.html#checking-for-existing-solutions",
    "title": "24 - Improving performance",
    "section": "Checking for existing solutions",
    "text": "Checking for existing solutions\nQ1: What are faster alternatives to lm? Which are specifically designed to work with larger datasets?\nA: The CRAN task view for high-performance computing provides many recommendations. For this question, we are most interested in the section on “Large memory and out-of-memory data”. We could for example give biglm::biglm() (Lumley 2020), fixest::feols() (Bergé 2018) a try.\nFor small datasets, we observe only minor performance gains (or even a small cost):\n\npenguins &lt;- palmerpenguins::penguins\n\nbench::mark(\n  \"lm\" = lm(\n    body_mass_g ~ bill_length_mm + species,\n    data = penguins\n  ) %&gt;% coef(),\n  \"biglm\" = biglm::biglm(\n    body_mass_g ~ bill_length_mm + species,\n    data = penguins\n  ) %&gt;% coef(),\n  \"fixest\" = fixest::feols(\n    body_mass_g ~ bill_length_mm + species,\n    data = penguins\n  ) %&gt;% coef()\n)\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; NOTE: 2 observations removed because of NA values (LHS: 2, RHS: 2).\n#&gt; # A tibble: 3 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 lm         423.93µs 500.75µs     1844.  937.49KB    10.6 \n#&gt; 2 biglm      320.17µs 367.26µs     2636.    6.14MB    10.4 \n#&gt; 3 fixest       3.58ms   3.93ms      252.   13.79MB     6.25\n\nFor larger datasets the selection of the appropriate method is of greater relevance:\n\neps &lt;- rnorm(100000)\nx1 &lt;- rnorm(100000, 5, 3)\nx2 &lt;- rep(c(\"a\", \"b\"), 50000)\ny &lt;- 7 * x1 + (x2 == \"a\") + eps\ntd &lt;- data.frame(y = y, x1 = x1, x2 = x2, eps = eps)\n\nbench::mark(\n  \"lm\" = lm(y ~ x1 + x2, data = td) %&gt;% coef(),\n  \"biglm\" = biglm::biglm(y ~ x1 + x2, data = td) %&gt;% coef(),\n  \"fixest\" = fixest::feols(y ~ x1 + x2, data = td) %&gt;% coef()\n)\n#&gt; # A tibble: 3 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 lm          16.91ms  17.08ms      58.5   27.04MB    732. \n#&gt; 2 biglm        15.4ms  15.57ms      64.0   22.22MB    256. \n#&gt; 3 fixest       8.18ms   8.68ms     110.     9.05MB     60.8\n\nFor further speed improvements, you could install a linear algebra library optimised for your system.\n\nThe functions of class ‘feols’ may speed up the fitting of LMs to large datasets. High performances can be obtained especially if R is linked against an optimized BLAS, such as ATLAS, Intel MKL, OpenBLAS, and others.\n\nTip: In case your dataset is stored in a database, you might want to check out the {modeldb} package (Kuhn 2020) which executes the linear model code in the corresponding database backend.\nQ2: What package implements a version of match() that’s faster for repeated lookups? How much faster is it?\nA: A web search points us to the {fastmatch} package (Urbanek 2017). We compare it to base::match() and observe an impressive performance gain.\n\ntable &lt;- 1:100000\nx &lt;- sample(table, 10000, replace = TRUE)\n\nbench::mark(\n  match = match(x, table),\n  fastmatch = fastmatch::fmatch(x, table)\n)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 match        7.41ms   7.58ms      131.    1.46MB     6.33\n#&gt; 2 fastmatch   258.9µs 270.06µs     3642.  442.91KB     4.05\n\nQ3: List four functions (not just those in base R) that convert a string into a date time object. What are their strengths and weaknesses?\nA: The usual base R way is to use the as.POSIXct() generic and create a date time object of class POSIXct and type integer.\n\ndate_ct &lt;- as.POSIXct(\"2020-01-01 12:30:25\")\ndate_ct\n#&gt; [1] \"2020-01-01 12:30:25 EST\"\n\nUnder the hood as.POSIXct() employs as.POSIXlt() for the character conversion. This creates a date time object of class POSIXlt and type list.\n\ndate_lt &lt;- as.POSIXlt(\"2020-01-01 12:30:25\")\ndate_lt\n#&gt; [1] \"2020-01-01 12:30:25 EST\"\n\nThe POSIXlt class has the advantage that it carries the individual time components as attributes. This allows to extract the time components via typical list operators.\n\nattributes(date_lt)\n#&gt; $names\n#&gt;  [1] \"sec\"    \"min\"    \"hour\"   \"mday\"   \"mon\"    \"year\"   \"wday\"   \"yday\"  \n#&gt;  [9] \"isdst\"  \"zone\"   \"gmtoff\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"POSIXlt\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"\"    \"EST\" \"EDT\"\n#&gt; \n#&gt; $balanced\n#&gt; [1] TRUE\ndate_lt$sec\n#&gt; [1] 25\n\nHowever, while lists may be practical, basic calculations are often faster and require less memory for objects with underlying integer type.\n\ndate_lt2 &lt;- rep(date_lt, 10000)\ndate_ct2 &lt;- rep(date_ct, 10000)\n\nbench::mark(\n  date_lt2 - date_lt2,\n  date_ct2 - date_ct2,\n  date_ct2 - date_lt2\n)\n#&gt; # A tibble: 3 × 6\n#&gt;   expression               min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;          &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 date_lt2 - date_lt2  17.32ms  17.52ms      56.9    1.39MB     2.03\n#&gt; 2 date_ct2 - date_ct2  36.06µs  40.44µs   23556.   195.45KB   111.  \n#&gt; 3 date_ct2 - date_lt2   7.67ms   8.75ms     115.   781.95KB     2.05\n\nas.POSIXlt() in turn uses strptime() under the hood, which creates a similar date time object.\n\ndate_str &lt;- strptime(\"2020-01-01 12:30:25\",\n  format = \"%Y-%m-%d %H:%M:%S\"\n)\nidentical(date_lt, date_str)\n#&gt; [1] TRUE\n\nas.POSIXct() and as.POSIXlt() accept different character inputs by default (e.g. \"2001-01-01 12:30\" or \"2001/1/1 12:30\"). strptime() requires the format argument to be set explicitly, and provides a performance improvement in return.\n\nbench::mark(\n  as.POSIXct = as.POSIXct(\"2020-01-01 12:30:25\"),\n  as.POSIXct_format = as.POSIXct(\"2020-01-01 12:30:25\",\n    format = \"%Y-%m-%d %H:%M:%S\"\n  ),\n  strptime_fomat = strptime(\"2020-01-01 12:30:25\",\n    format = \"%Y-%m-%d %H:%M:%S\"\n  )\n)[1:3]\n#&gt; # A tibble: 3 × 3\n#&gt;   expression             min   median\n#&gt;   &lt;bch:expr&gt;        &lt;bch:tm&gt; &lt;bch:tm&gt;\n#&gt; 1 as.POSIXct         20.43µs  23.71µs\n#&gt; 2 as.POSIXct_format   10.9µs  12.38µs\n#&gt; 3 strptime_fomat      2.85µs   3.08µs\n\nA fourth way is to use the converter functions from the {lubridate} package (Grolemund and Wickham 2011), which contains wrapper functions (for the POSIXct approach) with an intuitive syntax. (There is a slight decrease in performance though.)\n\nlibrary(lubridate)\nymd_hms(\"2013-07-24 23:55:26\")\n#&gt; [1] \"2013-07-24 23:55:26 UTC\"\n\nbench::mark(\n  as.POSIXct = as.POSIXct(\"2013-07-24 23:55:26\", tz = \"UTC\"),\n  ymd_hms = ymd_hms(\"2013-07-24 23:55:26\")\n)[1:3]\n#&gt; # A tibble: 2 × 3\n#&gt;   expression      min   median\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;\n#&gt; 1 as.POSIXct  22.55µs   25.7µs\n#&gt; 2 ymd_hms      1.54ms    1.7ms\n\nFor additional ways to convert characters into date time objects, have a look at the {chron}, the {anytime} and the {fasttime} packages. The {chron} package (James and Hornik 2020) introduces new classes and stores times as fractions of days in the underlying double type, while it doesn’t deal with time zones and daylight savings. The {anytime} package (Eddelbuettel 2020) aims to convert “Anything to POSIXct or Date”. The {fasttime} package (Urbanek 2016) contains only one function, fastPOSIXct().\nQ4: Which packages provide the ability to compute a rolling mean?\nA: A rolling mean is a useful statistic to smooth time-series, spatial and other types of data. The size of the rolling window usually determines the amount of smoothing and the number of missing values at the boundaries of the data.\nThe general functionality can be found in multiple packages, which vary in speed and flexibility of the computations. Here is a benchmark for several functions that all serve our purpose.\n\nx &lt;- 1:10\nslider::slide_dbl(x, mean, .before = 1, .complete = TRUE)\n#&gt;  [1]  NA 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5\n\nbench::mark(\n  caTools = caTools::runmean(x, k = 2, endrule = \"NA\"),\n  data.table = data.table::frollmean(x, 2),\n  slider = slider::slide_dbl(x, mean, .before = 1, .complete = TRUE),\n  TTR = TTR::SMA(x, 2),\n  zoo_apply = zoo::rollapply(x, 2, mean, fill = NA, align = \"right\"),\n  zoo_rollmean = zoo::rollmean(x, 2, fill = NA, align = \"right\")\n)\n#&gt; # A tibble: 6 × 6\n#&gt;   expression        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 caTools          25µs   29.2µs    33235.  168.47KB     16.6\n#&gt; 2 data.table     13.2µs   15.6µs    60402.   32.73KB     30.2\n#&gt; 3 slider         29.8µs   34.5µs    28092.        0B     16.9\n#&gt; 4 TTR            53.8µs   62.7µs    15513.  608.02KB     14.6\n#&gt; 5 zoo_apply     123.8µs  145.7µs     6673.  453.96KB     17.0\n#&gt; 6 zoo_rollmean  115.2µs  123.7µs     7637.    6.43KB     19.0\n\nYou may also take a look at an extensive example in the first edition of Advanced R, which demonstrates how a rolling mean function can be created.\nQ5: What are the alternatives to optim()?\nA: According to its description (see ?optim) optim() implements:\n\nGeneral-purpose optimization based on Nelder–Mead, quasi-Newton and conjugate-gradient algorithms. It includes an option for box-constrained optimization and simulated annealing.\n\noptim() allows to optimise a function (fn) on an interval with a specific method (method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\", \"Brent\")). Many detailed examples are given in the documentation. In the simplest case, we give optim() the starting value par = 0 to calculate the minimum of a quadratic polynomial:\n\noptim(0, function(x) x^2 - 100 * x + 50,\n  method = \"Brent\",\n  lower = -1e20, upper = 1e20\n)\n#&gt; $par\n#&gt; [1] 50\n#&gt; \n#&gt; $value\n#&gt; [1] -2450\n#&gt; \n#&gt; $counts\n#&gt; function gradient \n#&gt;       NA       NA \n#&gt; \n#&gt; $convergence\n#&gt; [1] 0\n#&gt; \n#&gt; $message\n#&gt; NULL\n\nSince this solves a one-dimensional optimisation task, we could have also used stats::optimize().\n\noptimize(function(x) x^2 - 100 * x + 50, c(-1e20, 1e20))\n#&gt; $minimum\n#&gt; [1] 50\n#&gt; \n#&gt; $objective\n#&gt; [1] -2450\n\nFor more general alternatives, the appropriate choice highly depends on the type of optimisation you intend to do. The CRAN task view on optimisation and mathematical modelling can serve as a useful reference. Here are a couple of examples:\n\n{optimx} (Nash and Varadhan 2011; Nash 2014) extends the optim() function with the same syntax but more method choices.\n{DEoptim} (Ardia et al. 2011) provides a global optimiser based on the Differential Evolution algorithm."
  },
  {
    "objectID": "24_Improving_performance.html#doing-as-little-as-possible",
    "href": "24_Improving_performance.html#doing-as-little-as-possible",
    "title": "24 - Improving performance",
    "section": "Doing as little as possible",
    "text": "Doing as little as possible\nQ1: What’s the difference between rowSums() and .rowSums()?\nA: When we inspect the source code of the user-facing rowSums(), we see that it is designed as a wrapper around .rowSums() with some input validation, conversions and handling of complex numbers.\n\nrowSums\n#&gt; function (x, na.rm = FALSE, dims = 1L) \n#&gt; {\n#&gt;     if (is.data.frame(x)) \n#&gt;         x &lt;- as.matrix(x)\n#&gt;     if (!is.array(x) || length(dn &lt;- dim(x)) &lt; 2L) \n#&gt;         stop(\"'x' must be an array of at least two dimensions\")\n#&gt;     if (dims &lt; 1L || dims &gt; length(dn) - 1L) \n#&gt;         stop(\"invalid 'dims'\")\n#&gt;     p &lt;- prod(dn[-(id &lt;- seq_len(dims))])\n#&gt;     dn &lt;- dn[id]\n#&gt;     z &lt;- if (is.complex(x)) \n#&gt;         .Internal(rowSums(Re(x), prod(dn), p, na.rm)) + (0+1i) * \n#&gt;             .Internal(rowSums(Im(x), prod(dn), p, na.rm))\n#&gt;     else .Internal(rowSums(x, prod(dn), p, na.rm))\n#&gt;     if (length(dn) &gt; 1L) {\n#&gt;         dim(z) &lt;- dn\n#&gt;         dimnames(z) &lt;- dimnames(x)[id]\n#&gt;     }\n#&gt;     else names(z) &lt;- dimnames(x)[[1L]]\n#&gt;     z\n#&gt; }\n#&gt; &lt;bytecode: 0x5f225cb2bb38&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n.rowSums() calls an internal function, which is built into the R interpreter. These compiled functions can be very fast.\n\n.rowSums\n#&gt; function (x, m, n, na.rm = FALSE) \n#&gt; .Internal(rowSums(x, m, n, na.rm))\n#&gt; &lt;bytecode: 0x5f225c1051e0&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nHowever, as our benchmark reveals almost identical computing times, we prefer the safer variant over the internal function for this case.\n\nm &lt;- matrix(rnorm(1e6), nrow = 1000)\n\nbench::mark(\n  rowSums(m),\n  .rowSums(m, 1000, 1000)\n)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression                   min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;              &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 rowSums(m)                1.96ms    2.2ms      455.    7.86KB        0\n#&gt; 2 .rowSums(m, 1000, 1000)   1.98ms   2.19ms      458.    7.86KB        0\n\nQ2: Make a faster version of chisq.test() that only computes the chi-square test statistic when the input is two numeric vectors with no missing values. You can try simplifying chisq.test() or by coding from the mathematical definition.\nA: We aim to speed up our reimplementation of chisq.test() by doing less.\n\nchisq.test2 &lt;- function(x, y) {\n  m &lt;- rbind(x, y)\n  margin1 &lt;- rowSums(m)\n  margin2 &lt;- colSums(m)\n  n &lt;- sum(m)\n  me &lt;- tcrossprod(margin1, margin2) / n\n\n  x_stat &lt;- sum((m - me)^2 / me)\n  df &lt;- (length(margin1) - 1) * (length(margin2) - 1)\n  p.value &lt;- pchisq(x_stat, df = df, lower.tail = FALSE)\n\n  list(x_stat = x_stat, df = df, p.value = p.value)\n}\n\nWe check if our new implementation returns the same results and benchmark it afterwards.\n\na &lt;- 21:25\nb &lt;- seq(21, 29, 2)\nm &lt;- cbind(a, b)\n\nchisq.test(m) %&gt;% print(digits = 5)\n#&gt; \n#&gt;  Pearson's Chi-squared test\n#&gt; \n#&gt; data:  m\n#&gt; X-squared = 0.162, df = 4, p-value = 1\nchisq.test2(a, b)\n#&gt; $x_stat\n#&gt; [1] 0.162\n#&gt; \n#&gt; $df\n#&gt; [1] 4\n#&gt; \n#&gt; $p.value\n#&gt; [1] 0.997\n\nbench::mark(\n  chisq.test(m),\n  chisq.test2(a, b),\n  check = FALSE\n)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression             min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;        &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 chisq.test(m)      31.43µs   35.6µs    26715.        0B     16.0\n#&gt; 2 chisq.test2(a, b)   9.16µs   10.4µs    91271.        0B     18.3\n\nQ3: Can you make a faster version of table() for the case of an input of two integer vectors with no missing values? Can you use it to speed up your chi-square test?\nA: When analysing the source code of table() we aim to omit everything unnecessary and extract the main building blocks. We observe that table() is powered by tabulate() which is a very fast counting function. This leaves us with the challenge to compute the pre-processing as performant as possible.\nFirst, we calculate the dimensions and names of the output table. Then we use fastmatch::fmatch() to map the elements of each vector to their position within the vector itself (i.e. the smallest value is mapped to 1L, the second smallest value to 2L, etc.). Following the logic within table() we combine and shift these values to create a mapping of the integer pairs in our data to the index of the output table. After applying these lookups tabulate() counts the values and returns an integer vector with counts for each position in the table. As a last step, we reuse the code from table() to assign the correct dimension and class.\n\ntable2 &lt;- function(a, b) {\n  a_s &lt;- sort(unique(a))\n  b_s &lt;- sort(unique(b))\n\n  a_l &lt;- length(a_s)\n  b_l &lt;- length(b_s)\n\n  dims &lt;- c(a_l, b_l)\n  pr &lt;- a_l * b_l\n  dn &lt;- list(a = a_s, b = b_s)\n\n  bin &lt;- fastmatch::fmatch(a, a_s) +\n    a_l * fastmatch::fmatch(b, b_s) - a_l\n  y &lt;- tabulate(bin, pr)\n\n  y &lt;- array(y, dim = dims, dimnames = dn)\n  class(y) &lt;- \"table\"\n\n  y\n}\n\na &lt;- sample(100, 10000, TRUE)\nb &lt;- sample(100, 10000, TRUE)\n\nbench::mark(\n  table(a, b),\n  table2(a, b)\n)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 table(a, b)     609µs    670µs     1450.    1.29MB     43.3\n#&gt; 2 table2(a, b)    221µs    236µs     4119.  563.34KB     48.5\n\nSince we didn’t use table() in our chisq.test2()-implementation, we cannot benefit from the slight performance gain from table2()."
  },
  {
    "objectID": "24_Improving_performance.html#vectorise",
    "href": "24_Improving_performance.html#vectorise",
    "title": "24 - Improving performance",
    "section": "Vectorise",
    "text": "Vectorise\nQ1: The density functions, e.g. dnorm(), have a common interface. Which arguments are vectorised over? What does rnorm(10, mean = 10:1) do?\nA: We can get an overview of the interface of these functions via ?dnorm:\n\ndnorm(x, mean = 0, sd = 1, log = FALSE)\npnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)\nqnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)\nrnorm(n, mean = 0, sd = 1)\n\nThese functions are vectorised over their numeric arguments, which includes the first argument (x, q, p, n) as well as mean and sd.\nrnorm(10, mean = 10:1) generates ten random numbers from different normal distributions. These normal distributions differ in their means. The first has mean 10, the second mean 9, the third mean 8 and so on.\nQ2: Compare the speed of apply(x, 1, sum) with rowSums(x) for varying sizes of x.\nA: We compare the two functions for square matrices of increasing size:\n\nrowsums &lt;- bench::press(\n  p = seq(500, 5000, length.out = 10),\n  {\n    mat &lt;- tcrossprod(rnorm(p), rnorm(p))\n    bench::mark(\n      rowSums = rowSums(mat),\n      apply = apply(mat, 1, sum)\n    )\n  }\n)\n#&gt; Running with:\n#&gt;        p\n#&gt;  1   500\n#&gt;  2  1000\n#&gt;  3  1500\n#&gt;  4  2000\n#&gt;  5  2500\n#&gt;  6  3000\n#&gt;  7  3500\n#&gt;  8  4000\n#&gt;  9  4500\n#&gt; 10  5000\n\nlibrary(ggplot2)\n\nrowsums %&gt;%\n  summary() %&gt;%\n  dplyr::mutate(Approach = as.character(expression)) %&gt;%\n  ggplot(\n    aes(p, median, color = Approach, group = Approach)\n  ) +\n  geom_point() +\n  geom_line() +\n  labs(\n    x = \"Number of Rows and Columns\",\n    y = \"Median (s)\"\n  ) +\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\nWe can see that the difference in performance is negligible for small matrices but becomes more and more relevant as the size of the data increases. apply() is a very versatile tool, but it’s not “vectorised for performance” and not as optimised as rowSums().\nQ3: How can you use crossprod() to compute a weighted sum? How much faster is it than the naive sum(x * w)?\nA: We can hand the vectors to crossprod(), which converts them to row- and column-vectors and then multiplies these. The result is the dot product, which corresponds to a weighted sum.\n\nx &lt;- rnorm(10)\nw &lt;- rnorm(10)\nall.equal(sum(x * w), crossprod(x, w)[[1]])\n#&gt; [1] TRUE\n\nA benchmark of both approaches for different vector lengths indicates that the crossprod() variant is almost twice as fast as sum(x * w).\n\nweightedsum &lt;- bench::press(\n  n = 1:10,\n  {\n    x &lt;- rnorm(n * 1e6)\n    bench::mark(\n      sum = sum(x * x),\n      crossprod = crossprod(x, x)[[1]]\n    )\n  }\n)\n#&gt; Running with:\n#&gt;        n\n#&gt;  1     1\n#&gt;  2     2\n#&gt;  3     3\n#&gt;  4     4\n#&gt;  5     5\n#&gt;  6     6\n#&gt;  7     7\n#&gt;  8     8\n#&gt;  9     9\n#&gt; 10    10\n\nweightedsum %&gt;%\n  summary() %&gt;%\n  dplyr::mutate(Approach = as.character(expression)) %&gt;%\n  ggplot(aes(n, median, color = Approach, group = Approach)) +\n  geom_point() +\n  geom_line() +\n  labs(\n    x = \"Vector length (millions)\",\n    y = \"Median (s)\"\n  ) +\n  theme(legend.position = \"top\")"
  },
  {
    "objectID": "24_Improving_performance.html#references",
    "href": "24_Improving_performance.html#references",
    "title": "24 - Improving performance",
    "section": "References",
    "text": "References\n\n\n\n\nArdia, David, Kris Boudt, Peter Carl, Katharine M. Mullen, and Brian G. Peterson. 2011. “Differential Evolution with DEoptim: An Application to Non-Convex Portfolio Optimization.” R Journal 3 (1): 27–34. https://doi.org/10.32614/RJ-2011-005.\n\n\nBergé, Laurent. 2018. “Efficient Estimation of Maximum Likelihood Models with Multiple Fixed-Effects: The R Package FENmlm.” CREA Discussion Papers, no. 13.\n\n\nEddelbuettel, Dirk. 2020. Anytime: Anything to ’POSIXct’ or ’Date’ Converter. https://CRAN.R-project.org/package=anytime.\n\n\nGrolemund, Garrett, and Hadley Wickham. 2011. “Dates and Times Made Easy with lubridate.” Journal of Statistical Software 40 (3): 1–25. https://www.jstatsoft.org/v40/i03/.\n\n\nJames, David, and Kurt Hornik. 2020. Chron: Chronological Objects Which Can Handle Dates and Times. https://CRAN.R-project.org/package=chron.\n\n\nKuhn, Max. 2020. Modeldb: Fits Models Inside the Database. https://CRAN.R-project.org/package=modeldb.\n\n\nLumley, Thomas. 2020. Biglm: Bounded Memory Linear and Generalized Linear Models. https://CRAN.R-project.org/package=biglm.\n\n\nNash, John C. 2014. “On Best Practice Optimization Methods in R.” Journal of Statistical Software 60 (2): 1–14. http://www.jstatsoft.org/v60/i02/.\n\n\nNash, John C., and Ravi Varadhan. 2011. “Unifying Optimization Algorithms to Aid Software System Users: optimx for R.” Journal of Statistical Software 43 (9): 1–14. http://www.jstatsoft.org/v43/i09/.\n\n\nUrbanek, Simon. 2016. Fasttime: Fast Utility Function for Time Parsing and Conversion. https://CRAN.R-project.org/package=fasttime.\n\n\n———. 2017. Fastmatch: Fast Match() Function. https://CRAN.R-project.org/package=fastmatch."
  },
  {
    "objectID": "25_Rewriting_R_code_in_Cpp.html#prerequisites",
    "href": "25_Rewriting_R_code_in_Cpp.html#prerequisites",
    "title": "25 - Rewriting R code in C++",
    "section": "Prerequisites",
    "text": "Prerequisites\nOn our journey through R’s metaprogramming, we continue to use the functions from the {cpp11} (Vaughan, Hester, and François 2023) package.\n\nlibrary(cpp11)"
  },
  {
    "objectID": "25_Rewriting_R_code_in_Cpp.html#getting-started-with-c",
    "href": "25_Rewriting_R_code_in_Cpp.html#getting-started-with-c",
    "title": "25 - Rewriting R code in C++",
    "section": "Getting started with C++",
    "text": "Getting started with C++\nQ1: With the basics of C++ in hand, it’s now a great time to practice by reading and writing some simple C++ functions. For each of the following functions, read the code and figure out what the corresponding base R function is. You might not understand every part of the code yet, but you should be able to figure out the basics of what the function does.\nPay attention to the parts where we use writable::doubles instead of doubles, in C++ objects can be read-only, which is different from R (or Python).\nUnlike R, C++ indexes start at 0, not 1. This is a common source of bugs when porting code from R to C++.\ndouble f1_(doubles x) {\n  int n = x.size();\n  double y = 0;\n  \n  for(int i = 0; i &lt; n; ++i) {\n    y += x[i] / n;\n  }\n  return y;\n}\n\ndoubles f2_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n);\n  \n  out[0] = x[0];\n  for(int i = 1; i &lt; n; ++i) {\n    out[i] = out[i - 1] + x[i];\n  }\n  return out;\n}\n\nbool f3_(logicals x) {\n  int n = x.size();\n  \n  for(int i = 0; i &lt; n; ++i) {\n    if (x[i]) return true;\n  }\n  return false;\n}\n\nint f4_(function pred, list x) {\n  int n = x.size();\n  \n  for(int i = 0; i &lt; n; ++i) {\n    logicals res = pred(x[i]);\n    if (res[0]) return i + 1;\n  }\n  return 0;\n}\n\ndoubles f5_(doubles x, doubles y) {\n  int n = std::max(x.size(), y.size());\n  vector&lt;double&gt; x1(n);\n  vector&lt;double&gt; y1(n);\n\n  for (int i = 0; i &lt; n; ++i) {\n    x1[i] = x[i % x.size()];\n    y1[i] = y[i % y.size()];\n  }\n\n  writable::doubles out(n);\n\n  for (int i = 0; i &lt; n; ++i) {\n    out[i] = std::min(x1[i], y1[i]);\n  }\n\n  return out;\n}\nA: The code above corresponds to the following base R functions:\n\nf1_: mean()\nf2_: cumsum()\nf3_: any()\nf4_: Position()\nf5_: pmin()\n\nQ2: To practice your function writing skills, convert the following functions into C++. For now, assume the inputs have no missing values.\n\nall().\ncumprod(), cummin(), cummax().\ndiff(). Start by assuming lag 1, and then generalise for lag n.\nrange().\nvar(). Read about the approaches you can take on Wikipedia. Whenever implementing a numerical algorithm, it’s always good to check what is already known about the problem.\n\nA: Let’s port these functions to C++.\n\nall()\nbool all_cpp_(logicals x) {\n  int n = x.size();\n  for(int i = 0; i &lt; n; ++i) {\n    if (x[i] == false) {\n      return false;\n    }\n  }\n  return true;\n}\ncumprod(), cummin(), cummax().\ndoubles cumprod_cpp_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n);\n  out[0] = x[0];\n  for(int i = 1; i &lt; n; ++i) {\n    out[i] = out[i - 1] * x[i];\n  }\n  return out;\n}\n\ndoubles cummin_cpp_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n);\n\n  out[0] = x[0];\n  for (int i = 1; i &lt; n; ++i) {\n    double x1 = out[i - 1];\n    double x2 = x[i];\n    out[i] = std::min(x1, x2);\n  }\n\n  return out;\n}\n\ndoubles cummax_cpp_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n);\n\n  out[0] = x[0];\n  for (int i = 1; i &lt; n; ++i) {\n    double x1 = out[i - 1];\n    double x2 = x[i];\n    out[i] = std::max(x1, x2);\n  }\n  return out;\n}\ndiff() (Start by assuming lag 1, and then generalise for lag n.)\ndoubles diff_cpp_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n - 1);\n\n  for (int i = 1; i &lt; n; i++) {\n    out[i - 1] = x[i] - x[i - 1];\n  }\n  return out ;\n}\n\ndoubles diff_lag_cpp_(doubles x, int lag) {\n  int n = x.size();\n\n  if (lag &gt;= n) stop(\"`lag` must be less than `length(x)`.\");\n\n  writable::doubles out(n - lag);\n\n  for (int i = lag; i &lt; n; i++) {\n    out[i - lag] = x[i] - x[i - lag];\n  }\n  return out;\n}\nrange()\ndoubles range_cpp_(doubles x) {\n  double omin = x[0], omax = x[0];\n  int n = x.size();\n\n  if (n == 0) stop(\"`length(x)` must be greater than 0.\");\n\n  for (int i = 1; i &lt; n; i++) {\n    omin = std::min(x[i], omin);\n    omax = std::max(x[i], omax);\n  }\n\n  writable::doubles out(2);\n  out[0] = omin;\n  out[1] = omax;\n  return out;\n}\nvar()\ndouble var_cpp_(doubles x) {\n  int n = x.size();\n\n  if (n &lt; 2) {\n    return NA_REAL;\n  }\n\n  double mx = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    mx += x[i] / n;\n  }\n\n  double out = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    out += pow(x[i] - mx, 2);\n  }\n\n  return out / (n - 1);\n}"
  },
  {
    "objectID": "25_Rewriting_R_code_in_Cpp.html#missing-values",
    "href": "25_Rewriting_R_code_in_Cpp.html#missing-values",
    "title": "25 - Rewriting R code in C++",
    "section": "Missing values",
    "text": "Missing values\nQ1: Rewrite any of the functions from the first exercise to deal with missing values. If na.rm is true, ignore the missing values. If na.rm is false, return a missing value if the input contains any missing values. Some good functions to practice with are min(), max(), range(), mean(), and var().\nA: For this exercise we start with min_cpp_() and extend it so it can deal with missing values. We introduce an na_rm argument to make min_cpp_() aware of NAs. In case x contains exclusively NA values min_cpp_() should return Inf for na_rm = TRUE. For the return values vector data types are used to avoid irregular type conversions.\nWe use expressions provided by #include &lt;cpp11.hpp&gt; to simplify the code:\n\nR_PosInf, which is pure C++ this would be std::numeric_limits&lt;double&gt;::infinity(); and requires #include &lt;limits&gt;.\nis_na(x[i]), which is the same as x[i] == NA_REAL.\n\n#include &lt;cpp11.hpp&gt;\n\nusing namespace cpp11;\n\n[[cpp11::register]] doubles min_cpp_(cpp11::doubles x, bool na_rm) {\n  int n = x.size();\n  writable::doubles out = {R_PosInf};\n\n  if (na_rm) {\n    for (int i = 0; i &lt; n; ++i) {\n      if (x[i] == NA_REAL) {\n        continue;\n      }\n      if (x[i] &lt; out[0]) {\n        out[0] = x[i];\n      }\n    }\n  } else {\n    for (int i = 0; i &lt; n; ++i) {\n      if (is_na(x[i])) {\n        out[0] = NA_REAL;\n        return out;\n      }\n      if (x[i] &lt; out[0]) {\n        out[0] = x[i];\n      }\n    }\n  }\n\n  return out;\n}\n\ncpp_source(\"cpp/01_min.cpp\")\n\nx &lt;- c(2:4, NA)\nmin(x, na.rm = FALSE)\n#&gt; [1] NA\nmin_cpp_(as.double(x), FALSE)\n#&gt; [1] NA\nmin(x, na.rm = TRUE)\n#&gt; [1] 2\nmin_cpp_(as.double(x), TRUE)\n#&gt; [1] 2\n\ny &lt;- c(NA, NA)\nmin(y, na.rm = FALSE)\n#&gt; [1] NA\nmin_cpp_(as.double(y), FALSE)\n#&gt; [1] NA\nmin(y, na.rm = TRUE)\n#&gt; Warning in min(y, na.rm = TRUE): no non-missing arguments to min; returning Inf\n#&gt; [1] Inf\nmin_cpp_(as.double(y), TRUE)\n#&gt; [1] Inf\n\nNote that we added explicit values and types for each parameter. This is necessary because cpp11 does not automatically cast integers (i.e., 2:4) to doubles and does not allow default parameters in the function. This is because R (and Python) automatically cast 1L to 1.0 depending on the context, which is not the case for C++. Run min_cpp_(c(2:4, NA), FALSE) and read the error message carefully.\nTo simplify things for the end user, you can provide a wrapper function that calls min_cpp_() with the correct types and default values.\n\nmin_cpp &lt;- function(x, na_rm = FALSE) {\n  if (!is.double(x)) {\n    x &lt;- as.double(x)\n  }\n  min_cpp_(x, na_rm)\n}\n\nmin_cpp(c(2:4, NA))\n#&gt; [1] NA\n\nWe also extend any_cpp_() so it can deal with missing values. Please note that this (again) introduces some code duplication. This could be avoided by moving the check for missing values to the inner loop at the expense of a slight decrease of performance. Here we use logicals as return type. If we would use bool instead, the C++ NA_LOGICAL would be converted into R’s logical TRUE.\n#include &lt;cpp11.hpp&gt;\n\nusing namespace cpp11;\n\n[[cpp11::register]] logicals any_cpp_(logicals x, bool na_rm) {\n  int n = x.size();\n  writable::logicals out = {false};\n\n  if (na_rm == false) {\n    for (int i = 0; i &lt; n; ++i) {\n      if (is_na(x[i])) {\n        out[0] = NA_LOGICAL;\n        return out;\n      } else {\n        if (x[i]) {\n          out[0] = true;\n        }\n      }\n    }\n  }\n\n  if (na_rm) {\n    for (int i = 0; i &lt; n; ++i) {\n      if (is_na(x[i])) {\n        continue;\n      }\n      if (x[i]) {\n        out[0] = true;\n        return out;\n      }\n    }\n  }\n\n  return out;\n}\n\ncpp_source(\"cpp/02_any.cpp\")\n\nx &lt;- c(NA, TRUE)\nany(x)\n#&gt; [1] TRUE\nany_cpp_(x, F)\n#&gt; [1] NA\nany_cpp_(x, T)\n#&gt; [1] TRUE\n\nQ2: Rewrite cumsum() and diff() so they can handle missing values. Note that these functions have slightly more complicated behaviour.\nA: Our NA-aware cumsum_cpp_() function will return a vector of the same length as x. By default (na_rm = FALSE) all values following the first NA input value will be set to NA, because they depend on the unknown missing value. In case of na_rm = FALSE the NA values are treated like zeros.\n#include &lt;cpp11.hpp&gt;\n\nusing namespace cpp11;\n\n[[cpp11::register]] doubles cumsum_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = y1;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = y2;\n        } else {\n          out[i] = y1 + y2;\n        }\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = y1 + y2;\n        }\n      }\n    }\n  }\n\n  return out;\n}\n\ncpp_source(\"cpp/03_cumsum.cpp\")\n\nx &lt;- c(1, NA, 2, 4)\ncumsum(x)\n#&gt; [1]  1 NA NA NA\ncumsum_cpp_(c(1, NA, 2, 4), FALSE)\n#&gt; [1]  1 NA NA NA\ncumsum_cpp_(c(1, NA, 2, 4), TRUE)\n#&gt; [1] 1 1 3 7\n\nThis example works immediately, because the input vector is a vector of doubles. If we create a sequence of integers, we need to cast it as doubles.\n\ncumsum_cpp_(as.double(1:4), FALSE)\n#&gt; [1]  1  3  6 10\n\n# or use a wrapper function\ncumsum_cpp &lt;- function(x, na_rm = FALSE) {\n  if (!is.double(x)) {\n    x &lt;- as.double(x)\n  }\n  cumsum_cpp_(x, na_rm)\n}\n\ncumsum_cpp(1:4, FALSE)\n#&gt; [1]  1  3  6 10\n\nThe diff_cpp_() implementation will return an NA vector of length length(x) - lag, if the input vector contains a missing value. In case of na_rm = TRUE, the function will return an NA for every difference with at least one NA as input.\n#include &lt;cpp11.hpp&gt;\n\nusing namespace cpp11;\n\n[[cpp11::register]] doubles diff_cpp_(doubles x, int lag, bool na_rm) {\n  int n = x.size();\n\n  if (lag &gt;= n) stop(\"`lag` must be less than `length(x)`.\");\n\n  writable::doubles out(n - lag);\n\n  for (int i = lag; i &lt; n; i++) {\n    if (is_na(x[i]) || is_na(x[i - lag])) {\n      if (!na_rm) {\n        writable::doubles out_na(n - lag);\n        for (int j = 0; j &lt; n - lag; ++j) {\n          out_na[j] = NA_REAL;\n        }\n        return out_na;\n      }\n      out[i - lag] = NA_REAL;\n      continue;\n    }\n    out[i - lag] = x[i] - x[i - lag];\n  }\n\n  return out;\n}\n\ncpp_source(\"cpp/04_diff.cpp\")\n\nx &lt;- c(1, 3, NA, 10)\ndiff(x, 1L)\n#&gt; [1]  2 NA NA\ndiff_cpp_(x, 1L, FALSE)\n#&gt; [1] NA NA NA\ndiff_cpp_(x, 1L, TRUE)\n#&gt; [1]  2 NA NA"
  },
  {
    "objectID": "25_Rewriting_R_code_in_Cpp.html#standard-template-library",
    "href": "25_Rewriting_R_code_in_Cpp.html#standard-template-library",
    "title": "25 - Rewriting R code in C++",
    "section": "Standard Template Library",
    "text": "Standard Template Library\nTo practice using the STL algorithms and data structures, implement the following using R functions in C++, using the hints provided:\nQ1: median.default() using partial_sort.\nA: The median is computed differently for even or odd vectors, which we allow for in the function below.\nTo be able to use partial_sort() we need to include the algorithm header. Unlike the previous examples, the input will be const doubles& x, meaning that the function takes a constant reference to an object of type doubles (i.e., the function will not modify the object x), and the & symbol means that the function takes a reference to the object instead of a copy of the object.\nThis can improve performance when the object is large, because it avoids copying the object, but in this case we did it to use the partial_sort() function, which is not compatible with doubles but it is with vector&lt;double&gt; types.\ndoubles is a data type we can send from R to C++ and vice-versa, but it is not compatible with all of C++ functions. vector&lt;double&gt; is a C++ data type that we cannot send to R. There are more details about this in the alternative solutions section at the end of the chapter.\n#include &lt;algorithm&gt;\n#include &lt;cpp11.hpp&gt;\n#include &lt;vector&gt;\n\nusing namespace cpp11;\nusing namespace std;\n\n[[cpp11::register]] double median_cpp_(const doubles& x) {\n  int n = x.size();\n\n  vector&lt;double&gt; y(n);\n  for (int i = 0; i &lt; n; ++i) {\n    y[i] = x[i];\n  }\n\n  if (n % 2 == 0) {\n    partial_sort(y.begin(), y.begin() + n / 2 + 1, y.end());\n    return (y[n / 2 - 1] + y[n / 2]) / 2;\n  } else {\n    partial_sort(y.begin(), y.begin() + (n + 1) / 2, y.end());\n    return y[(n + 1) / 2 - 1];\n  }\n}\n\ncpp_source(\"cpp/05_median.cpp\")\n\nx &lt;- c(1, 2, 3)\nmedian(x)\n#&gt; [1] 2\nmedian_cpp_(x)\n#&gt; [1] 2\n\nQ2: %in% using unordered_set and the find() or count() methods.\nA: We use the find() method and loop through the unordered_set until we find a match or have scanned the entire set.\n#include &lt;cpp11.hpp&gt;\n#include &lt;unordered_set&gt;\n\nusing namespace cpp11;\nusing namespace std;\n\n[[cpp11::register]] logicals in_cpp_(const strings& x, const strings& table) {\n  unordered_set&lt;string&gt; seen;\n  seen.insert(table.begin(), table.end());\n\n  int n = x.size();\n  writable::logicals out(n);\n  for (int i = 0; i &lt; n; ++i) {\n    out[i] = seen.find(x[i]) != seen.end();\n  }\n\n  return out;\n}\n\ncpp_source(\"cpp/06_in.cpp\")\n\nx &lt;- letters[1:3]\ny &lt;- letters[1:2]\nin_cpp_(x, y)\n#&gt; [1]  TRUE  TRUE FALSE\nx %in% y\n#&gt; [1]  TRUE  TRUE FALSE\n\nQ3: unique() using an unordered_set (challenge: do it in one line!).\nA: The insert()-method will return if an equivalent element already exists. If a new element is inserted, we will add it to the (unique) return vector of our function.\nFirst we will implement the function in multiple lines, and then reduce.\n#include &lt;cpp11.hpp&gt;\n#include &lt;unordered_set&gt;\n\nusing namespace cpp11;\nusing namespace std;\n\n[[cpp11::register]] doubles unique_cpp_(const doubles& x) {\n  unordered_set&lt;double&gt; seen;\n  int n = x.size();\n\n  writable::doubles out;\n  for (int i = 0; i &lt; n; ++i) {\n    if (seen.insert(x[i]).second) out.push_back(x[i]);\n  }\n\n  return out;\n}\nIn one line we would need to write a wrapper function in C++ to be able to export the result to R.\n#include &lt;cpp11.hpp&gt;\n#include &lt;unordered_set&gt;\n\nusing namespace cpp11;\nusing namespace std;\n\nunordered_set&lt;double&gt; unique_short1_cpp_(const doubles& x) {\n  return unordered_set&lt;double&gt;(x.begin(), x.end());\n}\n\n[[cpp11::register]] doubles unique_short2_cpp_(const doubles& x) {\n  unordered_set&lt;double&gt; y = unique_short1_cpp_(x);\n\n  int n = y.size();\n  writable::doubles out(n);\n  copy(y.begin(), y.end(), out.begin());\n\n  return out;\n}\n\ncpp_source(\"cpp/07_unique.cpp\")\ncpp_source(\"cpp/08_unique_short.cpp\")\n\nx &lt;- c(1, 2, 2)\nunique(x)\n#&gt; [1] 1 2\nunique_cpp_(x)\n#&gt; [1] 1 2\nunique_short2_cpp_(x)\n#&gt; [1] 2 1\n\nQ4: min() using std::min(), or max() using std::max().\nA: We will implement min() by iterating over the vector and recursively comparing each element to the current minimum value.\nIn this example, and unlike the previous min_cpp_(), we can assign x[i] from a doubles object to the left hand side that is a double variable without the need to convert data types.\n#include &lt;cpp11.hpp&gt;\n\nusing namespace cpp11;\nusing namespace std;\n\n[[cpp11::register]] double min_cpp_(const doubles& x) {\n  int n = x.size();\n  double out = x[0];\n\n  for (int i = 0; i &lt; n; i++) {\n    out = min(out, x[i]);\n  }\n\n  return out;\n}\n\ncpp_source(\"cpp/09_min.cpp\")\n\nx &lt;- c(-1, 0, 1)\nmin(x)\n#&gt; [1] -1\nmin_cpp_(x)\n#&gt; [1] -1\n\nQ5: which.min() using min_element, or which.max() using max_element.\nA: To implement which.min(), we will first locate the min_element and then compute the distance() to it (starting from the beginning of the vector).\nCheck the +1 in the return statement, which was included because of zero indexes as it was mentioned in the beginning of the chapter.\n#include &lt;algorithm&gt;\n#include &lt;cpp11.hpp&gt;\n#include &lt;iterator&gt;\n\nusing namespace cpp11;\nusing namespace std;\n\n[[cpp11::register]] double which_min_cpp_(const doubles& x) {\n  int out = distance(x.begin(), min_element(x.begin(), x.end())\n  );\n\n  return out + 1;\n}\n\ncpp_source(\"cpp/10_which_min.cpp\")\n\nx &lt;- c(1, -1)\nwhich.min(x)\n#&gt; [1] 2\nwhich_min_cpp_(x)\n#&gt; [1] 2\n\nQ6: setdiff(), union(), and intersect() for integers using sorted ranges and set_union, set_intersection and set_difference.\nA: The structure of the three functions will be very similar.\nWe first sort both input vectors. Then we apply the respective set_union, set_intersection or set_difference function. After that, the result will be between the iterators tmp.begin() and out_end. To retrieve the result, we loop once through the range between tmp.begin() and out_end in the last part of each function.\nThe set operations in base R will discard duplicated values in the arguments. We achieve a similar behaviour by introducing a deduplication step, which omits values that match their predecessor. For the C++ implementation we rely on the properties of the set operations and the fact that the input vectors are sorted.\nWe also use variables of type vector&lt;int&gt;::iterator, which are used to point to elements in a vector&lt;int&gt;.\n#include &lt;algorithm&gt;\n#include &lt;cpp11.hpp&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\n\nusing namespace cpp11;\nusing namespace std;\n\n[[cpp11::register]] integers union_cpp_(const integers& x, const integers& y) {\n  vector&lt;int&gt; vx(x.begin(), x.end());\n  vector&lt;int&gt; vy(y.begin(), y.end());\n\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n\n  vector&lt;int&gt; tmp(vx.size() + vy.size());\n\n  vector&lt;int&gt;::iterator out_end =\n      set_union(vx.begin(), vx.end(), vy.begin(), vy.end(), tmp.begin());\n\n  int prev_value = 0;\n  writable::integers out;\n\n  for (vector&lt;int&gt;::iterator it = tmp.begin(); it != out_end; ++it) {\n    if ((it != tmp.begin()) && (prev_value == *it)) continue;\n\n    out.push_back(*it);\n\n    prev_value = *it;\n  }\n\n  return out;\n}\n\n[[cpp11::register]] integers intersect_cpp_(const integers& x,\n                                            const integers& y) {\n  vector&lt;int&gt; vx(x.begin(), x.end());\n  vector&lt;int&gt; vy(y.begin(), y.end());\n\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n\n  vector&lt;int&gt; tmp(min(vx.size(), vy.size()));\n\n  vector&lt;int&gt;::iterator out_end =\n      set_intersection(vx.begin(), vx.end(), vy.begin(), vy.end(), tmp.begin());\n\n  writable::integers out;\n\n  for (vector&lt;int&gt;::iterator it = tmp.begin(); it != out_end; ++it) {\n    out.push_back(*it);\n  }\n\n  return out;\n}\n\n[[cpp11::register]] integers setdiff_cpp_(const integers& x,\n                                          const integers& y) {\n  vector&lt;int&gt; vx(x.begin(), x.end());\n  vector&lt;int&gt; vy(y.begin(), y.end());\n\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n\n  vector&lt;int&gt; tmp(vx.size());\n\n  vector&lt;int&gt;::iterator out_end =\n      set_difference(vx.begin(), vx.end(), vy.begin(), vy.end(), tmp.begin());\n\n  writable::integers out;\n\n  for (vector&lt;int&gt;::iterator it = tmp.begin(); it != out_end; ++it) {\n    out.push_back(*it);\n  }\n\n  return out;\n}\nLet’s verify, that these functions work as intended.\n\ncpp_source(\"cpp/11_set_operations.cpp\")\n\n# input vectors include duplicates\nx &lt;- 1:3\ny &lt;- 0:5\n\nunion(x, y)\n#&gt; [1] 1 2 3 0 4 5\nunion_cpp_(x, y)\n#&gt; [1] 0 1 2 3 4 5\n\nintersect(x, y)\n#&gt; [1] 1 2 3\nintersect_cpp_(x, y)\n#&gt; [1] 1 2 3\n\nx &lt;- 1:3\ny &lt;- 0:1\n\nsetdiff(x, y)\n#&gt; [1] 2 3\nsetdiff_cpp_(x, y)\n#&gt; [1] 2 3"
  },
  {
    "objectID": "25_Rewriting_R_code_in_Cpp.html#alternative-solutions",
    "href": "25_Rewriting_R_code_in_Cpp.html#alternative-solutions",
    "title": "25 - Rewriting R code in C++",
    "section": "Alternative solutions",
    "text": "Alternative solutions\n\nAll\nThe all_cpp_() function can be implemented at least in three more ways.\nI can save lines by not defining n.\nbool all_cpp_(logicals x) {\n  for (int i = 0; i &lt; x.size(); ++i) {\n    if (x[i] == false) {\n      return false;\n    }\n  }\n  return true;\n}\nIt is also possible to directly define a logical variable i inside the loop.\nbool all_cpp_(logicals x) {\n  for (bool i : x) {\n    if (i == false) {\n      return false;\n    }\n  }\n  return true;\n}\nUsing std::all_of() you can do the same thing in one line.\nbool all_cpp_(logicals x) {\n  return std::all_of(x.begin(), x.end(), [](bool x) { return x; });\n}\n\n\nPairwise minimum\nUnlike cumprod_cpp_(), cummin_cpp_() requires to declare additional double values, otherwise std::min() will not work.\nIt is possible to save some lines by using std::vector.\n#include &lt;cpp11.hpp&gt;\n#include &lt;vector&gt;\n\nusing namespace cpp11;\nusing namespace std;\n\n[[cpp11::register]] doubles pmin_cpp_(doubles x, doubles y) {\n  int n = max(x.size(), y.size());\n\n  vector&lt;double&gt; x1(n);\n  vector&lt;double&gt; y1(n);\n  for (int i = 0; i &lt; n; ++i) {\n    x1[i] = x[i % x.size()];\n    y1[i] = y[i % y.size()];\n  }\n\n  writable::doubles out(n);\n\n  for (int i = 0; i &lt; n; ++i) {\n    out[i] = min(x1[i], y1[i]);\n  }\n\n  return out;\n}\nWe can subset x1 and y1 when these are of class vector&lt;double&gt; instead of doubles because x1[i] and y1[i] are of class double. When x1 and y1 are of class doubles, x1[i] and y1[i] are proxy objects that represent elements of x1 and y1\nPassing proxies to std::min(), which returns a reference to its smallest argument, creates an output that is a new proxy object that cannot be assigned to out[i]."
  },
  {
    "objectID": "25_Rewriting_R_code_in_Cpp.html#references",
    "href": "25_Rewriting_R_code_in_Cpp.html#references",
    "title": "25 - Rewriting R code in C++",
    "section": "References",
    "text": "References\n\n\n\n\nVaughan, Davis, Jim Hester, and Romain François. 2023. Cpp11: A c++11 Interface for r’s c Interface. https://CRAN.R-project.org/package=cpp11."
  }
]